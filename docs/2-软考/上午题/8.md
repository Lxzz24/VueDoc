---
title: 8-设计模式 ⑩ ✅
sidebarDepth: 1
category: 软考笔记
tag: 软考
---

::: details 目录
[[toc]]
:::



## 🍀 设计模式的要素

设计模式的核心在于提供了相关问题的解决方案，使得人们可以更加简单方便地 **复用成功的设计和体系结构**。

设计模式基本要素：

- 模式名称（Pattern Name）
- 问题（Problem）
- 解决方案（Solution）
- 效果（Consequences）

![](./assets/image-20230417151608470.png =800x)




## 🍀 创建型设计模式（5 种）


:::: tabs

@tab 0

### Simple Factory（简单工厂）

::: tip 创建对象不对外暴露细节
:::


- 简单工厂模式属创建型模式，~~但不属于 23 种设计模式之一~~。

#### （1）意图

在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。

> - 定义：定义一个工厂类，他可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。在简单工厂模式中用于被创建实例的方法通常为静态 (static) 方法，因此简单工厂模式又被成为静态工厂方法
> - *简单工厂模式违反了开放封闭原则，即对扩展开放对修改也开放*。


#### （2）类图

![简单工厂](./assets/image-20240430091347439.png =500x)

<details>
<summary><mark>查看代码</mark></summary>

```java {13,19-21,23-24}
public class SimpleFactory {
    public static void main(String[] args) {
        Product productA = Factory.createProduct("A");
        productA.info();
 
        Product productB = Factory.createProduct("B");
        productB.info();
 
    }
}
 
class Factory{
    public static Product createProduct(String type){
        Product product = null;
 
        switch (type){
            case "A":
                product = new ProductA();
                break;
            case "B":
                product = new ProductB();
                break;
            default:
                System.out.println("没有 " + type + " 类型的产品！");
                return null;
        }
        return product;
    }
}
 
abstract class Product{
    public abstract void info();
}
 
class ProductA extends Product{
 
    @Override
    public void info() {
        System.out.println("产品的信息：A");
    }
}
 
class ProductB extends Product{
 
    @Override
    public void info() {
        System.out.println("产品的信息：B");
    }
}
```

</details>


@tab 1

### 1. Factory Method（工厂方法）

> 创建型**类**模式

::: tip 定义创建对象的接口，子类进行实例化
:::


#### （1）意图

定义一个创建对象的接口，让子类决定实例化哪个类。*Factory Method 把实例化操作延迟到子类。*

#### （2）类图  

![工厂方法](./assets/image-20240430094024755.png =500x)

#### （3）适用性

工厂模式适用于
- *当一个类不知道它所必须创建的对象的类的时候*。 
- 当一个类希望由它的子类来指定它所创建的对象的时候。 
- 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。❓


<details>
<summary><mark>查看代码</mark></summary>

```java {15-17,22-24,30-32}
public class FactoryMethod {
    public static void main(String[] args) {
        
        Factory factoryA = new FactoryA();
        Product productA = factoryA.createProduct();
        productA.info();
 
        Factory factoryB = new FactoryB();
        Product productB = factoryB.createProduct();
        productB.info();
 
    }
}
 
interface Factory{
   Product createProduct();
}
 
class FactoryA implements Factory{
 
    @Override
    public Product createProduct() {
        return new ProductA();
    }
}
 
class FactoryB implements Factory{
 
    @Override
    public Product createProduct() {
        return new ProductB();
    }
}
 
interface Product{
    void info();
}
 
class ProductA implements Product{
 
    @Override
    public void info() {
        System.out.println("产品的信息：A");
    }
}
 
class ProductB implements Product{
 
    @Override
    public void info() {
        System.out.println("产品的信息：B");
    }
}
```

</details>

@tab 2


### 2. Abstract Factory（抽象工厂）

::: tip 创建一系列对象
:::


#### （1）意图

提供一个创建**一系列**相关或相互依赖对象的接口，而无须指定它们具体的类。

> 提供一个接口，用于创建 *相关的对象家族* 

#### （2）类图

![抽象工厂](./assets/image-20240430095030350.png =800x)

#### （3）适用性

Abstract Factory 模式适用于
- 一个系统要独立于它的产品的创建、**组合**和表示时。
- 一个系统要由多个产品系列中的一个来配置时。
- 当要强调一系列相关的产品对象的设计以便进行联合使用时。
- 当提供一个产品类库，只想显示它们的接口而不是实现时。

<details>
<summary><mark>查看代码</mark></summary>

```java {21-22,26,30,35,43,48,39}
public class AbstractFactory {
 
    public static void main(String[] args) {
        Factory factory1 = new Factory1();
        ProductA productA1 = factory1.createProductA();
        productA1.info();
        ProductB productB1 = factory1.createProductB();
        productB1.info();
 
        Factory factory2 = new Factory2();
        ProductA productA2 = factory2.createProductA();
        productA2.info();
        ProductB productB2 = factory2.createProductB();
        productB2.info();
 
    }
}
 
// 声明一个创建抽象产品对象的操作接口
interface Factory{
   ProductA createProductA();
   ProductB createProductB();
}
 
// 实现创建具体产品对象的操作
class Factory1 implements Factory{
 
    @Override
    public ProductA createProductA() {
        return new ProductA1();
    }
 
    @Override
    public ProductB createProductB() {
        return new ProductB1();
    }
}
 
class Factory2 implements Factory{
 
    @Override
    public ProductA createProductA() {
        return new ProductA2();
    }
 
    @Override
    public ProductB createProductB() {
        return new ProductB2();
    }
}
 
// 为一类产品对象声明一个接口
interface ProductA{
    void info();
}
 
interface ProductB{
    void info();
}
 
// 定义一将被相应的具体工厂创建的产品对象
class ProductA1 implements ProductA{
 
    @Override
    public void info() {
        System.out.println("产品的信息：A1");
    }
}
 
class ProductA2 implements ProductA{
 
    @Override
    public void info() {
        System.out.println("产品的信息：A2");
    }
}
 
class ProductB1 implements ProductB{
 
    @Override
    public void info() {
        System.out.println("产品的信息：B1");
    }
}
 
class ProductB2 implements ProductB{
 
    @Override
    public void info() {
        System.out.println("产品的信息：B2");
    }
}
```

</details>


@tab 3

### 3. Builder（生成器/建造者）

::: tip 构建复杂对象：类似于组装
:::


#### （1）意图

将一个**复杂对象**的构建与它的表示分离，使得同样的**构建过程**可以创建不同的表示。

> 封装一个对象的构造过程，并允许按步骤构造。

#### （2）类图  

![生成器](./assets/image-20230414134325945.png =800x)

#### （3）适用性

Builder 模式适用于
- 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。
- 当构造过程必须允许被构造的对象有不同的表示时。


> 可以将 Builder 理解为一个抽象套餐，ConcreteBuilder 为一个具体套餐

<details>
<summary><mark>查看代码</mark></summary>

```java {18-20,24-25,68,70-72}
public class Main {
    public static void main(String[] args) {
        Director director = new Director();
 
        Builder builder1 = new Builder1();
        director.Construct(builder1);
        Product product1 = builder1.getResult();
        product1.show();
 
        Builder builder2 = new Builder2();
        director.Construct(builder2);
        Product product2 = builder2.getResult();
        product2.show();
    }
}
 
class Director{
    public void Construct(Builder builder){
        builder.BuildPart();
    }
}

abstract class Builder{
    public abstract void BuildPart();
    public abstract Product getResult();
}
 
class Builder1 extends Builder{
 
    Product product = new Product();
 
    @Override
    public void BuildPart() {
        product.add("A");
        product.add("B");
        product.add("C");
        product.add("D");
        product.add("E");
        product.add("F");
    }
 
    @Override
    public Product getResult() {
 
        return product;
    }
}
 
class Builder2 extends Builder{
 
    Product product = new Product();
 
    @Override
    public void BuildPart() {
        product.add("A");
        product.add("B");
        product.add("C");
    }
 
    @Override
    public Product getResult() {
 
        return product;
    }
}
 
class Product{
    List<String> parts = new ArrayList<String>();
 
    public void add(String part){
        parts.add(part);
    }
 
    public void show(){
        System.out.print("产品的组成：");
        for (String part : parts) {
            System.out.print(part + " ");
        }
        System.out.println();
    }
}
```

</details>


@tab 4

### 4. Prototype（原型）

::: tip 复制
:::

#### （1）意图

用原型实例指定创建对象的类型，并且通过**复制**这些原型创建新的对象。

#### （2）类图  

![原型](./assets/image-20240430104802365.png =800x)

- Prototype 声明一个复制自身的接口。
- ConcretePrototype 实现一个复制自身的操作。
- Client 让一个原型复制自身从而创建一个新的对象

#### （3）适用性

Prototype 模式适用于
- 当一个系统应该独立于它的产品创建、**构成**和表示时。
- 当要实例化的类是在运行时刻指定时，例如，通过动态装载。
- 为了避免创建一个与产品类层次平行的工厂类层次时。
- 当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们，可能比每次用合适的状态手工实例化该类更方便一些。

<details>
<summary><mark>查看代码</mark></summary>

```java {13,37-43}
public class Main {
    public static void main(String[] args) {
        Product product1 = new Product(2022,5.28);
        System.out.println(product1.getId()+ " " + product1.getPrice());
 
        Product product2 = (Product) product1.Chlone();
        System.out.println(product2.getId()+ " " + product2.getPrice());
 
    }
}
 
interface Prototype{
    Object Clone();
}
 
class Product implements Prototype{
 
    private int id;
    private double price;
 
    public Product(){}
 
    public Product(int id,double price){
        this.id = id;
        this.price = price;
    }
 
    public int getId() {
        return id;
    }
 
    public double getPrice() {
        return price;
    }
 
    @Override
    public Object Clone() {
        Product object = new Product();
        object.id = this.id;
        object.price = this.price;
 
        return object;
    }
}
```

</details>

@tab 5

### 5. Singleton（单例）

::: tip 仅有一个实例
:::


#### （1）意图

保证一个类**仅有**一个实例，并提供一个访问它的**全局访问点**。

#### （2）类图  

![](./assets/image-20230414153516687.png =800x)

- 其中：Singleton 指定一个 Instance 操作，允许客户访问它的唯一实例，Instance 是一个类
- 操作：可能负责创建它自己的唯一实例。

#### （3）适用性

Singleton 模式适用于：
- 当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。
- 当这个唯一实例应该是通过子类化可扩展的，并且客户无须更改代码就能使用一个扩展的实例时。

<details>
<summary><mark>查看代码</mark></summary>

```java {14,16,18-20}
public class SingletonPattern {
    public static void main(String[] args) {
        Singleton instance1 = Singleton.getInstance();
        Singleton instance2 = Singleton.getInstance();
        Singleton instance3 = Singleton.getInstance();
 
        System.out.println("instance1: " + instance1);
        System.out.println("instance2: " + instance2);
        System.out.println("instance3: " + instance3);
    }
}
 
class Singleton {
    private static Singleton instance = new Singleton();
 
    private Singleton(){};
 
    public static Singleton getInstance(){
        return instance;
    }
}
```

![](./assets/image-20230414154430890.png =500x)

</details>


::::



## 🍀 结构型设计模式（7 种）

:::: tabs

@tab 1

### 🌸 1. Adapter（适配器）

::: tip 接口适配
:::

#### （1）意图

将一个类的接口转换成另一个用户需要的接口。

![](./assets/3d5b828e-5c4d-48d8-a440-281e4a8e1c92.png)

Adapter 模式使得原本由于**接口不兼容**而不能一起工作的那些类可以一起工作。

#### （2）类图    


![适配器类模式（了解）](./assets/image-20240430110220613.png =800x)

![适配器对象模式](./assets/image-20240430110413021.png =800x)    

其中：
- Target 定义 Client 使用的与特定领域相关的接口。
- Client 与符合 Target 接口的对象协同。
- Adaptee 定义一个已经存在的接口，这个接口需要适配。
- Adapter 对 Adaptee 的接口与 Target 接口进行适配。

#### （3）适用性

Adapter 模式适用于
- *想使用一个已经存在的类，而它的接口不符合要求。*
- 想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。（了解）
- (仅适用于对象 Adapter) 想使用一个已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。（了解）



<details>
<summary><mark>查看代码</mark></summary>

```java {14-20}
public class AdapterPattern {
    public static void main(String[] args) {
        Target target = new Adapter();
        target.Request();
    }
}
 
class Target{
    public void Request(){
        System.out.println("普通请求~");
    }
}

class Adapter extends Target {
    private Adaptee adaptee = new Adaptee();
    @Override
    public void Request() {
        adaptee.SpecificRequest();
    }
}
 
class Adaptee{
    public void SpecificRequest(){
        System.out.println("特殊请求~");
    }
}
```

</details>


@tab 2

### 🌸 2. Bridge（桥接）

::: tip 抽象与实现分离
:::

#### （1）意图

将抽象部分与其实现部分**分离**，使它们都可以*独立地变化*。

#### （2）类图

![桥接](./assets/image-20230414163901596.png =800x)

#### （3）适用性

- 不希望在抽象和它的实现部分之间有一个固定的绑定关系。
- 类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。
- 对一个抽象的实现部分的修改应对客户不产生影响，即客户代码不必重新编译。(C++) 想对客户完全隐藏抽象的实现部分。
- 有许多类要生成的类层次结构。
- 想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点。


<details>
<summary><mark>查看代码</mark></summary>

```java {34,38,44-46}
public class BridgePattern {
    public static void main(String[] args) {
        Product productA = new ProductA();
        Product productB = new ProductA();
 
        Color red = new Red();
        productA.setName("产品A");
        productA.setColor(red);
        productA.Operation();
 
        Blue blue = new Blue();
        productB.setName("产品B");
        productB.setColor(blue);
        productB.Operation();
    }
}
 
abstract class Product{
    private String name;
    protected Color color;
 
    public void setName(String name){
        this.name = name;
    }
 
    public String getName(){
        return name;
    }
 
    public void setColor(Color color){
        this.color = color;
    }
 
    public abstract void Operation();
}
 
interface Color{
    void OperationImpl(String name);
}
 
class ProductA extends Product{
 
    @Override
    public void Operation() {
        color.OperationImpl(this.getName());
    }
}
 
class Red implements Color{
 
    @Override
    public void OperationImpl(String name) {
        System.out.println(name + ": 红色" );
    }
}
 
class Blue implements Color{
 
    @Override
    public void OperationImpl(String name) {
        System.out.println(name + ": 蓝色" );
    }
}
```

</details>


@tab 3

### 🌸 3. Composite（组合）

::: tip 部分-整体
:::

#### （1）意图

将对象组合成树型结构以表示 **“部分-整体”** 的层次结构。Composite 使得用户对单个对象和组合对象的使用具有**一致性**。
   
> 例如，文件-文件夹

#### （2）类图  

![组合](./assets/image-20240430135919199.png =800x)

其中：  
- *Component* 为组合中的对像 *声明接口*：在适当情况下实现所有类共有接口的默认行为：声明一个接口用于访问和管理 Component 的子组件；（可选）在递归结构中定义一个接口，用于访问一个父组件，并在合适的情况下实现它。
- *Leaf* 在组合中表示叶结点对象，叶结点没有子结点；在组合中 *定义图元对象的行为*。
- *Composite* *定义有子组件的那些组件的行为*；存储子组件；在 Component 接口中实现与子组件有关的操作。
- *Client 通过 Component 接口操纵组合组件的对象*。

#### （3）适用性

Composite 模式下适用于：
- 想表示对象的 “部分-整体” 层次结构。
- 希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。


<details>
<summary><mark>查看代码</mark></summary>

```java {28-29,33-35,46-48,72}
import java.util.*;

public class CompositePattern {
    public static void main(String[] args) {
        // 父类名 对象名 = new 子类名();
        AbstractFile root = new Folder("root");
 
        AbstractFile folderA = new Folder("folderA");
        AbstractFile folderB = new Folder("folderB");
 
        AbstractFile fileC = new File("fileC");
        AbstractFile fileD = new File("fileD");
        AbstractFile fileE = new File("fileE");
 
        root.Add(folderA);
        root.Add(folderB);
        root.Add(fileC);
 
        folderA.Add(fileD);
        folderA.Add(fileE);
 
        print(root);
    }
 
    static void print(AbstractFile file){
        file.printName();
 
        List<AbstractFile> childrenList = file.getChildren();
        if (childrenList == null){
            return;
        }
 
        for (AbstractFile children : childrenList) {
            print(children);
        }
    }
}
 
abstract class AbstractFile{
    protected String name;
 
    public void printName(){
        System.out.println(name);
    }
 
    public abstract boolean Add(AbstractFile file);
    public abstract boolean Remove(AbstractFile file);
    public abstract List<AbstractFile> getChildren();
 
}
 
class Folder extends AbstractFile {
 
    private List<AbstractFile> childrenList = new ArrayList<>();
 
    public Folder(String name) {
        this.name = name;
    }
 
    @Override
    public boolean Add(AbstractFile file) {
        return childrenList.add(file);
    }
 
    @Override
    public boolean Remove(AbstractFile file) {
        return childrenList.remove(file);
    }
 
    @Override
    public List<AbstractFile> getChildren() {
        return childrenList;
    }
}
 
class File extends AbstractFile{
    public File(String name) {
        this.name = name;
    }
 
    @Override
    public boolean Add(AbstractFile filei) {
        return false;
    }
 
    @Override
    public boolean Remove(AbstractFile file) {
        return false;
    }
 
    @Override
    public List<AbstractFile> getChildren() {
        return null;
    }
}
```

</details>

@tab 4


### 4. Decorator（装饰）

::: tip 为对象动态添加功能
:::

#### （1）意图

动态地给一个对象添加一些*额外的职责*。就增加功能而言，Decorator 模式比生成子类更加灵活。

#### （2）类图  

![装饰](./assets/image-20240430145021730.png =800x)  

其中：  
- Component 定义一个对象接口，可以给这些对象动态地添加职责。
- ConcreteComponent 定义一个对象，可以给这个对象添加一些职责。
- Decorator 维持一个指向 Component 对象的指针，并定义一个与 Component 接口一致的接口。
- ConcreteDecorator 向组件添加职责。

#### （3）适用性

Decorator 模式适用于：

- 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。
- 处理那些可以撤销的职责。
- 当不能采用生成子类的方式进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是，由于类定义被隐藏，或类定义不能用于生成子类。（了解）


<details>
<summary><mark>查看代码</mark></summary>

```java {4-5,11,17,21,33}
public class DecoratorPattern {
    public static void main(String[] args) {
        Person zhangsan = new Student("张三");
        zhangsan = new DecoratorA(zhangsan);
        zhangsan = new DecoratorB(zhangsan);
        zhangsan.Operation();
 
        System.out.println("==========分割线==============");
 
        // 对像链
        Person lisi = new DecoratorB(new DecoratorA(new Student("李四")));
        lisi.Operation();
 
    }
}
 
abstract class Decorator extends Person{
    protected Person person;
}
 
class DecoratorA extends Decorator{
    public DecoratorA(Person person){
        this.person = person;
    }
 
    @Override
    public void Operation() { // 职责
        person.Operation(); // 原本的职责
        System.out.println("写作业~");
    }
}
 
class DecoratorB extends Decorator{
    public DecoratorB(Person person){
        this.person = person;
    }
 
    @Override
    public void Operation() { // 职责
        person.Operation(); // 原本的职责
        System.out.println("考试~");
    }
}
 
abstract class Person{
    protected String name;
 
    public abstract void Operation(); // 职责
 
}
 
class Student extends Person{
    public Student(String name){
        this.name = name;
    }
 
    @Override
    public void Operation() {
        System.out.println(name + "的职责：学习~");
    }
}
```

</details>


@tab 5


### 5. Facade（外观）

::: tip 提供一个统一的接口来访问子系统中的一群接口
:::

#### （1）意图

为**子系统**中的**一组接口**提供一个一致的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

#### （2）类图

![](./assets/image-20230415135923577.png =800x)

其中：
- Facade 知道哪些子系统类负责处理请求；将客户的请求代理给适当的子系统对象。
- Subsystem classes 实现子系统的功能；处理有 Facade 对象指派的任务；没有 Facade 的任何相关信息，即没有指向 Facade 的指针。

#### （3）适用性

Facade 模式适用于
- *要为一个复杂子系统提供一个简单接口时*。
- 客户程序与抽象类的实现部分之间存在着很大的依赖性。
- 当需要构建一个层次结构的子系统时，使用 Facade 模式定义子系统中每层的入口点。



<details>
<summary><mark>查看代码</mark></summary>

```java {19-21}
import java.util.Scanner;

public class FacadePattern {
    public static void main(String[] args) {
        Facade facade = new Facade();
 
        facade.methodA();
        facade.methodB();
        facade.methodC();
    }
}
 
class Facade{
    SubSystemOne subSystemOne;
    SubSystemTwo subSystemTwo;
    SubSystemThree subSystemThree;
 
    public Facade(){
        subSystemOne = new SubSystemOne();
        subSystemTwo = new SubSystemTwo();
        subSystemThree = new SubSystemThree();
    }
 
    public void methodA(){
        subSystemOne.methodOne();
    }
 
    public void methodB(){
        subSystemTwo.methodTwo();
    }
 
    public void methodC(){
        subSystemThree.methodThree();
    }
}
 
class SubSystemOne{
    public void methodOne(){
        System.out.println("执行子系统一的功能~");
    }
}
 
class SubSystemTwo{
    public void methodTwo(){
        System.out.println("执行子系统二的功能~");
    }
}
 
class SubSystemThree{
    public void methodThree(){
        System.out.println("执行子系统三的功能~");
    }
}
```

</details>

@tab 6

### 6. Flyweight（享元）

::: tip 共享创建的对象
:::

#### （1）意图

运用**共享技术**有效地支持**大量**细粒度的对象。

> 减少创建的对象的数量，降低存储开销

#### （2）类图

![](./assets/image-20240430145130815.png =800x)

其中：
- Flyweight 描述一个接口，通过这个接口 Flyweight 可以接受并作用于外部状态。
- ConcreteFlyweight 实现 Flyweight 接口，并为内部状态（如果有）增加存储空间。
- ConcreteFlyweight 对象必须是可共享的。它所存储的状态必须是内部的，即它必须独立于 ConcreteFlyweight 对象的场景。
- 并非所有的 Flyweight 子类都需要被共享。Flyweight 接口使共享成为可能，但它并不强制共享。在 Flyweight 对象结构的某些层次，UnsharedConcreteFlyweight 对象通常将 ConcreteFlyweight 对象作为子结点。
- FlyweightFactory 创建并管理 Flyweight 对象；确保合理地共享 Flyweight，当用户请求一个 Flyweight 时，FlyweightFactory 对象提供一个已创建的实例或者在不存在时创建个实例。
- Client 维持一个对 Flyweight 的引用；计算或存储一个或多个 Flyweight 的外部状态。

#### （3）适用性

Flyweight 模式适用于：

- 一个应用程序使用了大量的对象。
- 完全由于使用大量的对象，造成很大的存储开销。
- 对象的大多数状态都可变为外部状态。
- 如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。
- 应用程序不依赖于对象标识。由于 Flyweight 对象可以被共享，所以对于概念上明显有别的对象，标识测试将返回真值。


##### 🍐 1 黑白棋

<details>
<summary><mark>查看代码</mark></summary>

```java {24,27-28}
public class FlyweightPattern {
    public static void main(String[] args) {
        PieceFactory factory = new PieceFactory();
 
        Piece whitePiece1 = factory.getPiece(0);
        whitePiece1.draw(66,87);
        System.out.println(whitePiece1);
 
        Piece blackPiece1 = factory.getPiece(1);
        blackPiece1.draw(20,11);
        System.out.println(blackPiece1);
 
        Piece whitePiece2 = factory.getPiece(0);
        whitePiece1.draw(26，54);
        System.out.println(whitePiece2);
 
        Piece blackPiece2 = factory.getPiece(1);
        blackPiece2.draw(12，34);
        System.out.println(blackPiece2);
    }
}
 
class PieceFactory{
    private Piece[] pieces = {new WhitePiece(),new BlackPiece()};
 
    public Piece getPiece(int key){
        if (key == 0) return pieces[0];
        else return pieces[1];
    }
}
 
abstract class Piece{
    protected String color;
 
    public abstract void draw(int x,int y);
}
 
class WhitePiece extends Piece{
    public WhitePiece(){
        this.color = "white";
    }
 
    @Override
    public void draw(int x，int y) {
        System.out.println("draw a color: " + color + " piece x: " + x + " y:　" + y);
    }
}
 
class BlackPiece extends Piece{
    public BlackPiece(){
        this.color = "black";
    }
 
    @Override
    public void draw(int x，int y) {
        System.out.println("draw a color: " + color + " piece x: " + x + " y:　" + y);
    }
}
```

运行 1

```text
draw a color: white piece x: 66 y:　87
com.lxzz.softdesign.WhitePiece@4c873330
draw a color: black piece x: 20 y:　11
com.lxzz.softdesign.BlackPiece@119d7047
draw a color: white piece x: 26 y:　54
com.lxzz.softdesign.WhitePiece@4c873330
draw a color: black piece x: 12 y:　34
com.lxzz.softdesign.BlackPiece@119d7047
```

</details>

##### 🍐 2 画圆

<details>
<summary><mark>查看代码</mark></summary>

```java {}
public class FlyweightPattern {
    public static void main(String[] args) {
        ShapeFactory factory = new ShapeFactory();
 
        Random random = new Random();
        String[] colors = {"red","blue","green","white","black"};
 
        for (int i = 1; i <= 10; i++) {
            int x = random.nextInt(colors.length);
            Shape shape = factory.getShape(colors[x]);
            System.out.print("第" + i + "个圆：");
            shape.draw(random.nextInt(100),random.nextInt(100));
        }
    }
}
 
class ShapeFactory{
    private Map<String,Shape> map = new HashMap<>();
 
    public Shape getShape(String key){
        if (!map.containsKey(key)) {
            map.put(key，new Circle(key));
            System.out.println("create color: " + key + " circle");
        }
        return map.get(key);
    }
}
 
abstract class Shape {
    protected String color;
 
    public abstract void draw(int x，int y);
}
 
class Circle extends Shape {
 
    public Circle(String color){
        this.color = color;
    }
 
    @Override
    public void draw(int x，int y) {
        System.out.println("draw a color: " + color + " circle x："+ x + " y：" + y);
    }
}
```


运行 2

```text
create color: white circle
第1个圆：draw a color: white circle x：98 y：99
create color: blue circle
第2个圆：draw a color: blue circle x：59 y：14
create color: red circle
第3个圆：draw a color: red circle x：21 y：31
create color: black circle
第4个圆：draw a color: black circle x：0 y：13
create color: green circle
第5个圆：draw a color: green circle x：41 y：66
第6个圆：draw a color: black circle x：54 y：11
第7个圆：draw a color: white circle x：99 y：68
第8个圆：draw a color: white circle x：18 y：52
第9个圆：draw a color: red circle x：28 y：60
第10个圆：draw a color: white circle x：83 y：66
```

</details>


@tab 7

### 7. Proxy (代理)

::: tip 代理控制
:::

#### （1）意图

为其他对象提供一种**代理**以**控制**对这个对象的**访问**。

#### （2）类图

![](./assets/image-20240430145205532.png =800x)

#### （3）适用性

Proxy 模式适用于在需要比较通用和复杂的对象指针代替简单的指针的时候，常见情况有：
- 远程代理 (Remote Proxy) 为一个对象在不同地址空间提供局部代表。
- 虚代理 (Virtual Proxy) 根据需要创建开销很大的对象。
- 保护代理 (Protection Proxy) 控制对原始对象的访问，用于对象应该有不同的访问权限的时候。
- 智能引用 (Smart Reference) 取代了简单的指针，它在访问对象时执行一些附加操作。

<details>
<summary><mark>查看代码</mark></summary>

```java {14,18-20,30}
public class ProxyPattern {
    public static void main(String[] args) {
        RealSubject realSubject = new RealSubject();
        Proxy proxy = new Proxy(realSubject);
 
        proxy.buy();
    }
}
 
interface Subject{
    void buy();
}
 
class Proxy implements Subject{
 
    protected RealSubject realSubject;
 
    public Proxy(RealSubject realSubject){
        this.realSubject = realSubject;
    }
 
    @Override
    public void buy() {
        System.out.println("办理购买前的手续~");
        realSubject.buy(); // 付钱
        System.out.println("办理购买后的手续~");
    }
}
 
class RealSubject implements Subject{
 
    @Override
    public void buy() {
        System.out.println("付钱~");
    }
}
```

</details>

::::


## 🍀 行为型设计模式（11 种）


:::: tabs

@tab 1

### 1. Chain of Responsibility（责任链）

::: tip 为某个请求创建一个对象链，每个对象依序检查此请求并对其进行处理或者将它传给链中的下一个对象
:::

#### （1）意图

*使多个对象都有机会处理请求*，从而避免请求的发送者和接收者之间的耦合关系。*将这些对象连成一条链*，并沿着这条链传递该请求，直到有一个对象处理它为止。

#### （2）类图

![](./assets/image-20230415171040969.png =800x)

其中：
- Handler 定义一个处理请求的接口；（可选）实现后继链。
- ConcreteHandler 处理它所负责的请求；可访问它的后继者（successor）；如果可处理该请求，就处理它，否则将该请求转发给后继者。
- Client 向链上的具体处理者 (ConcreteHandler) 对象提交请求。


#### （3）适用性

Chain of Responsibility 模式适用于以下条件：

- 有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。
- 想在不明确指定接收者的情况下向多个对象中的一个提交一个请求。
- 可处理一个请求的对象集合应被动态指定。


<details>
<summary><mark>查看代码</mark></summary>

```java
public class ChainOfResponsibilityPattern {
    public static void main(String[] args) {
        Handler counsellor = new Counsellor();
        Handler dean = new Dean();
        Handler headmaster= new Headmaster();
 
        counsellor.setNext(dean);
        dean.setNext(headmaster);
 
        counsellor.HandRequest(25);
    }
 
}
 
abstract class Handler{
    protected Handler next;
 
    public void setNext(Handler next){
        this.next = next;
    }
 
    public abstract void HandRequest(int request);
}
 
class Counsellor extends Handler{
 
    @Override
    public void HandRequest(int request) {
        if (request <= 7){
            System.out.println("辅导员审批通过~");
        }else {
            if (next != null){
                next.HandRequest(request);
            }else {
                System.out.println("无法审批");
            }
        }
    }
}
 
class Dean extends Handler{
 
    @Override
    public void HandRequest(int request) {
        if (request <= 15){
            System.out.println("院长审批通过~");
        }else {
            if (next != null){
                next.HandRequest(request);
            }else {
                System.out.println("无法审批");
            }
        }
    }
}
 
class Headmaster extends Handler{
 
    @Override
    public void HandRequest(int request) {
        if (request <= 30){
            System.out.println("校长审批通过~");
        }else {
            if (next != null){
                next.HandRequest(request);
            }else {
                System.out.println("无法审批");
            }
        }
    }
}
```

</details>


@tab 2

### 🌸 2. Command（命令）

::: tip 将请求封装为对象
:::


#### （1）意图

将一个请求封装为一个对象，从而使得可以用不同的请求对客户进行参数化；对**请求排队**或记录**请求日志**，以及支持可**撤销**的操作。


#### （2）类图

![](./assets/image-20230415173855870.png =800x)

其中：

- *Command* 声明执行操作的接口。
- *ConcreteCommand* 将一个接收者对象绑定于一个动作：调用接收者相应的操作，以实现 Execute。
- Client 创建一个具体命令对象并设定它的接收者。
- Invoker 要求该命令执行这个请求。
- Receiver 知道如何实施与执行一个请求相关的操作。*任何类都可能作为一个接收者*。


#### （3）适用性

Command 模式适用于：

- 抽象出待执行的动作以参数化某对象。
- 在不同的时刻指定、排列和执行请求。
- 支持取消操作。
- 支持修改日志。
- 用构建在原语操作上的高层操作构造一个系统。



<details>
<summary><mark>查看代码</mark></summary>

```java
public class CommandPattern {
    public static void main(String[] args) {
        Tv tv = new Tv(); // 接收者 对象 电视机
 
        Command onCommand = new OnCommand(tv); // 命令对象 开机命令
        Command offCommand = new OnCommand(tv); // 命令对象 关机命令
 
        Invoker invoker = new Invoker(); //请求者
        invoker.setCommand(onCommand); // 给请求者设置 开机 命令
        invoker.call(); // 请求者去请求命令
 
        System.out.println("==============分割线===============");
 
        invoker.setCommand(offCommand); // 给请求者设置 关机命令
        invoker.call(); // 请求者去请求命令
 
    }
}
 
class Invoker{ // 请求者
    private Command command; // 命令
 
    public void setCommand(Command command){ // 设置请求者的命令
        this.command = command;
    }
 
    public void call(){ // 调用
        command.Execute();
    }
}
 
interface Command{ // 命令接口
    void Execute(); // 执行命令
 
}
 
class OnCommand implements Command{// 开机命令
    private Tv tv;
 
    public OnCommand(Tv tv){
        this.tv = tv;
    }
 
    @Override
    public void Execute() {
        tv.OnAction();
    }
}
 
class OffCommand implements Command{ // 关机命令
    private Tv tv;
 
    public OffCommand(Tv tv){
        this.tv = tv;
    }
 
    @Override
    public void Execute() {
        tv.OffAction();
    }
}
 
class Tv{
    public void OnAction(){ // 开机行为
        System.out.println("电视机开机了...");
    }
 
    public void OffAction(){ // 关机行为
        System.out.println("电视机关机了...");
    }
}
```

</details>



@tab 3

### 3. Interpreter（解释器）

> 没考过

::: tip 为语言创建解释器，通常由语言的语法和语法分析来定义
:::

#### （1）意图

给定一个语言，*定义它的文法的一种表示*，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。


#### （2）类图

![](./assets/image-20240430145354943.png =800x)

- Context 上下文
- NonterminalExpression 非终结符表达式

#### （3）适用性

Interpreter 模式适用于当有一个语言需要解释执行，并且可将该语言中的句子表示为一个抽象语法树时，以下情况效果最好：

- 该文法简单。对于复杂的发文，文法的类层次变得庞大而无法管理。
- 效率不是一个关键问题。最高效的解释器通常不是通过直接解释语法分析树实现的，而是首先将它们转换成另一种形式。


<details>
<summary><mark>查看代码</mark></summary>

```java
public class InterpreterPattern {
 
    public static void main(String[] args) {
 
        Context context = new Context();
 
        context.check("A区的开发人员");
        context.check("B区的调试人员");
        context.check("C区的测试人员");
 
        System.out.println("========分割线=============");
 
        context.check("D区的程序员");
        context.check("D区的测试员");
        context.check("C区的程序员");
 
    }
}
 
class Context{
    private String[] regions = {"A区","B区","C区"};
    private String[] persions = {"开发人员","测试人员","调试人员"};
    private NonterminalExpression nonterminal;
 
    public Context(){
        TerminalExpression region = new TerminalExpression(regions);
        TerminalExpression person = new TerminalExpression(persions);
        nonterminal = new NonterminalExpression(region,person);
    }
 
    public void check(String info){
        boolean result = nonterminal.Interpret(info);
        if (result){
            System.out.println("识别成功~");
        }else {
            System.out.println("识别失败~");
        }
    }
 
}
 
interface Expression{
    boolean Interpret(String info);
}
 
class NonterminalExpression implements Expression{
 
    private TerminalExpression region;
    private TerminalExpression person;
 
    public NonterminalExpression(TerminalExpression region,TerminalExpression person){
        this.region =region;
        this.person = person;
    }
 
    @Override
    public boolean Interpret(String info) {
        String[] str = info.split("的");
        // B区的调试人员 --> str = {"B区","调试人员"};
        return region.Interpret(str[0]) && person.Interpret(str[1]);
    }
}
 
class TerminalExpression implements Expression{
 
    private Set<String> set = new HashSet<>();
 
    public TerminalExpression(String[] data){
        for (String str : data) {
            set.add(str);
        }
    }
 
    @Override
    public boolean Interpret(String info) {
        return set.contains(info);
    }
}
```

</details>




@tab 4

### 4. Iterator（迭代器）

::: tip 提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示
:::

#### （1）意图

提供一种方法*顺序访问*一个**聚合对象**中的各个元素，且*不需要暴露该对象的内部表示*。


#### （2）类图

![](./assets/image-20240430145419785.png =800x)

其中：

- Iterator (迭代器) *定义访问和遍历元素的接口*。
- ConcreteIterator（具体迭代器）*实现迭代器接口*；对该聚合遍历时跟踪当前位置。
- Aggregate (聚合) 定义创建相应迭代器对象的接口。
- ConcreteAggregate (具体聚合) 实现创建相应迭代器的接口，该操作返回 ConcreteIterator 的一个适当的实例。

#### （3）适用性

Iterator 模式适用于：

- 访问一个聚合对象的内容而无须暴露它的内部表示。
- 支持对聚合对象的多种遍历。
- 为遍历不同的聚合结构提供一个统一的接口。


<details>
<summary><mark>查看代码</mark></summary>

```java
public class IteratorPattern {
 
    public static void main(String[] args) {
        BookAggregate bookAggregate = new BookAggregate();
 
        String[] books = {"数据结构","操作系统","计算机网络","计算机组成原理"};
        double[] prices = {10.24,20.48,40.96,81.92};
 
        for (int i = 0; i < 4; i++) {
            bookAggregate.Add(new Book(books[i],prices[i]));
        }
 
        Iterator iterator = bookAggregate.CreateIterator();
        while (iterator.hasNext()) {
            Book book = (Book) iterator.next();
            System.out.println("书名：" + book.getName() + " 价格：" + book.getPrice());
        }
 
    }
 
}
 
interface Iterator{
    boolean hasNext();
    Object next();
}
 
class BookIterator implements Iterator{
    private int index;
    private BookAggregate bookAggregate;
 
    public BookIterator(BookAggregate bookAggregate){
        this.index = 0;
        this.bookAggregate = bookAggregate;
    }
 
    @Override
    public boolean hasNext() {
        if (index < bookAggregate.getSize()){
            return true;
        }
        return false;
    }
 
    @Override
    public Object next() {
        Object obj = bookAggregate.get(index);
        index ++ ;
        return obj;
    }
}
 
class BookAggregate implements Aggregate{
 
    private List<Book> list = new ArrayList<>();
 
    public void Add(Book book){
        list.add(book);
    }
 
    public Book get(int index){
        return list.get(index);
    }
 
    public int getSize(){
        return list.size();
    }
 
    @Override
    public Iterator CreateIterator() {
        return new BookIterator(this);
    }
}
 
interface Aggregate{
    Iterator CreateIterator();
}
 
class Book{
    private String name;
    private double price;
 
    public Book(String name,double price){
        this.name = name;
        this.price = price;
    }
 
    public String getName(){
        return name;
    }
 
    public double getPrice(){
        return price;
    }
}
```

</details>




@tab 5

### 5. Mediator（中介者）

::: tip 集中相关对象之间复杂的沟通和控制方式
:::

#### （1）意图

用一个**中介对象**来*封装一系列的对象交互*。中介者使各对象不需要显式的相互引用，从而使其*耦合松散*，而且可以独立地改变它们之间的交互。


#### （2）类图

![](./assets/image-20240430145449796.png =800x)


其中：

- Mediator (中介者) 定义一个接口用于各同事 (Colleague) 对象通信。
- ConcreteMediator (具体中介者) 通过协调各同事对象实现协作行为；了解并维护它的各个同事。
- Colleague class (同事类) 知道它的中介者对象；每一个同事类对象在需要与其他同事通信的时候与它的中介者通信。


#### （3）适用性

Mediator 模式适用于：

- 一组对象以*定义良好*但是~~复杂的方式进行通信~~，产生的~~相互依赖关系结构混乱且难以理解~~。
- 一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象。
- 想定制一个分布在多个类中的行为，而又不想生成太多的子类。


<details>
<summary><mark>查看代码</mark></summary>

```java
public class MediatorPattern {
    public static void main(String[] args) {
        ConcreteMediator mediator = new ConcreteMediator();

        Colleague1 colleague1 = new Colleague1(mediator);
        Colleague2 colleague2 = new Colleague2(mediator);

        mediator.setColleague1(colleague1);
        mediator.setColleague2(colleague2);

        colleague1.sendMessage("软考加油~");
        colleague2.sendMessage("祝你上岸~");
    }
}

abstract class Colleague {
    protected Mediator mediator;
}

class Colleague1 extends Colleague {
    public Colleague1(Mediator mediator) {
        this.mediator = mediator;
    }

    public void sendMessage(String message) {
        mediator.sendMessage(message，this);
    }

    public void Notify(String message) {
        System.out.println("同事1收到消息：" + message);
    }
}

class Colleague2 extends Colleague {
    public Colleague2(Mediator mediator) {
        this.mediator = mediator;
    }

    public void sendMessage(String message) {
        mediator.sendMessage(message，this);
    }

    public void Notify(String message) {
        System.out.println("同事2收到消息：" + message);
    }
}

abstract class Mediator {
    public abstract void sendMessage(String message，Colleague colleague);
}

class ConcreteMediator extends Mediator {
    private Colleague1 colleague1;
    private Colleague2 colleague2;

    public void setColleague1(Colleague1 colleague1) {
        this.colleague1 = colleague1;
    }

    public void setColleague2(Colleague2 colleague2) {
        this.colleague2 = colleague2;
    }

    @Override
    public void sendMessage(String message，Colleague colleague) {
        if (colleague == colleague1) {
            // 让同事2收到消息
            colleague2.Notify(message);
        } else {
            // 让同事1收到消息
            colleague1.Notify(message);
        }
    }
}
```

</details>




@tab 6

### 6. Memento（备忘录）

::: tip 当你需要让对象返回之前的状态时(例如，你的用户请求"撤销")，你使用备忘录模式
:::

#### （1）意图

在不破坏封装性的前提下*捕获一个对象的内部状态*，并在对象之外*保存*这个状态。这样以后就可以将对象*恢复*到原先保存的状态。


#### （2）类图


![](./assets/image-20240430145510432.png =800x)

- Memento（备忘录）：存储原发器对象的内部状态；防止原发器以外的对象访问备忘录；
- Originator（原发器）：创建一个备忘录，用于记录当前时刻它的内部状态；使用备忘录恢复内部状态
- Caretaker（管理者）

#### （3）适用性

Memento 模式适用于：

- *必须保存一个对象在某一个时刻的（部分）状态*，这样以后需要时它才能恢复到先前的状态。
- 如果一个用接口来让其他对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。


<details>
<summary><mark>查看代码</mark></summary>

```java
public class MementoPattern {
    public static void main(String[] args) {
        Caretaker caretaker = new Caretaker();
        Originator originator = new Originator();
 
        originator.setState("1024");
        Memento backup1 = originator.createMemento();
        caretaker.addMemento(backup1);
 
        originator.setState("2048");
        Memento backup2 = originator.createMemento();
        caretaker.addMemento(backup2);
 
        originator.setState("4096");
        Memento backup3 = originator.createMemento();
        caretaker.addMemento(backup3);
 
        System.out.println(originator.getState());
        caretaker.showMemento();
 
        Memento memento1 = caretaker.getMemento(2);
        originator.setState(memento1.getState());
 
        System.out.println("根据第2次备份还原之后的状态为：" + originator.getState());
    }
}
 
class Originator{ // 原发器
    private String state;
 
    public void setState(String state){
        this.state = state;
    }
 
    public String getState(){
        return state;
    }
 
    public Memento createMemento(){
        return new Memento(state);
    }
 
    public void setMemento(Memento memento){
        state = memento.getState();
    }
}
 
class Memento{ // 备忘录
    private String state;
 
    public String getState(){
        return state;
    }
 
    public Memento(String state){
        this.state = state;
    }
}
 
class Caretaker{ // 管理者
    private List<Memento> mementoList = new ArrayList<>();
 
    public void addMemento(Memento memento){
        mementoList.add(memento);
    }
 
    public Memento getMemento(int index){
        // 判断参数是否合法
        if (index >=1 && index <= mementoList.size()) {
            return mementoList.get(index - 1);
        }
        return null;
    }
 
    public void showMemento(){
        int cnt = 1;
        for (Memento memento : mementoList) {
            System.out.println("第" + cnt + "次备份，状态为：" + memento.getState());
            cnt ++;
        }
    }
}
```

</details>




@tab 7


### 🌸 7. Observer（观察者）

::: tip 对象间定义一对多的依赖，一个对象改变状态，依赖它的对象都会收到通知
:::

#### （1）意图

定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

#### （2）类图

![](./assets/image-20240430145530766.png =800x)


其中：

- *Subject (目标) 知道它的观察者，可以有任意多个观察者观察同一个目标*；提供注册和删除观察者对象的接口。
- Observer (观察者) 为那些在目标发生改变时需获得通知的对象定义一个更新接口。
- ConcreteSubject (具体目标) 将有关状态存入各 ConcreteObserver 对象；当它的状态发生改变时，向它的各个观察者发出通知。
- ConcreteObserver (具体观察者) 维护一个指向 ConcreteSubject 对象的引用；存储有关状态，这些状态应与目标的状态保持一致。
- 实现 Observer 的更新接口，以使自身状态与目标的状态保持一致。

#### （3）适用性

Observer 模式适用于：

- 当一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两者封装在独立的对象中以使它们可以各自独立地改变和复用。
- *当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变时*。
- 当一个对象必须通知其他对象，而它又不能假定其他对象是谁，即*不希望这些对象是 **紧耦合** 的*。

<details>
<summary><mark>查看代码</mark></summary>

```java
public class ObserverPattern {
    public static void main(String[] args) {
        Subject subjectA = new ConcreteSubject("目标A");

        Observer observerB = new ConcreteObserver("张三"，subjectA);
        Observer observerC = new ConcreteObserver("李四"，subjectA);
        Observer observerD = new ConcreteObserver("王五"，subjectA);

        subjectA.setState("更新了");
    }
}


interface Subject { // 目标接口
    void Attach(Observer observer); // 添加观察者

    void Detach(Observer observer); // 删除观察者

    void Notify(); // 状态改变后，通知所有观察者

    void setState(String state); // 设置状态（改变状态）

    String getState(); // 获取状态


}

class ConcreteSubject implements Subject {
    private String name;
    private String state;


    private List<Observer> observerList;

    public ConcreteSubject(String name) {
        state = "未更新";
        this.name = name;
        observerList = new ArrayList<>();
    }

    @Override
    public void Attach(Observer observer) {
        observerList.add(observer);
    }

    @Override
    public void Detach(Observer observer) {
        observerList.remove(observer);
    }

    @Override
    public void Notify() {
        for (Observer observer : observerList) {
            observer.update();
        }
    }

    @Override
    public void setState(String state) {
        this.state = state;

        System.out.println(name + "的状态发生变化，变化后的状态为：" + state);
        Notify();
    }

    @Override
    public String getState() {
        return state;
    }


}

interface Observer { // 观察者接口
    void update(); // 收到通知，更新观察者的状态
}

class ConcreteObserver implements Observer {


    private String name;
    private String state;

    private Subject subject;

    public ConcreteObserver(String name，Subject subject) {
        this.name = name;
        this.subject = subject;
        subject.Attach(this);
        state = subject.getState();
    }

    @Override
    public void update() {
        System.out.println(name + " 收到通知");
        state = subject.getState(); //  让当前观察者的状态 和 目标改变后的状态保持一致
        System.out.println(name + " 改变后的状态为：" + state);
    }
}
```

</details>


@tab 8


### 🌸 8. State（状态）

::: tip 允许对象在内部状态改变时改变它的行为
:::

#### （1）意图

允许一个对象在其*内部状态改变*时改变它的行为。对象看起来似乎修改了它的类。


#### （2）类图

![](./assets/image-20240430145747952.png =800x)

#### （3）适用性

State 模式适用于：

- 一个对象的*行为决定于它的状态*，并且它*必须在运行时刻根据状态改变它的行为*。
- 一个操作中*含有庞大的多分支的条件语句*，且这些*分支依赖于该对象的状态*。这个状态常用一个或多个枚举常量表示。


<details>
<summary><mark>查看代码</mark></summary>

```java
public class StatePattern {
    public static void main(String[] args) {
        Context context = new Context(); // count = 3
 
        System.out.println("状态：" + context.getState() + " 数量：" + context.getCount());
 
        context.Request(); // 购买一个饮料 count = 2
        context.Request(); // 购买一个饮料 count = 1
        context.Request(); // 购买一个饮料 count = 0
 
        System.out.println("状态：" + context.getState() + " 数量：" + context.getCount());
 
        context.Request(); // 无货，等待补货
 
        System.out.println("状态：" + context.getState() + " 数量：" + context.getCount());
 
        context.Request(); // 购买一个饮料 count = 4
        System.out.println("状态：" + context.getState() + " 数量：" + context.getCount());
 
    }
}
 
class Context{ // 贩卖机
    private int count;
 
    private State state;
 
    public Context(){
        count = 3;
        state = new StateA();
    }
 
    public int getCount() {
        return count;
    }
 
    public void setCount(int count) {
        this.count = count;
    }
 
    public State getState() {
        return state;
    }
 
    public void setState(State state) {
        this.state = state;
    }
 
    public void Request(){  // 购买饮料
        state.Handle(this);
    }
}
 
interface State{
    void Handle(Context context);
}
 
class StateA implements State{
 
    @Override
    public void Handle(Context context) {
        int count = context.getCount();
 
        if (count >= 1){
            System.out.println("购买成功~");
            context.setCount(count - 1);
 
            if (context.getCount() == 0){
                context.setState(new StateB()); // 设置为无货状态
            }
        }else {
            System.out.println("购买失败~");
        }
    }
}
 
class StateB implements State{
 
    @Override
    public void Handle(Context context) {
        int count = context.getCount();
 
        if (count == 0){
            System.out.println("购买失败！等待补货~");
 
            context.setCount(5);
            System.out.println("补货成功，请重新购买~");
 
            context.setState(new StateA());
        }
    }
}
```

</details>



@tab 9


### 🌸 9. Strategy（策略）

::: tip 定义了算法族，分别封闭起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户
:::

#### （1）意图


定义一系列的**算法**，把它们一个个**封装**起来，并且使它们可以相互替换。此模式使得算法可以独立于使用它们的客户而变化。


#### （2）类图

![](./assets/image-20240430145813957.png =800x)


#### （3）适用性

Strategy 模式适用于：

- 许多相关的类仅仅是*行为有异*。
- *需要使用一个算法的不同变体*。
- 算法使用客户不应该知道的数据。可使用策略模式以*避免暴露复杂的、与算法相关的数据结构*。
- 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现（超市打折，普通/高级会员价），将相关的条件分支移入它们各自的 Strategy 类中，以代替这些条件语句。


<details>
<summary><mark>查看代码</mark></summary>

```java
public class StrategyPattern {
    public static void main(String[] args) {
 
        OperationContext context = new OperationContext(new Addstrategy());
        context.Operation(20,17);
 
        context = new OperationContext(new Substrategy());
        context.Operation(20,17);
 
        context = new OperationContext(new Multstrategy());
        context.Operation(20,17);
    }
}
 
class OperationContext{
    private Strategy strategy;
 
    public OperationContext(Strategy strategy){
        this.strategy = strategy;
    }
 
    public void Operation(int a，int b){
        strategy.TwoNumberOperation(a,b);
    }
}
 
interface Strategy{
    void TwoNumberOperation(int a,int b);
}
 
class Addstrategy implements Strategy{
    @Override
    public void TwoNumberOperation(int a，int b) {
        System.out.println(a + b);
    }
}
 
class Substrategy implements Strategy{
    @Override
    public void TwoNumberOperation(int a，int b) {
        System.out.println(a - b);
    }
}
 
class Multstrategy implements Strategy{
    @Override
    public void TwoNumberOperation(int a，int b) {
        System.out.println(a * b);
    }
}
```

</details>




@tab 10

### 10. Template Method（模板方法）

::: tip 在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中
:::

#### （1）意图

定义一个操作中的**算法骨架**，而将一些步骤延迟到子类中。Template Method 使得子类可以不改变一个算法的结构即*可重定义该算法的某些特定步骤*。


#### （2）类图

![](./assets/image-20240430145831835.png =800x)

其中：

- AbstractClass（抽象类）定义抽象的*原语操作*，具体的子类将重定义它们以实现一个算法的各步骤；实现模板方法，定一个算法的骨架，该模板方法不仅调用原语操作，也调用定义在 AbstractClass 或其他对象中的操作。
- ConcreteClass（具体类）实现原语操作以完成算法中与特定子类相关的步骤。

> 抽象类控制步骤，各子类继承父类具体实现操作步骤

#### （3）适用性

Template Method 模式适用于：

- 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。
- 各子类中公共的行为应被提取出来并集中到一个公共父类中，以避免代码重复。
- 控制子类扩展：模板方法在特定点调用 “hook” 操作 (默认行为，子类可以在必要时进行重定义扩展)，这就只允许在这些点进行扩展。

<details>
<summary><mark>查看代码</mark></summary>

```java
public class TemplateMethodPattern {
    public static void main(String[] args) {
        // 父类名 对象名 = new 子类名();
 
        Person student = new Student();
        Person teacher = new Teacher();
 
        student.TemplateMethod();
 
        System.out.println("=========分割线=============");
 
        teacher.TemplateMethod();
    }
}
 
abstract class Person{
    public void TemplateMethod(){
        System.out.println("上课 去教室");
        PrimitiveOperation1();
        System.out.println("下课 离开教室");
        PrimitiveOperation2();
    }
 
    public abstract void PrimitiveOperation1(); // 原语操作 1：上课过程 学生 听课... 老师 讲课
    public abstract void PrimitiveOperation2(); // 原语操作 2：作业  学生 写作业 提交作业... 老师批改作业 打分数
}
 
class Student extends Person{
 
    @Override
    public void PrimitiveOperation1() {
        System.out.println("学生：听课 学习 做笔记 提出问题");
    }
 
    @Override
    public void PrimitiveOperation2() {
        System.out.println("学生：写作业 提交作业");
    }
}
 
class Teacher extends Person{
 
    @Override
    public void PrimitiveOperation1() {
        System.out.println("老师：上课 讲课 解答问题 布置作业");
    }
 
    @Override
    public void PrimitiveOperation2() {
        System.out.println("老师：批改作业 打分数");
    }
}
```

</details>



@tab 11

### 🌸 11. Visitor（访问者）

::: tip 当你想要为一个对象的组合增加新的能力，且封装并不重要时，就使用访问者模式
:::

#### （1）意图

*表示一个作用于某**对象结构**中的各元素的操作*。它允许在不改变各元素的类的前提下定义作用于这些元素的新操作。


#### （2）类图

![](./assets/image-20240430145858087.png =800x)

其中：

- Visitor (访问者) 为该对象结构中 ConcreteElement 的每一个类声明一个 Visit 操作。该操作的名字和特征标识了发送 Vist 请求给该访问者的那个类，这使得访问者可以确定正被访问元素的具体的类。这样访问者就可以通过该元素的特定接口直接访问它。
- ConcreteVisitor (具体访问者) 实现每个有 Visitor 声明的操作，每个操作实现本算法的一部分，而该算法片段乃是对应于结构中对象的类。Concrete Visitor 为该算法提供了上下文并存储它的局部状态。这一状态常常在遍历该结构的过程中累积结果。
- Element (元素) 定义以一个访问者为参数的 Accept 操作。
- ConcreteElement (具体元素) 实现以一个访问者为参数的 Accept 操作。
- ObjectStructure (对象结构) 能枚举它的元素；可以提供一个高层的接口以允许该访问者访问它的元素；可以是一个组合或者一个集合，如一个列表或一个无序集合。


#### （3）适用性

Visitor 模式适用于：

- 一个对象结构包含很多类对象，它们有不同的接口，而用户想对这些对象实施一些依赖于其具体类的操作。
- 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而又想要避免这些操作 “污染” 这些对象的类。
- 定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。


<details>
<summary><mark>查看代码</mark></summary>

```java
public class VisitorPattern {
    public static void main(String[] args) {
        PersonStructure structure = new PersonStructure();
 
        Visitor1 visitor1 = new Visitor1();
        System.out.println("访问者1的访问记录：");
        structure.Accept(visitor1);
        System.out.println("学生年龄的总和：" + visitor1.getStudentAgeSum() +" 老师年龄的总和：" + visitor1.getTeacherAgeSum());
 
        System.out.println("=========分割线==============");
 
        Visitor2 visitor2 = new Visitor2();
        System.out.println("访问者2的访问记录：");
        structure.Accept(visitor2);
        System.out.println("学生的最高成绩：" + visitor2.getMaxScore() + " 老师的最高工龄：" + visitor2.getMaxWorkYear());
 
    }
}
 
interface Visitor{
    void VistStudent(Student student); // 访问
    void vistTeacher(Teacher teacher); // 访问老师
}
 
class Visitor1 implements Visitor{ // 访问者1 分别统计学生和老师的年龄总和
    private int studentAgeSum = 0;
    private int teacherAgeSum = 0;
 
    public int getStudentAgeSum() {
        return studentAgeSum;
    }
 
    public int getTeacherAgeSum() {
        return teacherAgeSum;
    }
 
    @Override
    public void VistStudent(Student student) {
        System.out.println("访问者1访问学生：" + student.getName() + " 年龄：" + student.getAge());
        studentAgeSum += student.getAge();
    }
 
    @Override
    public void vistTeacher(Teacher teacher) {
        System.out.println("访问者1访问老师：" + teacher.getName() + " 年龄：" + teacher.getAge());
        teacherAgeSum += teacher.getAge();
    }
}
 
class Visitor2 implements Visitor{ // 访问者2 分别求出 学生的最高成绩 以及 老师的最高工龄
    private int maxScore = -1;
    private int maxWorkYear = -1;
 
    public int getMaxScore() {
        return maxScore;
    }
 
    public int getMaxWorkYear() {
        return maxWorkYear;
    }
 
    @Override
    public void VistStudent(Student student) {
        System.out.println("访问者2访问学生：" + student.getName() + " 成绩：" + student.getScore());
        maxScore = Math.max(maxScore,student.getScore());
    }
 
    @Override
    public void vistTeacher(Teacher teacher) {
        System.out.println("访问者2访问老师：" + teacher.getName() + " 工龄：" + teacher.getWorkYear());
        maxWorkYear = Math.max(maxWorkYear,teacher.getWorkYear());
    }
}
 
class PersonStructure{
    private List<Person> personList = new ArrayList<>();
 
    public PersonStructure(){
        personList.add(new Student("张三",20,70));
        personList.add(new Student("李四",21,80));
        personList.add(new Student("王五",22,90));
 
        personList.add(new Teacher("李老师",26,3));
        personList.add(new Teacher("陈老师",27,4));
        personList.add(new Teacher("刘老师",28,5));
    }
 
    public void Accept(Visitor visitor){
        for (Person person : personList) {
            person.Accept(visitor);
        }
    }
}
 
abstract class Person{
    private String name;
    private int age;
 
    public Person(String  name,int age){
        this.name = name;
        this.age = age;
    }
 
    public String getName(){
        return name;
    }
 
    public int getAge() {
        return age;
    }
 
    public abstract void Accept(Visitor visitor);
}
 
class Student extends Person{
 
    private int score;
    public Student(String name,int age,int score){
        super(name,age);
        this.score = score;
    }
 
    public int getScore(){
        return score;
    }
 
    @Override
    public void Accept(Visitor visitor) {
        visitor.VistStudent(this);
    }
}
 
class Teacher extends Person{
    private int workYear;
    public Teacher(String name,int age,int workYear){
        super(name,age);
        this.workYear = workYear;
    }
 
    public int getWorkYear(){
        return workYear;
    }
 
    @Override
    public void Accept(Visitor visitor) {
        visitor.vistTeacher(this);
    }
}
```

</details>



