---
title: è¯•é¢˜å›› ã‰‘ âœ…
sidebarDepth: 1
category: è½¯è€ƒç¬”è®°
tag: è½¯è€ƒ
---

::: details ç›®å½•
[[toc]]
:::


## ğŸ€ å›æº¯æ³• - N çš‡åé—®é¢˜

1. æŒ‰è¡Œæ¥æ‘†æ”¾çš‡å
2. åˆ¤æ–­åŒä¸€åˆ—
    $$Q_i = Q_j$$
3. åˆ¤æ–­åŒä¸€æ¡æ–œçº¿ï¼š
    $$| i - j| = | Q_i - Q_j |$$

::: code-tabs

@tab 2015ä¸Š

```c {10,22,27,39,44}
#include <stdio.h>
#include <math.h>
#define N 10

/* åˆ¤æ–­ç¬¬kä¸ªçš‡åç›®å‰æ”¾ç½®ä½ç½®æ˜¯å¦ä¸å‰é¢çš„çš‡åå†²çª */
int isplace(int pos[], int k) {
    int i;
    for(i = 1; i < k; i ++ )
        // if ((1) || fabs(i - k) == fabs(pos[i] - pos[k]))
        if ( pos[i] == pos[k] || fabs(i - k) == fabs(pos[i] - pos[k]))
            return 0;
    return 1;
}

int main() {
    int i, j, count = 1;
    int pos[N + 1];
    // åˆå§‹åŒ–ä½ç½®
    for (i = 1; i <= N; i ++ )
        pos[i] = 0;
    // (2);
    j = 1;
    while (j >= 1) {
        pos[j] = pos[j] + 1;
        /* å°è¯•æ‘†æ”¾ç¬¬ j ä¸ªçš‡å */
        // while (pos[j] <= N && (3)) {
        while (pos[j] <= N && !isplace(pos,j)) {    
            pos[j] = pos[j] + 1;
        }
        /* å¾—åˆ°ä¸€ä¸ªæ‘†æ”¾æ–¹æ¡ˆ */
        if (pos[j] <= N && j == N) {
            printf("æ–¹æ¡ˆ%dï¼š", count ++ );
            for (i = 1; i <= N; i ++ )
                printf("%d", pos[i]);
            printf("\n");
        }
        /* è€ƒè™‘ä¸‹ä¸€ä¸ªçš‡å */
        // if (pos[j] <= N && (4)) {
        if (pos[j] <= N && j < N) {
            j = j + 1;
        } else { // è¿”å›è€ƒè™‘ä¸Šä¸€ä¸ªçš‡å
            pos[j] = 0;
            // (5);
            j--;
        }
    }
    return 1;
}
```

@tab 2019ä¸Š

```c {21,26,34,39}
#include <math.h>
#include <stdio.h>

#define n 4

int queen[n + 1];

void Show() { /* è¾“å‡ºæ‰€æœ‰çš‡åæ‘†æ”¾æ–¹æ¡ˆ */
    int i;
    printf("(");
    for (i = 1; i <= n; i++) {
        printf(" %d", queen[i]);
    }
    printf(")\n");
}

int Place(int j) { /* æ£€æŸ¥å½“å‰åˆ—èƒ½å¦æ”¾ç½®çš‡åï¼Œä¸èƒ½æ”¾è¿”å›0ï¼Œèƒ½æ”¾è¿”å›1 */
    int i;
    for (i = 1; i < j; i++) { /*æ£€æŸ¥ä¸å·²æ‘†æ”¾çš„çš‡åæ˜¯å¦åœ¨åŒä¸€åˆ—æˆ–è€…åŒä¸€æ–œçº¿ä¸Š*/
        // if ((1) || abs(queen[i] - queen[j]) == (j - i)) {
        if (queen[i] == queen[j] || abs(queen[i] - queen[j]) == (j - i)) {
            return 0;
        }
    }
    // return (2);
    return 1;
}

void Nqueen(int j) {
    int i;
    for (i = 1; i <= n; i++) {
        queen[j] = i;
        // if ((3)) {
        if (Place(i)) {
            if (j == n) { /* å¦‚æœæ‰€æœ‰çš‡åéƒ½æ‘†æ”¾å¥½ï¼Œåˆ™è¾“å‡ºå½“å‰æ‘†æ”¾æ–¹æ¡ˆ */
                Show();
            } else { /* å¦åˆ™ç»§ç»­æ‘†æ”¾ä¸‹ä¸€ä¸ªçš‡å */
                // (4);
                Nqueen(j++);
            }
        }
    }
}

int main() {
    Nqueen(1);

    return 0;
}
```

:::



## ğŸ€ åˆ†æ²»æ³•


åˆ†ææ—¶é—´å¤æ‚åº¦æ—¶ï¼Œåˆ—å‡ºå…¶**é€’å½’å¼**ä¸º $T(n) = 2T(n/2) + n$ã€‚**æ—¶é—´**å¤æ‚åº¦ä¸º $O(nlogn)$ï¼Œ**ç©ºé—´**å¤æ‚åº¦ä¸º $O(n)$

::: code-tabs

@tab å½’å¹¶æ’åº


```c {38-40}
#include <stdio.h>
#include <sched.h>
#include <climits>

void Merge(int A[], int p, int q, int r) {
    int i, j, k;

    int L[50], R[50];
    int n1 = q - p + 1, n2 = r - q;
    for (i = 0; i < n1; i ++ ) {
        L[i] = A[p + i];
    }

    for (j = 0; j < n2; j ++ ) {
        R[j] = A[q + j + 1];
    }

    L[n1] = INT_MAX;
    R[n2] = INT_MAX;

    i = 0;
    j = 0;
    for (k = p; k < r + 1; k ++ ) {
        if (L[i] < R[j]) {
            A[k] = L[i];
            i ++ ;
        } else {
            A[k] = R[j];
            j ++ ;
        }
    }
}

void MergeSort(int A[], int p, int r) {
    int q;
    if (p < r) {
        q = (p + r) / 2;
        MergeSort(A, p, q);
        MergeSort(A, q + 1, r);
        Merge(A, p, q, r);
    }
}

int main() {
    int A[] = {4, 1, 3, 6, 8, 5, 2, 9};
    MergeSort(A, 0, 7);

    int i;
    for (i = 0; i < 8; i ++ ) {
        printf("%d ", A[i]);
    }

    return 0;
}
```

@tab 2014ä¸Š

```c {30,33,45,49}
#include <stdio.h>
#include <stdlib.h>

#define MAX 65536

void merge(int arr[], int p, int q, int r) {
    int *left, *right;
    int n1, n2, i, j, k;
    n1 = q - p + 1;
    n2 = r - q;
    if ((left = (int *) malloc((n1 + 1) * sizeof(int))) == NULL) {
        perror("malloc error");
        exit(1);
    }
    if ((right = (int *) malloc((n2 + 1) * sizeof(int))) == NULL) {
        perror("malloc error");
        exit(1);
    }
    for (i = 0; i < n1; i++) {
        left[i] = arr[p + i];
    }
    left[i] = MAX;
    for (i = 0; i < n2; i++) {
        right[i] = arr[q + i + 1];
    }
    right[i] = MAX;
    i = 0;
    j = 0;
    // for (k = p; (1); k++) {
    for (k = p; k < r+1; k++) {
        if (left[i] > right[j]) {
            // (2);
            arr[k] = right[j];
            j++;
        } else {
            arr[k] = left[i];
            i++;
        }
    }
}

void mergeSort(int arr[], int begin, int end) {
    int mid;
    // if ((3)) {
    if (begin < end) {
        mid = (begin + end) / 2;
        mergeSort(arr, begin, mid);
        // (4);
        mergeSort(arr, mid+1, end);
        merge(arr, begin, mid, end);
    }
}
```

@tab 2017ä¸Š

```c {14,21,39}
// å‡å¸é—®é¢˜
#include <stdio.h>

int getCounterfeitCoin(int coins[], int first, int last) {
    int firstSum = 0, lastSum = 0;
    int i;
    if (first == last - 1) { /* åªå‰©ä¸¤æšç¡¬å¸ */
        if (coins[first] < coins[last])
            return first;
        return last;
    }
    if ((last - first + 1) % 2 == 0) { /* å¶æ•°æšç¡¬å¸ */
        // for (i = first; (1); i++) {
        for (i = first; i < first + (last - first) / 2 + 1; i++) {
            firstSum += coins[i];
        }
        for (i = first + (last - first) / 2 + 1; i < last + 1; i++) {
            lastSum += coins[i];
        }
        // if ((2)) {
        if (firstSum > lastSum) {
            return getCounterfeitCoin(coins, first, first + (last - first) / 2);
        } else {
            return getCounterfeitCoin(coins, first + (last - first) / 2 + 1, last);
        }
    } else { /*å¥‡æ•°æšç¡¬å¸*/
        for (i = first; i < first + (last - first) / 2; i++) {
            firstSum += coins[i];
        }
        for (i = first + (last - first) / 2 + 1; i < last + 1; i++) {
            lastSum += coins[i];
        }
        if (firstSum < lastSum) {
            return getCounterfeitCoin(coins, first, first + (last - first) / 2 - 1);
        } else if (firstSum > lastSum) {
            return getCounterfeitCoin(coins, first + (last - first) / 2 + 1, last);
        } else {
            // return (3);
            return coins[first + (last - first) / 2];
        }
    }
}
```


@tab 2020ä¸‹

```c {13,16,22,27}
// å¸Œå°”æ’åº
#include <stdio.h>
#include <cstdlib>

void shellsort(int data[], int n) {
    int *delta, k, i, t, dk, j;
    k = n;
    delta = (int *) malloc(sizeof(int) * (n / 2)); // ç”³è¯·å†…å­˜ç©ºé—´
    i = 0;
    // æ„é€ æ­¥é•¿æ•°ç»„
    do {
        // (1);
        k = k / 2;
        delta[i++] = k;
    // } while ((2));
    } while (k > 1);

    i = 0;
    while ((dk = delta[i]) > 0) {
        for (k = delta[i]; k < n; ++k)
            // if ((3)) {
            if (data[k-dk] > data[k]) {
                t = data[k];
                for (j = k - dk; j >= 0 && t < data[j]; j -= dk)
                    data[j + dk] = data[j];
                // (4);
                data[j + dk] = t; // å†™ data[k-dk] = t æœ‰é—®é¢˜
            }
        ++i;
    }
}
```

:::


## ğŸ€ åŠ¨æ€è§„åˆ’


0-1 èƒŒåŒ…é—®é¢˜æ—¶é—´/ç©ºé—´å¤æ‚åº¦ï¼š O(NW)ã€‚è‡ªé¡¶å‘ä¸‹ã€‚

::: code-tabs

@tab 0-1èƒŒåŒ…é—®é¢˜

```c {17-19,21-24,31-36}
#include <stdio.h>

#define N 4 // ç‰©å“æ•°é‡
#define W 5 // èƒŒåŒ…å®¹é‡

int max(int a, int b) {
    return a > b ? a : b;
}

int main() {
    int v[] = {0, 2, 4, 5, 6}; // ç‰©å“ä»·å€¼æ•°ç»„
    int w[] = {0, 1, 2, 3, 4}; // ç‰©å“é‡é‡æ•°ç»„

    int f[N + 1][W + 1] = {}; // å­é—®é¢˜è§£æ•°ç»„

    int i, j;
    for (i = 1; i <= N; i ++ ) {
        for (j = 1; j <= W; j ++ ) {
            f[i][j] = f[i - 1][j]; // é»˜è®¤ä¸é€‰ç¬¬ i ä¸ªç‰©å“

            if (j >= w[i]) { // é€‰ç¬¬ i ä¸ªç‰©å“çš„å‰ææ¡ä»¶
                // ç­‰äº ä¸é€‰ç¬¬ i ä¸ªç‰©å“ å’Œ é€‰ç¬¬ i ä¸ªç‰©å“ ä¸¤è€…çš„è¾ƒå¤§å€¼
                f[i][j] = max(f[i][j], f[i - 1][j - w[i]] + v[i]);
            }

            // ä¸Šæ–¹æ˜¯å†™æ³• 1
            /* ============================================================ */
            // ä¸‹æ–¹æ˜¯å†™æ³• 2 

            /*
            if (j >= w[i]) { // é€‰ç¬¬ i ä¸ªç‰©å“çš„å‰ææ¡ä»¶
                // ç­‰äº ä¸é€‰ç¬¬ i ä¸ªç‰©å“ å’Œ é€‰ç¬¬ i ä¸ªç‰©å“ ä¸¤è€…çš„è¾ƒå¤§å€¼
                f[i][j] = max(f[i - 1][j], f[i - 1][j - w[i]] + v[i]);
            } else { // ä¸é€‰ç¬¬ i ä¸ªç‰©å“
                f[i][j] = f[i - 1][j]; // ç­‰äº ä»å‰ i - 1 ä¸ªç‰©å“ä¸­é€‰ï¼ŒèƒŒåŒ…å®¹é‡ä¸º j æ—¶çš„æœ€å¤§ä»·å€¼
            }
            */
        }
    }

    printf("%d\n", f[N][W]);

    for (i = 0; i <= N; i ++ ) {
        for (j = 0; j <= W; j ++ ) {
            printf("%d ", f[i][j]);
        }
        printf("\n");
    }

    return 0;
}
```

@tab 2019ä¸‹


```c {26,33,35,38}
#include <stdio.h>
#include <math.h>

#define N 6
#define maxT 1000

int c[N][maxT] = {0};

int Calculate_Max_Value(int v[N], int w[N], int i, int j);

int Memoized_Knapsack(int v[N], int w[N], int T) {
    int i;
    int j;
    for (i = 0; i < N; i++) {
        for (j = 0; j <= T; j++) {
            c[i][j] = -1;
        }
    }
    return Calculate_Max_Value(v, w, N - 1, T);
}

int Calculate_Max_Value(int v[N], int w[N], int i, int j) {
    int temp = 0;
    if (c[i][j] != -1) { // c[i][j] = -1 è¡¨ç¤ºè¿˜æœªæ±‚è§£
        // return (1);
        return c[i][j];
    }
    if (i == 0 || j == 0) {
        c[i][j] = 0;
    } else {
        c[i][j] = Calculate_Max_Value(v, w, i - 1, j); // ä¸é€‰ç¬¬ i ä¸ªç‰©å“
        // if ((2)) {
        if (j >= w[i] ) {
            // temp = (3);
            temp = Calculate_Max_Value(v, w, i-1, j-w[i]) + v[i];
            if (c[i][j] < temp) {
                // (4);
                c[i][j] = temp;
            }
        }
    }
    return c[i][j];
}
```


@tab 2021ä¸‹

```c
#include <stdio.h>

#define N 100

char A[N] = "CTGA";
char B[N] = "ACGCTA";
int d[N][N];

int min(int a, int b) {
    return a < b ? a : b;
}

int editdistance(char *str1, int len1, char *str2, int len2) {
    int i, j;
    int diff;
    int temp;

    for (i = 0; i <= len1; i++) {
        d[i][0] = i;
    }

    for (j = 0; j <= len2; j++) {
        // (1);
        d[0][j] = j;
    }

    for (i = 1; i <= len1; i++) {
        for (j = 1; j <= len2; j++) {
            // if ((2)) {
            if (str1[i-1] == str2[j-1]) {
                d[i][j] = d[i - 1][j - 1];
            } else {
                temp = min(d[i - 1][j] + 1, d[i][j - 1] + 1);
                // d[i][j] = min(temp, (3));
                d[i][j] = min(temp, d[i - 1][j - 1] + 1);
            }
        }
    }

    // return (4);
    return d[len1][len2];
}
```

:::


