---
title: 负数的二进制表示方法
sidebarDepth: 1
category: 基础知识
tag: 基础
---

::: details 目录
[[toc]]
:::


## 🍀 一、表示法

### 1、正数 5 的表示法

假设有一个 int 类型的数，值为 5，那么，我们知道它在计算机中表示为：
`00000000 00000000 00000000 00000101`
5 转换成二制是 101，不过 int 类型的数占用 4 字节（32 位），所以前面填了一堆 0。


### 2、负数 -5 的表示法

现在想知道，-5 在计算机中如何表示？在计算机中，负数以原码的补码形式表达。


## 🍀 二、概念

### 1、原码


一个正数，按照绝对值大小转换成的二进制数；一个负数按照绝对值大小转换成的二进制数，然后最高位补 1，称为原码。比如: 
- `00000000 00000000 00000000 00000101` 是 5 的 原码。
- `10000000 00000000 00000000 00000101` 是 -5 的 原码。

> [!note]
> 备注：
> 比如 byte 类型, 用 $2^8$ 来表示无符号整数的话, 是 0 - 255 了；如果有符号， 最高位表示符号, 0 为正, 1 为负, 那么, 正常的理解就是 -127 至 +127 了. 这就是原码了, 值得一提的是, 原码的弱点, 有 2 个 0, 即 `+0` 和 `-0`（`1000 0000` 和 `0000 0000`）；还有就是, 进行异号相加或同号相减时, 比较笨蛋, 先要判断 2 个数的绝对值大小, 然后进行加减操作, 最后运算结果的符号还要与大的符号相同；于是, 反码产生了。


### 2、反码


正数的反码与原码相同，负数的反码为对该数的原码除符号位外各位取反 [每一位取反 (除符号位)]。
取反操作指：原为 1，得 0；原为 0，得 1。（1 变 0; 0 变 1），比如：
- 正数 `00000000 00000000 00000000 00000101`  的反码还是 `00000000 00000000 00000000 00000101`
- 负数 `10000000 00000000 00000000 00000101`  的反码则是 `11111111 11111111 11111111 11111010`

反码是相互的，所以也可称：`10000000 00000000 00000000 00000101` 和 `11111111 11111111 11111111 11111010` 互为反码。

> [!note]
> 还是有 `+0` 和 `-0`, 没过多久，反码就成为了过滤产物, 也就是, 后来补码出现了。


### 3、补码


正数的补码与原码相同，负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加 1.
比如：
- `10000000 00000000 00000000 00000101` 的补码是：`11111111 11111111 11111111 11111010`

那么，补码为：
$11111111 11111111 11111111 11111010 + 1 = 11111111 11111111 11111111 11111011$

> [!note]
> 1. 从补码求原码的方法跟原码求补码是一样的 ，也可以通过完全逆运算来做，先减一，再取反。
> 2. 补码却规定 0 没有正负之分

所以，-5 在计算机中表达为：`11111111 11111111 11111111 11111011`。转换为十六进制：`0xFFFFFFFB`。



## 🍀 三、再举一例

我们来看整数 -1 在计算机中如何表示。假设这也是一个 int 类型，那么：

1. 先取 -1 的原码：`10000000 00000000 00000000 00000001`
2. 得反码：`11111111 11111111 11111111 11111110`（除符号位按位取反）
3. 得补码：`11111111 11111111 11111111 11111111`

可见，－1 在计算机里用二进制表达就是全 1。16 进制为：`0xFFFFFF`


## 🍀 四、主要知识点

- 正数的反码和补码都与原码**相同**。
- 负数的反码为对该数的原码除符号位外`按位取反`。
- 负数的补码为对该数的原码除符号位外`按位取反，然后在最后一位加 1`

- 原码：优点在于换算简单 缺点在于两个零 加减法需要独立运算
- 反码：有点在于表示清晰 缺点在于两个零 加减法同样需要独立运算
- 补码：优点在于一个零，范围大，减法可以转为加法；缺点在于理解困难

下面是书上原文：

> [!tip]
> - 原码表示法规定：用符号位和数值表示带符号数，正数的符号位用 “0” 表示，负数的符号位用 “1” 表示，数值部分用二进制形式表示。
> - 反码表示法规定：正数的反码与原码相同，负数的反码为对该数的原码除符号位外各位取反。
> - 补码表示法规定：正数的补码与原码相同，负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加 1.
> - 正零和负零的补码相同，$[+0]_补 =[-0]_补 = 0000 0000B$


## 🍀 五、特殊情况 -128

`1000 0000`, 那么, 它的原码是什么呢? 从补码求原码的方法跟原码求补码是一样的。先保留符号位其它求反: `1111 1111`, 再加 1，`1 0000 0000`, 超过了 8 位了。对, 用 8 位数的原码在这里已经无法表示了。

那么, 回到原码处, 它的原码也是 `1000 0000`(超出的自动丢失)，`1000 0000` 在原码表示什么呢? `-0`, 但补码却规定 0 没有正负之分。

转换一下思路, 看看计算机里, 是怎么运算的:

- 对于负数, 先取绝对值, 然后求反, 加一：  
  $-128 → 128  → 1000 0000 → 0111 1111 → 1000 0000$

现在明确了吧

所以，8 位有符号的整数取值范围的补码表示 `1000 0000` 到 `0000 0000`, 再到 `0111 1111`，即 -128 到 0, 再到 127，最终 $-128$ ~ $+127$

> [!caution]
> 永远记住：程序里的加减法对二进制是永远有效的。但是并不一定适合于真实世界。


```java
    byte m = -128;
    byte q = 1;
    byte p = (byte)(m - q); // 这一步其实编译器会报错，其实是发现越界了，我们强行转化为 byte 就可以看出结果。
    System.out.println(p); // p 的结果为：127
```

