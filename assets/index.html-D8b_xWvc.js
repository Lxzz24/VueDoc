import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as p,o as c,c as l,a as n,b as e,w as a,d as i,e as t}from"./app-CvlAI_tu.js";const u="/VueDoc/assets/image-20231220171220040-CiZkLaKx.png",d={},r={class:"hint-container details"},v=n("summary",null,"目录",-1),k={class:"table-of-contents"},m=i(`<p>一个 Web App 就是由一个或多个 Servlet 组成的，每个 Servlet 通过注解说明自己能处理的路径。例如：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@WebServlet</span><span class="token punctuation">(</span>urlPatterns <span class="token operator">=</span> <span class="token string">&quot;/hello&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述 <code>HelloServlet</code> 能处理 <code>/hello</code> 这个路径的请求。</p><div class="hint-container caution"><p class="hint-container-title">警告</p><p>早期的 Servlet 需要在 web.xml 中配置映射路径，但最新 Servlet 版本只需要通过注解就可以完成映射。</p></div><p>因为浏览器发送请求的时候，还会有请求方法（HTTP Method）：即 GET、POST、PUT 等不同类型的请求。因此，要处理 GET 请求，我们要覆写 <code>doGet()</code> 方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@WebServlet</span><span class="token punctuation">(</span>urlPatterns <span class="token operator">=</span> <span class="token string">&quot;/hello&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doGet</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> req<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> resp<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>类似的，要处理 POST 请求，就需要覆写 <code>doPost()</code> 方法。</p><p>如果没有覆写 <code>doPost()</code> 方法，那么 <code>HelloServlet</code> 能不能处理 <code>POST /hello</code> 请求呢？</p><p>我们查看一下 <code>HttpServlet</code> 的 <code>doPost()</code> 方法就一目了然了：它会直接返回 405 或 400 错误。因此，一个 Servlet 如果映射到 <code>/hello</code>，那么所有请求方法都会由这个 Servlet 处理，至于能不能返回 200 成功响应，要看有没有覆写对应的请求方法。</p><p>一个 Webapp 完全可以有多个 Servlet，分别映射不同的路径。例如：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@WebServlet</span><span class="token punctuation">(</span>urlPatterns <span class="token operator">=</span> <span class="token string">&quot;/hello&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@WebServlet</span><span class="token punctuation">(</span>urlPatterns <span class="token operator">=</span> <span class="token string">&quot;/signin&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SignInServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@WebServlet</span><span class="token punctuation">(</span>urlPatterns <span class="token operator">=</span> <span class="token string">&quot;/&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IndexServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>浏览器发出的 HTTP 请求总是由 Web Server 先接收，然后，根据 Servlet 配置的映射，不同的路径转发到不同的 Servlet：</p><figure><img src="`+u+`" alt="image-20231220171220040" tabindex="0" loading="lazy"><figcaption>image-20231220171220040</figcaption></figure><p>这种根据路径转发的功能我们一般称为 Dispatch。映射到 <code>/</code> 的 <code>IndexServlet</code> 比较特殊，它实际上会接收所有未匹配的路径，相当于 <code>/*</code>，因为 Dispatcher 的逻辑可以用伪代码实现如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> path <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">&quot;/hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">dispatchTo</span><span class="token punctuation">(</span>helloServlet<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">&quot;/signin&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">dispatchTo</span><span class="token punctuation">(</span>signinServlet<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 所有未匹配的路径均转发到 &quot;/&quot;</span>
    <span class="token function">dispatchTo</span><span class="token punctuation">(</span>indexServlet<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以我们在浏览器输入一个 <code>http://localhost:8080/abc</code> 也会看到 <code>IndexServlet</code> 生成的页面。</p><h2 id="🍀-httpservletrequest" tabindex="-1"><a class="header-anchor" href="#🍀-httpservletrequest" aria-hidden="true">#</a> 🍀 HttpServletRequest</h2><p><code>HttpServletRequest</code> 封装了一个 HTTP 请求，它实际上是从 <code>ServletRequest</code> 继承而来。最早设计 Servlet 时，设计者希望 Servlet 不仅能处理 HTTP，也能处理类似 SMTP 等其他协议，因此，单独抽出了 <code>ServletRequest</code> 接口，但实际上除了 HTTP 外，并没有其他协议会用 Servlet 处理，所以这是一个过度设计。</p><p>我们通过 <code>HttpServletRequest</code> 提供的接口方法可以拿到 HTTP 请求的几乎全部信息，常用的方法有：</p><ul><li>getMethod()：返回请求方法，例如，<code>&quot;GET&quot;</code>，<code>&quot;POST&quot;</code>；</li><li>getRequestURI()：返回请求路径，但不包括请求参数，例如，<code>&quot;/hello&quot;</code>；</li><li>getQueryString()：返回请求参数，例如，<code>&quot;name=Bob&amp;a=1&amp;b=2&quot;</code>；</li><li>getParameter(name)：返回请求参数，GET 请求从 URL 读取参数，POST 请求从 Body 中读取参数；</li><li>getContentType()：获取请求 Body 的类型，例如，<code>&quot;application/x-www-form-urlencoded&quot;</code>；</li><li>getContextPath()：获取当前 Webapp 挂载的路径，对于 ROOT 来说，总是返回空字符串 <code>&quot;&quot;</code>；</li><li>getCookies()：返回请求携带的所有 Cookie；</li><li>getHeader(name)：获取指定的 Header，对 Header 名称不区分大小写；</li><li>getHeaderNames()：返回所有 Header 名称；</li><li>getInputStream()：如果该请求带有 HTTP Body，该方法将打开一个输入流用于读取 Body；</li><li>getReader()：和 getInputStream() 类似，但打开的是 Reader；</li><li>getRemoteAddr()：返回客户端的 IP 地址；</li><li>getScheme()：返回协议类型，例如，<code>&quot;http&quot;</code>，<code>&quot;https&quot;</code>；</li></ul><p>此外，<code>HttpServletRequest</code> 还有两个方法：<code>setAttribute()</code> 和 <code>getAttribute()</code>，可以给当前 <code>HttpServletRequest</code> 对象附加多个 Key-Value，相当于把 <code>HttpServletRequest</code> 当作一个 <code>Map&lt;String, Object&gt;</code> 使用。</p><p>调用 <code>HttpServletRequest</code> 的方法时，注意务必阅读接口方法的文档说明，因为有的方法会返回 <code>null</code>，例如 <code>getQueryString()</code> 的文档就写了：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>... This method returns null if the URL does not have a query string...
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="🍀-httpservletresponse" tabindex="-1"><a class="header-anchor" href="#🍀-httpservletresponse" aria-hidden="true">#</a> 🍀 HttpServletResponse</h2><p><code>HttpServletResponse</code> 封装了一个 HTTP 响应。由于 HTTP 响应必须先发送 Header，再发送 Body，所以，操作 <code>HttpServletResponse</code> 对象时，必须先调用设置 Header 的方法，最后调用发送 Body 的方法。</p><p>常用的设置 Header 的方法有：</p><ul><li>setStatus(sc)：设置响应代码，默认是 <code>200</code>；</li><li>setContentType(type)：设置 Body 的类型，例如，<code>&quot;text/html&quot;</code>；</li><li>setCharacterEncoding(charset)：设置字符编码，例如，<code>&quot;UTF-8&quot;</code>；</li><li>setHeader(name, value)：设置一个 Header 的值；</li><li>addCookie(cookie)：给响应添加一个 Cookie；</li><li>addHeader(name, value)：给响应添加一个 Header，因为 HTTP 协议允许有多个相同的 Header；</li></ul><p>写入响应时，需要通过 <code>getOutputStream()</code> 获取写入流，或者通过 <code>getWriter()</code> 获取字符流，二者只能获取其中一个。</p><p>写入响应前，无需设置 <code>setContentLength()</code>，因为底层服务器会根据写入的字节数自动设置，如果写入的数据量很小，实际上会先写入缓冲区，如果写入的数据量很大，服务器会自动采用 Chunked 编码让浏览器能识别数据结束符而不需要设置 Content-Length 头。</p><p>但是，写入完毕后调用 <code>flush()</code> 却是必须的，因为大部分 Web 服务器都基于 HTTP/1.1 协议，会复用 TCP 连接。如果没有调用 <code>flush()</code>，将导致缓冲区的内容无法及时发送到客户端。此外，写入完毕后千万不要调用 <code>close()</code>，原因同样是因为会复用 TCP 连接，如果关闭写入流，将关闭 TCP 连接，使得 Web 服务器无法复用此 TCP 连接。</p><div class="hint-container caution"><p class="hint-container-title">警告</p><p>写入完毕后对输出流调用 flush() 而不是 close() 方法！</p></div><p>有了 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 这两个高级接口，我们就不需要直接处理 HTTP 协议。注意到具体的实现类是由各服务器提供的，而我们编写的 Web 应用程序只关心接口方法，并不需要关心具体实现的子类。</p><h2 id="🍀-servlet-多线程模型" tabindex="-1"><a class="header-anchor" href="#🍀-servlet-多线程模型" aria-hidden="true">#</a> 🍀 Servlet 多线程模型</h2><p>一个 Servlet 类在服务器中只有一个实例，但对于每个 HTTP 请求，Web 服务器会使用多线程执行请求。因此，一个 Servlet 的 <code>doGet()</code>、<code>doPost()</code> 等处理请求的方法是多线程并发执行的。如果 Servlet 中定义了字段，要注意多线程并发访问的问题：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doGet</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> req<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> resp<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
        <span class="token comment">// 注意读写 map 字段是多线程并发的:</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于每个请求，Web 服务器会创建唯一的 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 实例，因此，<code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 实例只有在当前处理线程中有效，它们总是局部变量，不存在多线程共享的问题。</p><h2 id="🍀-小结" tabindex="-1"><a class="header-anchor" href="#🍀-小结" aria-hidden="true">#</a> 🍀 小结</h2><p>一个 Webapp 中的多个 Servlet 依靠路径映射来处理不同的请求；</p><p>映射为 <code>/</code> 的 Servlet 可处理所有 “未匹配” 的请求；</p><p>如何处理请求取决于 Servlet 覆写的对应方法；</p><p>Web 服务器通过多线程处理 HTTP 请求，一个 Servlet 的处理方法可以由多线程并发执行。</p>`,41);function S(b,h){const s=p("router-link");return c(),l("div",null,[n("details",r,[v,n("nav",k,[n("ul",null,[n("li",null,[e(s,{to:"#🍀-httpservletrequest"},{default:a(()=>[t("🍀 HttpServletRequest")]),_:1})]),n("li",null,[e(s,{to:"#🍀-httpservletresponse"},{default:a(()=>[t("🍀 HttpServletResponse")]),_:1})]),n("li",null,[e(s,{to:"#🍀-servlet-多线程模型"},{default:a(()=>[t("🍀 Servlet 多线程模型")]),_:1})]),n("li",null,[e(s,{to:"#🍀-小结"},{default:a(()=>[t("🍀 小结")]),_:1})])])])]),m])}const q=o(d,[["render",S],["__file","index.html.vue"]]);export{q as default};
