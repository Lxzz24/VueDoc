const e=JSON.parse('{"key":"v-1696e730","path":"/1-Java/2_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/6.html","title":"面向对象三大特征","lang":"zh-CN","frontmatter":{"title":"面向对象三大特征","category":"Java 教程","tag":"Java","headerDepth":1,"description":"目录 [[toc]] 🍀 封装性（Encapsulation） 当我们创建一个类的对象以后，我们可以通过 对象.属性 的方式，对对象的属性进行赋值，这里，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没有其他制约条件。 但是，在实际问题中，我们往往需要给属性赋值，加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条...","head":[["meta",{"property":"og:url","content":"https://www.gxmnzl.cn/VueDoc/1-Java/2_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/6.html"}],["meta",{"property":"og:site_name","content":"BLOG"}],["meta",{"property":"og:title","content":"面向对象三大特征"}],["meta",{"property":"og:description","content":"目录 [[toc]] 🍀 封装性（Encapsulation） 当我们创建一个类的对象以后，我们可以通过 对象.属性 的方式，对对象的属性进行赋值，这里，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没有其他制约条件。 但是，在实际问题中，我们往往需要给属性赋值，加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-04T08:53:47.000Z"}],["meta",{"property":"article:author","content":"Lxzz24"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:modified_time","content":"2024-06-04T08:53:47.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"面向对象三大特征\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-06-04T08:53:47.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Lxzz24\\"}]}"]]},"headers":[{"level":2,"title":"🍀 封装性（Encapsulation）","slug":"🍀-封装性-encapsulation","link":"#🍀-封装性-encapsulation","children":[{"level":3,"title":"封装性的体现","slug":"封装性的体现","link":"#封装性的体现","children":[]},{"level":3,"title":"为什么需要封装？封装的作用和含义？","slug":"为什么需要封装-封装的作用和含义","link":"#为什么需要封装-封装的作用和含义","children":[]}]},{"level":2,"title":"🍀 继承性（inheritance）","slug":"🍀-继承性-inheritance","link":"#🍀-继承性-inheritance","children":[{"level":3,"title":"继承树","slug":"继承树","link":"#继承树","children":[]},{"level":3,"title":"protected","slug":"protected","link":"#protected","children":[]},{"level":3,"title":"super","slug":"super","link":"#super","children":[]},{"level":3,"title":"阻止继承 *","slug":"阻止继承","link":"#阻止继承","children":[]},{"level":3,"title":"向上转型","slug":"向上转型","link":"#向上转型","children":[]},{"level":3,"title":"向下转型","slug":"向下转型","link":"#向下转型","children":[]},{"level":3,"title":"区分继承和组合","slug":"区分继承和组合","link":"#区分继承和组合","children":[]},{"level":3,"title":"练习","slug":"练习","link":"#练习","children":[]},{"level":3,"title":"小结","slug":"小结","link":"#小结","children":[]}]},{"level":2,"title":"🍀 多态性(Polymorphic)","slug":"🍀-多态性-polymorphic","link":"#🍀-多态性-polymorphic","children":[{"level":3,"title":"定义","slug":"定义","link":"#定义","children":[]},{"level":3,"title":"重写 Object 方法","slug":"重写-object-方法","link":"#重写-object-方法","children":[]},{"level":3,"title":"调用 super","slug":"调用-super","link":"#调用-super","children":[]},{"level":3,"title":"final","slug":"final","link":"#final","children":[]},{"level":3,"title":"练习","slug":"练习-1","link":"#练习-1","children":[]},{"level":3,"title":"小结","slug":"小结-1","link":"#小结-1","children":[]}]}],"git":{"createdTime":1704354222000,"updatedTime":1717491227000,"contributors":[{"name":"Lxzz24","email":"lxzz108@gmail.com","commits":3}]},"readingTime":{"minutes":18.43,"words":5528},"filePathRelative":"1-Java/2_面向对象/面向对象基础/6.md","localizedDate":"2024年1月4日","autoDesc":true}');export{e as data};
