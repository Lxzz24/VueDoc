import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as e,o as t,c as o,a as n,b as c,w as p,d as l,e as i}from"./app-CvlAI_tu.js";const d={},u={class:"hint-container details"},r=n("summary",null,"目录",-1),k={class:"table-of-contents"},v=l(`<p>Java 的 <code>java.util.concurrent</code> 包除了提供底层锁、并发集合外，还提供了一组原子操作的封装类，它们位于 <code>java.util.concurrent.atomic</code> 包。</p><p>我们以 <code>AtomicInteger</code> 为例，它提供的主要操作有：</p><ul><li>增加值并返回新值：<code>int addAndGet(int delta)</code></li><li>加 1 后返回新值：<code>int incrementAndGet()</code></li><li>获取当前值：<code>int get()</code></li><li>用 CAS 方式设置：<code>int compareAndSet(int expect, int update)</code></li></ul><p>Atomic 类是通过无锁（lock-free）的方式实现的线程安全（thread-safe）访问。它的主要原理是利用了 CAS：Compare and Set。</p><p>如果我们自己通过 CAS 编写 <code>incrementAndGet()</code>，它大概长这样：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token class-name">AtomicInteger</span> <span class="token keyword">var</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> prev<span class="token punctuation">,</span> next<span class="token punctuation">;</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        prev <span class="token operator">=</span> <span class="token keyword">var</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        next <span class="token operator">=</span> prev <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token keyword">var</span><span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>CAS 是指，在这个操作中，如果 <code>AtomicInteger</code> 的当前值是 <code>prev</code>，那么就更新为 <code>next</code>，返回 <code>true</code>。如果 <code>AtomicInteger</code> 的当前值不是 <code>prev</code>，就什么也不干，返回 <code>false</code>。通过 CAS 操作并配合 <code>do ... while</code> 循环，即使其他线程修改了 <code>AtomicInteger</code> 的值，最终的结果也是正确的。</p><p>我们利用 <code>AtomicLong</code> 可以编写一个多线程安全的全局唯一 ID 生成器：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">IdGenerator</span> <span class="token punctuation">{</span>
    <span class="token class-name">AtomicLong</span> <span class="token keyword">var</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicLong</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getNextId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">var</span><span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通常情况下，我们并不需要直接用 <code>do ... while</code> 循环调用 <code>compareAndSet</code> 实现复杂的并发操作，而是用 <code>incrementAndGet()</code> 这样的封装好的方法，因此，使用起来非常简单。</p><p>在高度竞争的情况下，还可以使用 Java 8 提供的 <code>LongAdder</code> 和 <code>LongAccumulator</code>。</p><h2 id="🍀-小结" tabindex="-1"><a class="header-anchor" href="#🍀-小结" aria-hidden="true">#</a> 🍀 小结</h2><p>使用 <code>java.util.concurrent.atomic</code> 提供的原子操作可以简化多线程编程：</p><ul><li>原子操作实现了无锁的线程安全；</li><li>适用于计数器，累加器等。</li></ul>`,14);function m(b,A){const a=e("router-link");return t(),o("div",null,[n("details",u,[r,n("nav",k,[n("ul",null,[n("li",null,[c(a,{to:"#🍀-小结"},{default:p(()=>[i("🍀 小结")]),_:1})])])])]),v])}const w=s(d,[["render",m],["__file","16.html.vue"]]);export{w as default};
