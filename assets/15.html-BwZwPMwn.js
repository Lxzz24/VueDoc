import{_ as c}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as t,o as p,c as l,a,b as s,w as e,d,e as o}from"./app-CvlAI_tu.js";const i="/VueDoc/assets/20220615225804-ByhYW7wx.png",u={},r={class:"hint-container details"},v=a("summary",null,"目录",-1),m={class:"table-of-contents"},k=d(`<p>从 Java 9 开始，JDK 又引入了模块（Module）。</p><h2 id="🍀-什么是模块" tabindex="-1"><a class="header-anchor" href="#🍀-什么是模块" aria-hidden="true">#</a> 🍀 什么是模块？</h2><p>这要从 Java 9 之前的版本说起。</p><p>我们知道，<code>.class</code> 文件是 JVM 看到的最小可执行文件，而一个大型程序需要编写很多 Class，并生成一堆 <code>.class</code> 文件，很不便于管理，所以，<code>jar</code> 文件就是 <code>class</code> 文件的容器。</p><p>在 Java 9 之前，一个大型 Java 程序会生成自己的 jar 文件，同时引用依赖的第三方 jar 文件，而 JVM 自带的 Java 标准库，实际上也是以 jar 文件形式存放的，这个文件叫 <code>rt.jar</code>，一共有 60 多 M。</p><p>如果是自己开发的程序，除了一个自己的 <code>app.jar</code> 以外，还需要一堆第三方的 jar 包，运行一个 Java 程序，一般来说，命令行写这样：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>java -cp app.jar:a.jar:b.jar:c.jar com.liaoxuefeng.sample.Main
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="hint-container caution"><p class="hint-container-title">警告</p><p>JVM 自带的标准库 rt.jar 不要写到 classpath 中，写了反而会干扰 JVM 的正常运行。</p></div><p>如果漏写了某个运行时需要用到的 jar ，那么在运行期极有可能抛出 <code>ClassNotFoundException</code> 。</p><p>所以，jar 只是用于存放 class 的容器，它并不关心 class 之间的依赖。</p><p>从 Java 9 开始引入的模块，主要是为了解决 “依赖” 这个问题。如果 <code>a.jar</code> 必须依赖另一个 <code>b.jar</code> 才能运行，那我们应该给 <code>a.jar</code> 加点说明啥的，让程序在编译和运行的时候能自动定位到 <code>b.jar</code>，这种自带 “依赖关系” 的 class 容器就是模块。</p><p>为了表明 Java 模块化的决心，从 Java 9 开始，原有的 Java 标准库已经由一个单一巨大的 <code>rt.jar</code> 分拆成了几十个模块，这些模块以 <code>.jmod</code> 扩展名标识，可以在 <code>$JAVA_HOME/jmods</code> 目录下找到它们：</p><ul><li>java.base.jmod</li><li>java.compiler.jmod</li><li>java.datatransfer.jmod</li><li>java.desktop.jmod</li><li>...</li></ul><p>这些 <code>.jmod</code> 文件每一个都是一个模块，模块名就是文件名。例如：模块 <code>java.base</code> 对应的文件就是 <code>java.base.jmod</code> 。模块之间的依赖关系已经被写入到模块内的 <code>module-info.class</code> 文件了。所有的模块都直接或间接地依赖 <code>java.base</code> 模块，只有 <code>java.base</code> 模块不依赖任何模块，它可以被看作是 “根模块”，好比所有的类都是从 <code>Object</code> 直接或间接继承而来。</p><p>把一堆 class 封装为 jar 仅仅是一个打包的过程，而把一堆 class 封装为模块则不但需要打包，还需要写入依赖关系，并且还可以包含二进制代码（通常是 JNI 扩展）。此外，模块支持多版本，即在同一个模块中可以为不同的 JVM 提供不同的版本。</p><h2 id="🍀-编写模块" tabindex="-1"><a class="header-anchor" href="#🍀-编写模块" aria-hidden="true">#</a> 🍀 编写模块</h2><p>那么，我们应该如何编写模块呢？还是以具体的例子来说。首先，创建模块和原有的创建 Java 项目是完全一样的，以 <code>oop-module</code> 工程为例，它的目录结构如下：</p><pre><code>oop-module
├── bin
├── build.sh
└── src
    ├── com
    │   └── itranswarp
    │       └── sample
    │           ├── Greeting.java
    │           └── Main.java
    └── module-info.java
</code></pre><p>其中，<code>bin</code> 目录存放编译后的 class 文件，<code>src</code> 目录存放源码，按包名的目录结构存放，仅仅在 <code>src</code> 目录下多了一个 <code>module-info.java</code> 这个文件，这就是模块的描述文件。在这个模块中，它长这样：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">module</span> <span class="token namespace">hello<span class="token punctuation">.</span>world</span> <span class="token punctuation">{</span>
	<span class="token keyword">requires</span> <span class="token namespace">java<span class="token punctuation">.</span>base</span><span class="token punctuation">;</span> <span class="token comment">// 可不写，任何模块都会自动引入 java.base</span>
	<span class="token keyword">requires</span> <span class="token namespace">java<span class="token punctuation">.</span>xml</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，<code>module</code> 是关键字，后面的 <code>hello.world</code> 是模块的名称，它的命名规范与包一致。花括号的 <code>requires xxx;</code> 表示这个模块需要引用的其他模块名。除了 <code>java.base</code> 可以被自动引入外，这里我们引入了一个 <code>java.xml</code> 的模块。</p><p>当我们使用模块声明了依赖关系后，才能使用引入的模块。例如，<code>Main.java</code> 代码如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itranswarp<span class="token punctuation">.</span>sample</span><span class="token punctuation">;</span>

<span class="token comment">// 必须引入 java.xml 模块后才能使用其中的类:</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">javax<span class="token punctuation">.</span>xml<span class="token punctuation">.</span></span><span class="token class-name">XMLConstants</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token class-name">Greeting</span> g <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Greeting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>g<span class="token punctuation">.</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token class-name">XMLConstants</span><span class="token punctuation">.</span><span class="token constant">XML_NS_PREFIX</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果把 <code>requires java.xml;</code> 从 <code>module-info.java</code> 中去掉，编译将报错。可见，<strong><em>模块的重要作用就是声明依赖关系</em></strong> 。</p><p>下面，我们用 JDK 提供的命令行工具来编译并创建模块。</p><p>首先，我们把工作目录切换到 <code>oop-module</code>，在当前目录下编译所有的 <code>.java</code> 文件，并存放到 <code>bin</code> 目录下，命令如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ javac -d bin src/module-info.java src/com/itranswarp/sample/*.java
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果编译成功，现在项目结构如下：</p><pre><code>oop-module
├── bin
│   ├── com
│   │   └── itranswarp
│   │       └── sample
│   │           ├── Greeting.class
│   │           └── Main.class
│   └── module-info.class
└── src
    ├── com
    │   └── itranswarp
    │       └── sample
    │           ├── Greeting.java
    │           └── Main.java
    └── module-info.java
</code></pre><p>注意到 <code>src</code> 目录下的 <code>module-info.java</code> 被编译到 <code>bin</code> 目录下的 <code>module-info.class</code> 。</p><p>下一步，我们需要把 <code>bin</code> 目录下的所有 class 文件先打包成 jar，在打包的时候，注意传入 <code>--main-class</code> 参数，让这个 jar 包能自己定位 <code>main</code> 方法所在的类：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ jar --create --file hello.jar --main-class com.itranswarp.sample.Main -C bin .
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>现在我们就在当前目录下得到了 <code>hello.jar</code> 这个 jar 包，它和普通 jar 包并无区别，可以直接使用命令 <code>java -jar hello.jar</code> 来运行它。但是我们的目标是创建模块，所以，继续使用 JDK 自带的 <code>jmod</code> 命令把一个 <code>jar</code> 包转换成模块：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ jmod create --class-path hello.jar hello.jmod
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>于是，在当前目录下我们又得到了 <code>hello.jmod</code> 这个模块文件，这就是最后打包出来的传说中的模块！</p><h2 id="🍀-运行模块" tabindex="-1"><a class="header-anchor" href="#🍀-运行模块" aria-hidden="true">#</a> 🍀 运行模块</h2><p>要运行一个 jar，我们使用 <code>java -jar xxx.jar</code> 命令。要运行一个模块，我们只需要指定模块名。试试：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ java --module-path hello.jmod --module hello.world
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>结果是一个错误：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Error occurred during initialization of boot layer
java.lang.module.FindException: JMOD format not supported at execution time: hello.jmod
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>原因是 <code>.jmod</code> 不能被放入 <code>--module-path</code> 中。换成 <code>.jar</code> 就没问题了：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ java --module-path hello.jar --module hello.world
Hello, xml!
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>那我们辛辛苦苦创建的 <code>hello.jmod</code> 有什么用？答案是我们可以用它来打包 JRE 。</p><h2 id="🍀-打包-jre" tabindex="-1"><a class="header-anchor" href="#🍀-打包-jre" aria-hidden="true">#</a> 🍀 打包 JRE</h2><p>前面讲了，为了支持模块化，Java 9 首先带头把自己的一个巨大无比的 <code>rt.jar</code> 拆成了几十个 <code>.jmod</code> 模块，原因就是，运行 Java 程序的时候，实际上我们用到的 JDK 模块，并没有那么多。不需要的模块，完全可以删除。</p><p>过去发布一个 Java 应用程序，要运行它，必须下载一个完整的 JRE，再运行 jar 包。而完整的 JRE 块头很大，有 100 多 M。怎么给 JRE 瘦身呢？</p><p>现在，JRE 自身的标准库已经分拆成了模块，只需要带上程序用到的模块，其他的模块就可以被裁剪掉。怎么裁剪 JRE 呢？并不是说把系统安装的 JRE 给删掉部分模块，而是 “复制” 一份 JRE，但只带上用到的模块。为此，JDK 提供了 <code>jlink</code> 命令来干这件事。命令如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ jlink --module-path hello.jmod --add-modules java.base,java.xml,hello.world --output jre/
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我们在 <code>--module-path</code> 参数指定了我们自己的模块 <code>hello.jmod</code>，然后，在 <code>--add-modules</code> 参数中指定了我们用到的 3 个模块 <code>java.base</code>、<code>java.xml</code> 和 <code>hello.world</code>，用 <code>,</code> 分隔。最后，在 <code>--output</code> 参数指定输出目录。</p><p>现在，在当前目录下，我们可以找到 <code>jre</code> 目录，这是一个完整的并且带有我们自己 <code>hello.jmod</code> 模块的 JRE。试试直接运行这个 JRE：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ jre/bin/java --module hello.world
Hello, xml!
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>要分发我们自己的 Java 应用程序，只需要把这个 <code>jre</code> 目录打个包给对方发过去，对方直接运行上述命令即可，既不用下载安装 JDK，也不用知道如何配置我们自己的模块，极大地方便了分发和部署。</p><h2 id="🍀-访问权限" tabindex="-1"><a class="header-anchor" href="#🍀-访问权限" aria-hidden="true">#</a> 🍀 访问权限</h2><p>前面我们讲过，Java 的 class 访问权限分为 public、protected、private 和默认的包访问权限。引入模块后，这些访问权限的规则就要稍微做些调整。</p><p>确切地说，class 的这些访问权限只在一个模块内有效，模块和模块之间，例如，a 模块要访问 b 模块的某个 class，必要条件是 b 模块明确地导出了可以访问的包。</p><p>举个例子：我们编写的模块 <code>hello.world</code> 用到了模块 <code>java.xml</code> 的一个类 <code>javax.xml.XMLConstants</code>，我们之所以能直接使用这个类，是因为模块 <code>java.xml</code> 的 <code>module-info.java</code> 中声明了若干导出：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">module</span> <span class="token namespace">java<span class="token punctuation">.</span>xml</span> <span class="token punctuation">{</span>
    <span class="token keyword">exports</span> <span class="token namespace">java<span class="token punctuation">.</span>xml</span><span class="token punctuation">;</span>
    <span class="token keyword">exports</span> <span class="token namespace">javax<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>catalog</span><span class="token punctuation">;</span>
    <span class="token keyword">exports</span> <span class="token namespace">javax<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>datatype</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>只有它声明的导出的包，外部代码才被允许访问。换句话说，如果外部代码想要访问我们的 <code>hello.world</code> 模块中的 <code>com.itranswarp.sample.Greeting</code> 类，我们必须将其导出：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">module</span> <span class="token namespace">hello<span class="token punctuation">.</span>world</span> <span class="token punctuation">{</span>
    <span class="token keyword">exports</span> <span class="token namespace">com<span class="token punctuation">.</span>itranswarp<span class="token punctuation">.</span>sample</span><span class="token punctuation">;</span>

    <span class="token keyword">requires</span> <span class="token namespace">java<span class="token punctuation">.</span>base</span><span class="token punctuation">;</span>
	<span class="token keyword">requires</span> <span class="token namespace">java<span class="token punctuation">.</span>xml</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因此，模块进一步隔离了代码的访问权限。</p><h2 id="🍀-练习" tabindex="-1"><a class="header-anchor" href="#🍀-练习" aria-hidden="true">#</a> 🍀 练习</h2><p>请练习如何打包模块和 JRE。</p><figure><img src="`+i+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itranswarp<span class="token punctuation">.</span>sample</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">javax<span class="token punctuation">.</span>xml<span class="token punctuation">.</span></span><span class="token class-name">XMLConstants</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>

	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token class-name">Greeting</span> g <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Greeting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>g<span class="token punctuation">.</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token class-name">XMLConstants</span><span class="token punctuation">.</span><span class="token constant">XML_NS_PREFIX</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itranswarp<span class="token punctuation">.</span>sample</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Greeting</span> <span class="token punctuation">{</span>

	<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token string">&quot;Hello, &quot;</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">&quot;!&quot;</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">module</span> <span class="token namespace">hello<span class="token punctuation">.</span>world</span> <span class="token punctuation">{</span>
	<span class="token keyword">requires</span> <span class="token namespace">java<span class="token punctuation">.</span>base</span><span class="token punctuation">;</span>
	<span class="token keyword">requires</span> <span class="token namespace">java<span class="token punctuation">.</span>xml</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="🍀-小结" tabindex="-1"><a class="header-anchor" href="#🍀-小结" aria-hidden="true">#</a> 🍀 小结</h2><p>Java 9 引入的模块目的是为了管理依赖；</p><p>使用模块可以按需打包 JRE；</p><p>使用模块对类的访问权限有了进一步限制。</p>`,70);function j(b,h){const n=t("router-link");return p(),l("div",null,[a("details",r,[v,a("nav",m,[a("ul",null,[a("li",null,[s(n,{to:"#🍀-什么是模块"},{default:e(()=>[o("🍀 什么是模块？")]),_:1})]),a("li",null,[s(n,{to:"#🍀-编写模块"},{default:e(()=>[o("🍀 编写模块")]),_:1})]),a("li",null,[s(n,{to:"#🍀-运行模块"},{default:e(()=>[o("🍀 运行模块")]),_:1})]),a("li",null,[s(n,{to:"#🍀-打包-jre"},{default:e(()=>[o("🍀 打包 JRE")]),_:1})]),a("li",null,[s(n,{to:"#🍀-访问权限"},{default:e(()=>[o("🍀 访问权限")]),_:1})]),a("li",null,[s(n,{to:"#🍀-练习"},{default:e(()=>[o("🍀 练习")]),_:1})]),a("li",null,[s(n,{to:"#🍀-小结"},{default:e(()=>[o("🍀 小结")]),_:1})])])])]),k])}const w=c(u,[["render",j],["__file","15.html.vue"]]);export{w as default};
