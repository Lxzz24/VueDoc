import{_ as c}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as o,o as m,c as p,a as l,b as i,w as s,d as e,e as a}from"./app-CvlAI_tu.js";const h="/VueDoc/assets/image-20240513091017820-DznALzvB.png",d="/VueDoc/assets/image-20240513092531825-L2Ev4nJq.png",g="/VueDoc/assets/13-Dj3fmRJ3.png",b="/VueDoc/assets/14-CiPcDfTE.png",x="/VueDoc/assets/image-20240513100223265-BPwTQc0g.png",f="/VueDoc/assets/image-20240513113027528-DPWQo5lo.png",k="/VueDoc/assets/image-20240513143644997-D-bI97k6.png",y="/VueDoc/assets/image-20240513163231274-EeIGANvT.png",_="/VueDoc/assets/1685074637082-03033021-2e2d-4fbb-a74f-0afb51fc7495-BKp8hfpv.png",v="/VueDoc/assets/16-CmQGkprk.png",M={},w={class:"hint-container details"},q=l("summary",null,"目录",-1),C={class:"table-of-contents"},T=e('<h2 id="🍀-软件过程" tabindex="-1"><a class="header-anchor" href="#🍀-软件过程" aria-hidden="true">#</a> 🍀 软件过程</h2><h3 id="能力成熟度模型-cmm" tabindex="-1"><a class="header-anchor" href="#能力成熟度模型-cmm" aria-hidden="true">#</a> 能力成熟度模型（CMM）</h3><p>CMM 将软件过程改进分为以下 5 个成熟度级别：</p><ol><li><p><u>初始级</u>（最低成熟度）：软件过程的特点是杂乱无章，有时甚至很混乱，几乎没有明确定义的步骤，<em>项目的成功完全依赖个人的努力和<strong>英雄式核心人物</strong>的作用。</em></p></li><li><p><u>可重复级</u>：<em>建立了<strong>基本</strong>的项目管理过程和实践</em>来跟踪项目费用、进度和功能特性，有必要的过程准则来重复以前在同类项目中的成功。</p></li><li><p><u>已定义级</u>：管理和工程两方面的软件过程已经<strong>文档化、标准化</strong>，并综合成整个软件开发组织的<strong>标准软件过程</strong>。</p></li><li><p><u>已管理级</u>：制定了<strong>软件过程</strong>和<strong>产品质量</strong>的<em>详细度量标准</em>。软件过程的产品质量都被开发组织的成员所理解和控制。</p></li><li><p><u>优化级</u>（最高成熟度）：<em>加强了定量分析</em>，通过来自<strong>过程质量反馈</strong>和来自<strong>新观念、新技术</strong>的反馈使过程能不断持续地改进。</p></li></ol><h3 id="能力成熟度模型集成-cmmi" tabindex="-1"><a class="header-anchor" href="#能力成熟度模型集成-cmmi" aria-hidden="true">#</a> 能力成熟度模型集成（CMMI）</h3><p>CMMI 提供了两种表示方法：</p><h4 id="_1-阶段式模型" tabindex="-1"><a class="header-anchor" href="#_1-阶段式模型" aria-hidden="true">#</a> 1 阶段式模型</h4><blockquote><p>没考过</p></blockquote><p>阶段式模型的结构类似于 CMM，它关注组织的成熟度。有五个成熟度等级：</p><ol><li>初始的：过程不可预测且缺乏控制。</li><li>已管理的：过程为项目服务。</li><li>已定义的：过程为组织服务。</li><li>定量管理的：过程已度量和控制。</li><li>优化的：集中于过程改进。</li></ol><h4 id="_2-连续式模型" tabindex="-1"><a class="header-anchor" href="#_2-连续式模型" aria-hidden="true">#</a> 2 连续式模型</h4>',11),O=l("ul",null,[l("li",null,[l("p",null,[l("u",null,[l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"C"),l("msub",null,[l("mi",null,"L"),l("mn",null,"0")])]),l("annotation",{encoding:"application/x-tex"},"CL₀")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.8333em","vertical-align":"-0.15em"}}),l("span",{class:"mord mathnormal",style:{"margin-right":"0.07153em"}},"C"),l("span",{class:"mord"},[l("span",{class:"mord mathnormal"},"L"),l("span",{class:"msupsub"},[l("span",{class:"vlist-t vlist-t2"},[l("span",{class:"vlist-r"},[l("span",{class:"vlist",style:{height:"0.3011em"}},[l("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[l("span",{class:"pstrut",style:{height:"2.7em"}}),l("span",{class:"sizing reset-size6 size3 mtight"},[l("span",{class:"mord mtight"},[l("span",{class:"mord mtight"},"0")])])])]),l("span",{class:"vlist-s"},"​")]),l("span",{class:"vlist-r"},[l("span",{class:"vlist",style:{height:"0.15em"}},[l("span")])])])])])])])])]),l("em",null,"（未完成的）"),a("：过程域"),l("strong",null,"未执行"),a("或"),l("strong",null,"未得到"),a(" CL₁ 中定义的所有目标。")])]),l("li",null,[l("p",null,[l("u",null,[l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"C"),l("msub",null,[l("mi",null,"L"),l("mn",null,"1")])]),l("annotation",{encoding:"application/x-tex"},"CL₁")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.8333em","vertical-align":"-0.15em"}}),l("span",{class:"mord mathnormal",style:{"margin-right":"0.07153em"}},"C"),l("span",{class:"mord"},[l("span",{class:"mord mathnormal"},"L"),l("span",{class:"msupsub"},[l("span",{class:"vlist-t vlist-t2"},[l("span",{class:"vlist-r"},[l("span",{class:"vlist",style:{height:"0.3011em"}},[l("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[l("span",{class:"pstrut",style:{height:"2.7em"}}),l("span",{class:"sizing reset-size6 size3 mtight"},[l("span",{class:"mord mtight"},[l("span",{class:"mord mtight"},"1")])])])]),l("span",{class:"vlist-s"},"​")]),l("span",{class:"vlist-r"},[l("span",{class:"vlist",style:{height:"0.15em"}},[l("span")])])])])])])])])]),l("em",null,"（已执行的）"),a("：其共性目标是过程将"),l("em",null,"可标识的输入工作产品"),l("strong",null,"转换成"),l("em",null,"可标识的输出工作产品"),a("，以实现支持过程域的特定目标。")])]),l("li",null,[l("p",null,[l("u",null,[l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"C"),l("msub",null,[l("mi",null,"L"),l("mn",null,"2")])]),l("annotation",{encoding:"application/x-tex"},"CL₂")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.8333em","vertical-align":"-0.15em"}}),l("span",{class:"mord mathnormal",style:{"margin-right":"0.07153em"}},"C"),l("span",{class:"mord"},[l("span",{class:"mord mathnormal"},"L"),l("span",{class:"msupsub"},[l("span",{class:"vlist-t vlist-t2"},[l("span",{class:"vlist-r"},[l("span",{class:"vlist",style:{height:"0.3011em"}},[l("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[l("span",{class:"pstrut",style:{height:"2.7em"}}),l("span",{class:"sizing reset-size6 size3 mtight"},[l("span",{class:"mord mtight"},[l("span",{class:"mord mtight"},"2")])])])]),l("span",{class:"vlist-s"},"​")]),l("span",{class:"vlist-r"},[l("span",{class:"vlist",style:{height:"0.15em"}},[l("span")])])])])])])])])]),l("em",null,"（已管理的）"),a("：其共性目标集中于"),l("strong",null,"已管理的"),l("em",null,"过程的制度化"),a("。根据组织级政策规定过程的运作将使用哪个过程，项目遵循已文档化的计划和过程描述，所有正在工作的人都有权使用足够的资源，所有工作任务和工作产品都被监控、控制和评审。")])]),l("li",null,[l("p",null,[l("u",null,[l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"C"),l("msub",null,[l("mi",null,"L"),l("mn",null,"3")])]),l("annotation",{encoding:"application/x-tex"},"CL₃")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.8333em","vertical-align":"-0.15em"}}),l("span",{class:"mord mathnormal",style:{"margin-right":"0.07153em"}},"C"),l("span",{class:"mord"},[l("span",{class:"mord mathnormal"},"L"),l("span",{class:"msupsub"},[l("span",{class:"vlist-t vlist-t2"},[l("span",{class:"vlist-r"},[l("span",{class:"vlist",style:{height:"0.3011em"}},[l("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[l("span",{class:"pstrut",style:{height:"2.7em"}}),l("span",{class:"sizing reset-size6 size3 mtight"},[l("span",{class:"mord mtight"},[l("span",{class:"mord mtight"},"3")])])])]),l("span",{class:"vlist-s"},"​")]),l("span",{class:"vlist-r"},[l("span",{class:"vlist",style:{height:"0.15em"}},[l("span")])])])])])])])])]),l("em",null,"（已定义级的）"),a("：其共性目标集中于"),l("strong",null,"已定义的"),l("em",null,"过程的制度化"),a("。过程是按照"),l("strong",null,"组织"),a("的剪裁指南从组织的标准过程集中剪裁得到的，还必须收集过程资产和过程的度量，并用于将来对过程的改进。")])]),l("li",null,[l("p",null,[l("u",null,[l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"C"),l("msub",null,[l("mi",null,"L"),l("mn",null,"4")])]),l("annotation",{encoding:"application/x-tex"},"CL₄")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.8333em","vertical-align":"-0.15em"}}),l("span",{class:"mord mathnormal",style:{"margin-right":"0.07153em"}},"C"),l("span",{class:"mord"},[l("span",{class:"mord mathnormal"},"L"),l("span",{class:"msupsub"},[l("span",{class:"vlist-t vlist-t2"},[l("span",{class:"vlist-r"},[l("span",{class:"vlist",style:{height:"0.3011em"}},[l("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[l("span",{class:"pstrut",style:{height:"2.7em"}}),l("span",{class:"sizing reset-size6 size3 mtight"},[l("span",{class:"mord mtight"},[l("span",{class:"mord mtight"},"4")])])])]),l("span",{class:"vlist-s"},"​")]),l("span",{class:"vlist-r"},[l("span",{class:"vlist",style:{height:"0.15em"}},[l("span")])])])])])])])])]),l("em",null,"（定量管理的）"),a("：其共性目标集中于"),l("strong",null,"可定量管理的"),l("em",null,"过程的制度化"),a("。使用测量和质量保证来控制和改进过程域，建立和使用关于质量和过程执行的定量目标作为管理准则。")])]),l("li",null,[l("p",null,[l("u",null,[l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"C"),l("msub",null,[l("mi",null,"L"),l("mn",null,"5")])]),l("annotation",{encoding:"application/x-tex"},"CL₅")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.8333em","vertical-align":"-0.15em"}}),l("span",{class:"mord mathnormal",style:{"margin-right":"0.07153em"}},"C"),l("span",{class:"mord"},[l("span",{class:"mord mathnormal"},"L"),l("span",{class:"msupsub"},[l("span",{class:"vlist-t vlist-t2"},[l("span",{class:"vlist-r"},[l("span",{class:"vlist",style:{height:"0.3011em"}},[l("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[l("span",{class:"pstrut",style:{height:"2.7em"}}),l("span",{class:"sizing reset-size6 size3 mtight"},[l("span",{class:"mord mtight"},[l("span",{class:"mord mtight"},"5")])])])]),l("span",{class:"vlist-s"},"​")]),l("span",{class:"vlist-r"},[l("span",{class:"vlist",style:{height:"0.15em"}},[l("span")])])])])])])])])]),l("em",null,"（优化的）"),a("：使用"),l("strong",null,"量化"),a("（统计学）手段"),l("em",null,"改变和优化过程域"),a("，以满足客户要求的改变和持续改进计划中的过程域的功效。")])])],-1),L=e('<h2 id="🍀-软件过程模型" tabindex="-1"><a class="header-anchor" href="#🍀-软件过程模型" aria-hidden="true">#</a> 🍀 软件过程模型</h2><p>软件开发过程模型是指为了有效地开发、维护和更新软件系统，提出的一系列步骤、阶段和方法的系统框架，以实现提高软件质量、加快开发速度和降低开发成本的目的。</p><h3 id="_1-瀑布模型-waterfall-model" tabindex="-1"><a class="header-anchor" href="#_1-瀑布模型-waterfall-model" aria-hidden="true">#</a> 1 瀑布模型 Waterfall Model</h3><p>瀑布模型是一种线性的软件开发过程模型，开发流程严格按照顺序依次进行，每个阶段都必须完成后才能进入下一个阶段。瀑布模型包括需求分析、设计、编码、测试和维护五个阶段。</p><figure><img src="'+h+'" alt="瀑布模型" width="300" tabindex="0" loading="lazy"><figcaption>瀑布模型</figcaption></figure><blockquote><p>瀑布模型以项目的阶段评审和文档控制为手段有效地对整个开发过程进行指导，它是<strong>以文档为驱动</strong>，适合于软件需求很明确的软件项目的模型。</p></blockquote><ul><li>优点： <ul><li>容易理解、管理成本低</li><li>每个阶段都有对应的成果产物</li><li>各个阶段有明显的界限划分和顺序需求</li><li><em>强调开发的阶段性早期计划及需求调查和产品测试</em></li></ul></li><li>缺点： <ul><li>需要客户能够完整、正确和清晰地表达自己的需要</li><li>在开始的两个或 3 个阶段中，很难评估真正的进度状态</li><li>当接近项目结束时，出现了大量的集成和测试工作</li><li>直到项目结束之前，都不能演示系统的能力</li><li><s>一旦发生错误，整个项目要推到重新开始</s></li><li>需求或设计中的错误往往只有到了项目后期才能够被发现，<s>对于项目风险的控制能力较弱</s>，从而导致项目常常延期完成，开发费用超出预算</li></ul></li></ul><p>瀑布模式适合用于：</p><ul><li><em>开发需求明确</em>的，需求大致固定且不会随意变更的系统</li><li>开发人员对软件的应用领域很熟悉</li><li>开发工作对用户参与的要求很低</li></ul><h3 id="_2-增量模型-incremental-model" tabindex="-1"><a class="header-anchor" href="#_2-增量模型-incremental-model" aria-hidden="true">#</a> 2 增量模型 Incremental Model</h3><p>增量模型采用了<strong>逐步完善</strong>的思路，将软件的开发过程划分为一个个的增量，每个增量都能够独立实现某一或多项功能或特性。在逐步实现的过程中，可以不断根据需求变化来进行迭代，从而保证最终的软件达到客户需求和期望。</p><figure><img src="'+d+'" alt="增量模型" tabindex="0" loading="lazy"><figcaption>增量模型</figcaption></figure><p>增量模型作为瀑布模型的一个变体，<em>具有瀑布模型的所有优点</em>。此外，它还有以下优点：</p><ul><li><em>第一个可交付版本所需要的成本和时间很少</em></li><li>开发由增量表示的小系统所<em>承担的风险不大</em></li><li>由于很快发布了第一个版本，因此可以减少用户需求的变更</li><li><em>优先级高的功能先交付</em>，使得重要的功能经历更多的测试</li><li>运行增量投资，即在项目开始时，可以仅对一个或两个增量投资</li></ul><p>缺点：</p><ul><li>如果没有对用户的变更要求进行规划，那么产生的初始增量可能会造成后来增量的不稳定</li><li>如果需求不像早期思考的那样稳定和完整，那么一些增量就可能需要重新开发、重新发布</li><li><s>管理发生的成本、进度和配置的复杂性可能会超出组织的能力</s></li></ul><p>增量模型适合用于：</p><ul><li>需求尚不明确</li><li>需要<em>快速构造可运行的产品</em>的项目（对完成期限严格要求的产品）适宜商业开发</li><li>进行已有产品升级或新版本开发</li><li>对所开发的领域比较熟悉而且已有原型系统。</li></ul><h3 id="_3-演化模型-evolutionary-model" tabindex="-1"><a class="header-anchor" href="#_3-演化模型-evolutionary-model" aria-hidden="true">#</a> 3 演化模型 Evolutionary Model</h3><p>演化模型是<strong>迭代</strong>的过程模型，使得软件开发人员能够逐步开发出更完整的软件版本。演化模型特别适用于<s>对软件需求缺乏准确认识</s>的情况。典型的演化模型有原型模型和螺旋模型等。</p><h4 id="_3-1-原型模型-prototype-model" tabindex="-1"><a class="header-anchor" href="#_3-1-原型模型-prototype-model" aria-hidden="true">#</a> 3.1 原型模型 Prototype Model</h4><p>并非所有的需求都能够预先定义。大量的实践表明，在开发初期很难得到一个完整的、准确的需求规格说明。原因有：</p><ul><li>客户往往不能准确地表达对未来系统的全面要求，导致形成的需求规格说明不完整、不准确，甚至是有歧义。</li><li>在整个开发过程中，用户可能会产生新的要求，导致需求的变更。</li></ul><p>原型模型：</p><ul><li>适合于<em>用户需求不清</em>、<em>需求经常变化</em>的情况</li><li><s>不适合大规模系统的开发</s></li></ul><figure><img src="'+g+'" alt="原型模型" width="300" tabindex="0" loading="lazy"><figcaption>原型模型</figcaption></figure><p>原型的目的是<strong>能快速、低成本地构建原型系统</strong>。</p><p>开发原型系统首先确定用户需求，开发初始原型，然后征求用户对初始原型的改进意见，并根据意见修改原型:</p><ol><li><u>交流</u>：目的是定义软件的总体目标，标识需求，然后</li><li><u>快速计划</u>：快速制订原型开发的计划，确定原型的目标和范围</li><li><u>采用快速设计方式进行建模</u></li><li><u>构建原型</u></li><li><u>部署交付和反馈</u>：<em>被开发的原型应交付给客户使用</em>，并收集客户的反馈意见，这些反馈意见可在下一轮中对原型进行改进</li><li><u>下一轮迭代</u>：<em>在前一个原型需要改进，或者需要扩展其范围的时候</em>，进入下一轮原型的迭代开发</li></ol><p>根据使用原型的目的不同，原型可以分为：</p><ul><li><u>探索型原型</u>：目的是要弄清目标的要求，确定所希望的特性，并探讨多种方案的可行性。</li><li><u>实验型原型</u>：目的是验证方案或算法的合理性，是在大规模开发和实现前，用于考查方案是否合适、规格说明是否可靠等。</li><li><u>演化型原型</u>：目的是将原型作为目标系统的一部分，通过对原型的多次改进，逐步将原型演化成最终的目标系统。</li></ul><h4 id="_3-2-螺旋模型-spiral-model" tabindex="-1"><a class="header-anchor" href="#_3-2-螺旋模型-spiral-model" aria-hidden="true">#</a> 3.2 螺旋模型 Spiral Model</h4><p>对于复杂的大型软件，开发一个原型往往达不到要求。</p><p>螺旋模型将瀑布模型和演化模型结合起来，加入了两种模型均忽略的<strong>风险分析</strong>（以风险为驱动），弥补了这两种模型的不足。</p><p>螺旋模型将开发过程分为几个螺旋周期，每个螺旋周期大致和瀑布模型相符合：</p><figure><img src="'+b+'" alt="螺旋模型" tabindex="0" loading="lazy"><figcaption>螺旋模型</figcaption></figure><p>螺旋模型属于面向对象开发模型。</p><p>螺旋模型适用于：</p><ul><li><em>庞大、复杂并且具有高风险的系统</em>；</li><li>新近开发，需求不明的情况。</li></ul><p>优点：</p><ul><li>支持用户需求的动态变化</li><li>螺旋模型强调风险分析，使得开发人员和用户对每个演化层出现的风险有所了解，从而做出应有的反应。</li><li>螺旋模型支持用户需求的动态变化，有助于提高软件的适应能力，降低了软件开发的风险。</li></ul><p>缺点：</p><ul><li>需要开发人员具有相当丰富的风险评估经验和专门知识。</li><li>过多的迭代次数会增加开发成本，延迟提交时间。</li></ul><h3 id="_4-喷泉模型-water-fountain-model" tabindex="-1"><a class="header-anchor" href="#_4-喷泉模型-water-fountain-model" aria-hidden="true">#</a> 4 喷泉模型 Water Fountain Model</h3><p>喷泉模型<strong>克服了</strong>瀑布模型<s>不支持软件重用</s>和<s>多项开发活动集成</s>的局限性</p><ul><li><em>以用户需求为动力</em></li><li><em>以对象作为驱动</em></li><li>适合于面向对象</li></ul><figure><img src="'+x+'" alt="喷泉模型" width="200" tabindex="0" loading="lazy"><figcaption>喷泉模型</figcaption></figure><p>喷泉模型使开发过程具有以下性质或特点：</p><ul><li><strong>迭代性</strong>：意味着模型中的开发活动常常需要重复多次，在迭代过程中不断地完善软件系统。</li><li><strong>无间隙性</strong>：指在开发活动（如分析、设计、编码）之间不存在明显的边界。 <blockquote><ul><li>喷泉不像瀑布模型那样，在需求分析活动结束后才开始设计活动，在设计活动结束后才开始编码活动，而是<em>允许各开发活动交叉、迭代地进行</em>。</li><li>喷泉模型的各个阶段<em>没有明显的界线</em>，开发人员可以同步进行。</li></ul></blockquote></li><li>支持软件重用。</li></ul><p>优点：可以提高软件项目的开发效率，节省开发时间。</p><p>缺点：</p><ul><li>由于喷泉模型在各个开发阶段是重叠的，在开发过程中<s>需要大量的开发人员</s>，不利于项目的管理。</li><li>喷泉模型<s>要求严格管理文档</s>，使得审核的难度加大。</li></ul><h3 id="_5-统一过程-up-模型" tabindex="-1"><a class="header-anchor" href="#_5-统一过程-up-模型" aria-hidden="true">#</a> 5 统一过程（UP）模型*</h3><blockquote><p>2014 年后没考过</p></blockquote><p><em>用例和风险驱动，以架构为中心，迭代并且增量</em></p><table><thead><tr><th style="text-align:center;">阶段</th><th style="text-align:center;"><em>里程碑</em></th><th style="text-align:center;"><strong>关注</strong></th><th style="text-align:center;">产生</th></tr></thead><tbody><tr><td style="text-align:center;">起始阶段</td><td style="text-align:center;">生命周期目标</td><td style="text-align:center;">项目的初创活动</td><td style="text-align:center;">构想文档、业务用例、项目计划、风险评估</td></tr><tr><td style="text-align:center;">精化阶段</td><td style="text-align:center;">生命周期架构</td><td style="text-align:center;">需求分析和架构演进</td><td style="text-align:center;">补充需求分析、软件架构描述、架构原型制品</td></tr><tr><td style="text-align:center;">构建阶段</td><td style="text-align:center;">初始运作功能</td><td style="text-align:center;">系统的构建</td><td style="text-align:center;">具有最初运作能力的软件产品</td></tr><tr><td style="text-align:center;">移交阶段</td><td style="text-align:center;">产品发布</td><td style="text-align:center;">软件提交方面的工作</td><td style="text-align:center;">产品发布版本</td></tr></tbody></table><p>典型代表：RUP（Rational Unified Process），是 UP 的商业扩展，更完整、更详细</p><h3 id="🌸-6-敏捷方法-agile-development" tabindex="-1"><a class="header-anchor" href="#🌸-6-敏捷方法-agile-development" aria-hidden="true">#</a> 🌸 6 敏捷方法 Agile Development</h3><p>敏捷开发的总体目标是通过“<em>尽可能早地、持续地对有价值的软件的交付</em>”使客户满意。</p><p>敏捷方法是一种反应灵活、拥有高度互动性和以人为本的软件开发方法。它的核心是通过不断地交付成果和及时反馈，来满足客户需求和不断变化的业务环境。</p><h4 id="_6-1-极限编程-xp" tabindex="-1"><a class="header-anchor" href="#_6-1-极限编程-xp" aria-hidden="true">#</a> 6.1 极限编程（XP）</h4><blockquote><p>极限编程（XP）是一种轻量级（敏捷）、高效、低风险、柔性、可预测的、科学的软件开发方式。</p></blockquote><p>极限编程是为了<em>降低需求变更所带来的成本</em>，旨在提高软件质量和对客户需求变化的适应性，期望能够让软件开发达到低成本、低缺陷、高产出、高回报（最小投入得到最大结果）的效果。</p><p>XP 由价值观、原则、实践和行为 4 个部分组成，他们之间彼此相互依赖、关联，并通过行为贯穿于整个生存周期：</p><ul><li><strong>4 大价值观</strong>： <ul><li>沟通、简单性、反馈、勇气</li></ul></li><li>5 个原则： <ul><li>快速反馈、简单性假设、逐步修改、提倡更改、优质工作</li></ul></li><li><strong>12 个最佳实践</strong>： <ul><li><u>计划游戏</u>：快速制定计划、随着细节的不断变化而完善</li><li><u>小型发布</u>：系统的设计要能够尽可能早地交付</li><li><u>隐喻</u>：找到合适的比喻传达信息</li><li><u>简单设计</u>：只处理当前的需求，使设计保持简单</li><li><u>测试先行</u>：先写测试代码，然后再编写程序</li><li><u>重构</u>：重新审视需求和设计，重新明确地描述它们以符合新的和现有的需求</li><li><u>结对编程</u>：非正式的代码审查，以获得质量更高的代码</li><li><u>集体代码所有制</u>：任何开发人员都可以对系统的任何部分进行改进</li><li><u>持续集成</u>：可以按日甚至按小时为客户提供可运行的版本</li><li><u>每周工作 40 个小时</u></li><li><u>现场客户</u>：系统最终用户代表应该全程配合 XP 团队</li><li><u>编码标准</u></li></ul></li></ul><h4 id="_6-2-水晶法-crystal" tabindex="-1"><a class="header-anchor" href="#_6-2-水晶法-crystal" aria-hidden="true">#</a> 6.2 水晶法（Crystal）*</h4><ul><li><em>认为每一个不同的项目都需要一套不同的策略、约定和方法论。</em></li><li>认为人对软件质量有重要的影响。</li><li>通过更好地交流和经常性的交付，软件生产力得到提高。</li></ul><h4 id="_6-3-并列争求法-scrum" tabindex="-1"><a class="header-anchor" href="#_6-3-并列争求法-scrum" aria-hidden="true">#</a> 6.3 并列争求法（Scrum）*</h4><p>使用迭代的方法。</p><ul><li><em>把每 30 天一次的迭代称为一个 “冲刺”。</em></li><li>按需求的优先级别来实现产品。</li><li>多个自组织和自治的小组并行地递增实现产品。</li><li>协调是通过简短的日常情况会议来进行，就像橄榄球中的 “并列争球”。</li></ul><h4 id="_6-4-自适应软件开发-asd" tabindex="-1"><a class="header-anchor" href="#_6-4-自适应软件开发-asd" aria-hidden="true">#</a> 6.4 自适应软件开发（ASD）*</h4><blockquote><p>没考过</p></blockquote><p>有 6 个基本原则：</p><ul><li>有一个使命作为指导；</li><li><em>特征被视为客户价值的关键点</em>；</li><li>过程中的等待是很重要的，因此 “重做” 与 “做” 同样关键；</li><li><em>变化不被视为改正，而是被视为对软件开发实际情况的调整</em>；</li><li>确定的交付时间迫使开发人员认真考虑每一个生产的版本的关键需求；</li><li>风险也包含其中。</li></ul><h4 id="_6-5-敏捷统一过程-aup" tabindex="-1"><a class="header-anchor" href="#_6-5-敏捷统一过程-aup" aria-hidden="true">#</a> 6.5 敏捷统一过程（AUP）</h4><p>敏捷统一过程采用以下原理来构建软件系统：</p><ul><li>“<strong>在大型上连续</strong>”</li><li>“<strong>在小型上迭代</strong>”</li></ul><p><em>采用经典的 UP 阶段性活动（初始、精化、构建和转换）</em>，提供了一系列活动，能够使团队为软件项目构想出一个全面的过程流。</p><p>每个 AUP 迭代执行以下活动（了解）：</p><ul><li><u>建模</u>：建立对商业和问题域的模型表述，这些模型 “足够好” 即可，以便团队继续前进。</li><li><u>实现</u>：将模型翻译成源代码。</li><li><u>测试</u>：像 XP 一样，团队设计和执行一系列的测试来发现错误以保证源代码满足需求。</li><li><u>部署</u>：对软件增量的交付以及获取最终用户的反馈。</li><li><u>配置及项目管理</u>：着眼于变更管理、风险管理以及对团队的任一制品的控制。项目管理追踪和控制开发团队的工作进展并协调团队活动。</li><li><u>环境管理</u>：协调标准、工具以及适用于开发团队的支持技术等过程基础设施。</li></ul><h2 id="🍀-需求分析" tabindex="-1"><a class="header-anchor" href="#🍀-需求分析" aria-hidden="true">#</a> 🍀 需求分析</h2><h3 id="软件需求" tabindex="-1"><a class="header-anchor" href="#软件需求" aria-hidden="true">#</a> 软件需求</h3><p>软件需求是指用户对目标软件系统在功能、行为、性能、设计约束等方面的期望。通常，这些需求包括：</p><blockquote><p>只考过 1、2、7</p></blockquote><ol><li><p><u><strong>功能需求</strong></u>：考虑系统要做什么，在何时做，在何时以及如何修改或升级。</p></li><li><p><u><strong>性能需求</strong></u>：考虑软件开发的技术性指标。</p><ul><li>存储容量限制；</li><li>执行速度；</li><li>响应时间；</li><li>吞吐量。</li></ul></li><li><p><u>用户或人的因素</u>：考虑用户的类型。</p><ul><li>各种用户对使用计算机的熟练程度，需要接受的训练；</li><li>用户理解、使用系统的难度；</li><li>用户错误操作系统的可能性。</li></ul></li><li><p><u>环境需求</u>：考虑未来软件应用的环境，包括硬件和软件。</p><ul><li>对硬件设备的需求包括：机型、外设、接口、地点、分布、湿度、磁场干扰等；</li><li>对软件的需求包括：操作系统、网络、数据库等。</li></ul></li><li><p><u>界面需求</u>：</p><ul><li>来自其他系统的输入；</li><li>到其他系统的输出；</li><li>对数据格式的特殊规定；</li><li>对数据存储介质的规定。</li></ul></li><li><p><u>文档需求</u>：考虑需要哪些文档，文档针对哪些读者。</p></li><li><p><u><strong>数据需求</strong></u>：</p><ul><li>输入、输出数据的格式；</li><li>接收、发送数据的频率；</li><li>数据的准确性和精度；</li><li>数据流量；</li><li>数据需保持的时间。</li></ul></li><li><p><u>资源使用需求</u>：</p><ul><li>软件运行时所需要的数据、其他软件、内存空间等资源；</li><li>软件开发、维护时，所需的人力、支撑软件、开发设备。</li></ul></li><li><p><u>安全保密要求</u>：</p><ul><li>是否需要对访问系统或系统信息加以控制；</li><li>隔离用户数据的方法；</li><li>用户程序如何与其他程序和操作系统隔离</li><li>系统备份要求。</li></ul></li><li><p><u>可靠性要求</u>：</p><ul><li>系统的可靠性要求；</li><li>系统是否必须检测和隔离错误；</li><li>出错后，重启系统允许的时间。</li></ul></li><li><p><u>软件成本消耗与开发进度需求</u>：</p><ul><li>开发是否有规定的时间表；</li><li>软/硬件投资有无限制。</li></ul></li><li><p><u>其他非功能性要求</u>：如采用某种开发模式，需要确定：</p><ul><li>质量控制标准；</li><li>里程碑和评审；</li><li>验收标准；</li><li>各种质量要求的优先级；</li><li>可维护性方面的要求。</li></ul></li></ol><blockquote><p>软件需求的出处：</p><ul><li>可以来自于用户（实际的和潜在的）、用户的规约、应用领域的专家、相关的技术标准和法规；</li><li>可以来自于原有的系统、原有系统的用户、新系统的潜在用户；</li><li>可以来自于竞争对手的产品</li></ul></blockquote><h2 id="🍀-系统设计" tabindex="-1"><a class="header-anchor" href="#🍀-系统设计" aria-hidden="true">#</a> 🍀 系统设计</h2><h3 id="概要设计" tabindex="-1"><a class="header-anchor" href="#概要设计" aria-hidden="true">#</a> 概要设计</h3><ol><li><strong>设计软件系统总体结构</strong><ul><li><em>确定每个模块的功能</em></li><li><em>确定模块之间的调用关系</em></li><li><em>确定模块之间的接口</em></li></ul></li><li>数据结构及数据库设计*</li><li>编写概要设计文档</li><li>评审*</li></ol><h3 id="详细设计" tabindex="-1"><a class="header-anchor" href="#详细设计" aria-hidden="true">#</a> 详细设计</h3><ol><li><em>对每个模块进行详细的<strong>算法</strong>设计</em></li><li>对模块内的数据结构进行设计</li><li>对数据库进行物理设计</li><li>其他设计 <ol><li>代码设计*</li><li>输入输出格式设计*</li><li>用户界面设计*</li></ol></li><li>编写详细设计说明书</li><li>评审</li></ol><blockquote><p>系统设计的结果是一系列系统设计文件，这些文件是物理实现一个信息系统（包括硬件设备和编制软件程序）的重要基础</p></blockquote><h2 id="🍀-系统测试" tabindex="-1"><a class="header-anchor" href="#🍀-系统测试" aria-hidden="true">#</a> 🍀 系统测试</h2><ul><li><strong>意义</strong>：系统测试是为了<strong>发现错误</strong>而执行程序的过程，成功的测试是发现了至今尚未发现的错误的测试。</li><li><strong>目的</strong>：测试的目的就是<em>希望能以最少的人力和时间发现潜在的各种错误和缺陷</em>。</li></ul><h3 id="系统测试原则" tabindex="-1"><a class="header-anchor" href="#系统测试原则" aria-hidden="true">#</a> 系统测试原则</h3><blockquote><p>考过：1、3、4、5、8、9</p></blockquote><ol><li>应<strong>尽早</strong>并不断地进行测试。</li><li>测试工作应该避免由原开发软件的人或小组承担。（<em>测试人员</em>）</li><li>在设计测试方案时，不仅要确定<em>输入数据</em>，而且要根据系统功能确定<em>预期输出结果</em>。</li><li>在设计测试用例时，不仅要设计有效、合理的输入条件，也要<em>包含不合理、失效的输入条件</em>。</li><li>在测试程序时，不仅要检验程序是否做了该做的事，还要<em>校验程序是否做了不该做的事</em>。</li><li><strong>严格按照测试计划</strong>来进行，避免测试的随意性。</li><li>妥善保存测试计划、测试用例。</li><li>测试用例都是精心设计出来的。</li><li>系统测试阶段的<em>测试目标来自于需求分析阶段</em>。</li></ol><h3 id="传统软件的测试策略" tabindex="-1"><a class="header-anchor" href="#传统软件的测试策略" aria-hidden="true">#</a> 传统软件的测试策略</h3><p>软件测试：单元测试、集成测试、确认测试、系统测试。</p><h4 id="_1-单元测试-模块测试" tabindex="-1"><a class="header-anchor" href="#_1-单元测试-模块测试" aria-hidden="true">#</a> 1 单元测试（模块测试）</h4><blockquote><p>测试内容：</p></blockquote><ol><li><strong>模块接口</strong><ul><li><em>测试模块的输入参数和形式参数在个数、属性、单位上是否一致</em>。</li><li>调用其他模块时，所给出的实际参数和被调用模块的形式参数在个数、属性、单位上是否一致。</li><li>调用标准函数时，所用的参数在属性、数目和顺序上是否正确。</li><li><em>全局变量</em>在各模块中的定义和用法是否一致。</li><li>输入是否仅改变了<em>形式参数</em>。</li><li>开/关的语句是否正确。</li><li>规定的 <em>I/O 格式</em>是否与输入/输出语句一致。</li><li>在使用文件之前是否已经打开文件或使用文件之后是否已经关闭文件。</li></ul></li><li>局部数据结构</li><li>重要的执行路径</li><li>出错处理</li><li>边界条件</li></ol><blockquote><p>测试过程：</p></blockquote><figure><img src="'+f+'" alt="单元测试" width="300" tabindex="0" loading="lazy"><figcaption>单元测试</figcaption></figure><ul><li><strong>驱动模块</strong>：接收测试例子的数据，将这些数据送到测试模块，输出结果。即模拟被测试模块的上一级模块，相当于被测模块的主程序。</li><li><strong>桩模块</strong>：代替测试模块中所调用的子模块，其<em>内部可进行少量的数据处理</em>。目的是为了检验入口、输出调用和返回的信息。</li><li>提高模块的内聚度可以简化单元测试。</li></ul><h4 id="_2-集成测试" tabindex="-1"><a class="header-anchor" href="#_2-集成测试" aria-hidden="true">#</a> 2 集成测试</h4><p>集成测试是进行一些旨在发现与接口相关的错误的测试，其目标是利用已通过单元测试的构件建立设计中描述的程序结构。</p><ol><li>自顶向下集成测试：是一种构造软件体系结构的增量方法。 <blockquote><p>自顶向下集成<s>不需要驱动模块</s>，<em>需要桩模块</em>。</p></blockquote></li><li>自底向上集成测试：就是从原子模块（程序结构的最底层构件）开始进行构造和测试。 <blockquote><p>自底向上集成<em>需要驱动模块</em>，<s>不需要桩模块</s>。</p></blockquote></li><li><strong>回归测试</strong>：重新执行己测试过的某些子集，以确保变更没有传播不期望的副作用。</li><li>冒烟测试*：一种常用的集成测试方法，<em>是时间关键项目的决定性机制</em>，它让软件团队频繁地对项目进行评估。</li></ol><h3 id="测试方法" tabindex="-1"><a class="header-anchor" href="#测试方法" aria-hidden="true">#</a> 测试方法</h3><p>静态测试*：指被测试程序不在机器上运行，而是采用以下手段对程序进行检测</p><ul><li>人工检测：不依靠计算机而是依靠人工审查程序或评审软件。人工检测包括：</li><li>代码检查</li><li>静态结构分析</li><li>代码质量度量</li><li>计算机辅助静态分析</li></ul><p><strong>动态测试</strong>：指通过运行程序发现错误。在对软件产品进行动态测试时可以采用以下两种测试方法：</p><ol><li><strong>黑盒测试法</strong></li><li><strong>白盒测试法</strong></li></ol><p>测试用例由以下组成：</p><ul><li>测试输入数据</li><li>预期输出结果：与测试输入数据对应的预期输出结果</li></ul><p>在设计测试用例时，应当包括：</p><ul><li>合理的输入条件</li><li>不合理的输入条件</li></ul><h4 id="黑盒测试-功能测试" tabindex="-1"><a class="header-anchor" href="#黑盒测试-功能测试" aria-hidden="true">#</a> 黑盒测试（功能测试）</h4><p>黑盒测试在<s>完全不考虑软件的内部结构和特性</s>的情况下，测试软件的外部特性。常用的黑盒测试技术有：</p><ol><li><strong>等价类划分</strong>：将程序的<em>输入域</em>划分为若干等价类，然后从每个等价类中选取一个代表性数据作为测试用例。<u>当测试用例全是无效等价类时则不是一个好的测试用例</u>。分类为： <ul><li>有效等价类</li><li>无效等价类（不符合条件的输入值集合）</li></ul></li><li><em>边界值分析</em>：输入的边界比中间更加容易发生错误，因此用边界值分析来补充等价类划分的测试用例设计技术。</li><li>错误推测</li><li>因果图</li></ol><h4 id="🌸-mccabe-度量法" tabindex="-1"><a class="header-anchor" href="#🌸-mccabe-度量法" aria-hidden="true">#</a> 🌸 McCabe 度量法</h4><blockquote><p>题型：计算环路复杂度</p></blockquote><figure><img src="'+k+'" alt="" width="300" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',123),z=l("p",{class:"katex-block"},[l("span",{class:"katex-display"},[l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[l("semantics",null,[l("mrow",null,[l("mi",null,"V"),l("mo",{stretchy:"false"},"("),l("mi",null,"G"),l("mo",{stretchy:"false"},")"),l("mo",null,"="),l("mi",null,"m"),l("mo",null,"−"),l("mi",null,"n"),l("mo",null,"+"),l("mn",null,"2"),l("mo",null,"="),l("mn",null,"8"),l("mo",null,"−"),l("mn",null,"7"),l("mo",null,"+"),l("mn",null,"2"),l("mo",null,"="),l("mn",null,"3")]),l("annotation",{encoding:"application/x-tex"}," V(G) = m - n + 2 = 8 - 7 + 2 = 3 ")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),l("span",{class:"mord mathnormal",style:{"margin-right":"0.22222em"}},"V"),l("span",{class:"mopen"},"("),l("span",{class:"mord mathnormal"},"G"),l("span",{class:"mclose"},")"),l("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),l("span",{class:"mrel"},"="),l("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.6667em","vertical-align":"-0.0833em"}}),l("span",{class:"mord mathnormal"},"m"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),l("span",{class:"mbin"},"−"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.6667em","vertical-align":"-0.0833em"}}),l("span",{class:"mord mathnormal"},"n"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),l("span",{class:"mbin"},"+"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.6444em"}}),l("span",{class:"mord"},"2"),l("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),l("span",{class:"mrel"},"="),l("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),l("span",{class:"mord"},"8"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),l("span",{class:"mbin"},"−"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),l("span",{class:"mord"},"7"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),l("span",{class:"mbin"},"+"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.6444em"}}),l("span",{class:"mord"},"2"),l("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),l("span",{class:"mrel"},"="),l("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.6444em"}}),l("span",{class:"mord"},"3")])])])])],-1),P=e('<p>V(G) 是环路个数（→），m 是 G 中的有向弧数，n 是 G 中的节点数</p><h4 id="🌸-白盒测试-结构测试" tabindex="-1"><a class="header-anchor" href="#🌸-白盒测试-结构测试" aria-hidden="true">#</a> 🌸 白盒测试（结构测试）</h4><p>白盒测试根据程序的内部结构和逻辑来设计测试用例，对程序的路径和过程进行测试，检查是否满足设计的需要。 白盒测试包括：逻辑覆盖、循环覆盖*、基本路径测试*</p><h5 id="❗️逻辑覆盖" tabindex="-1"><a class="header-anchor" href="#❗️逻辑覆盖" aria-hidden="true">#</a> ❗️逻辑覆盖</h5><p>考察用测试数据运行被测程序时，<em>对程序逻辑的覆盖程度</em>。主要的逻辑覆盖标准有 6 种，它们的覆盖程度从低到高为：</p><ol><li><p><u>语句覆盖</u>：指<em>选择足够的测试数据</em>，使被测试程序中的<em>每条语句至少执行一次</em>。</p><blockquote><p>语句覆盖对程序执行逻辑的覆盖很低，因此一般认为它是很弱的逻辑覆盖。</p></blockquote></li><li><p><u>判定覆盖（<em>分支覆盖</em>）</u>：指设计足够的测试用例，使得被测程序中的<em>每个<strong>判定表达式</strong>至少获得一次 “真”/“假” 值</em>。</p><blockquote><p>判定覆盖的判定表达式是指判定表达式整体。判定覆盖要比语句覆盖更强一些。</p></blockquote></li><li><p><u>条件覆盖</u>：指构造一组测试用例，使得每一判定语句中<em>每个<strong>逻辑条件</strong>的各种可能的值至少满足一次</em>。</p><blockquote><p>条件覆盖的判定语句是指判定表达式下的判定语句（如果有），即用 <code>AND</code>、<code>OR</code> 等逻辑运算符连接起来的语句（不包含逻辑运算符的语句）。</p></blockquote></li><li><p><u>判定/条件覆盖</u>：指设计足够的测试用例，使得判定中每个条件的所有可能取值（真/假）至少出现一次，并使每个判定本身的判定结果（真/假）也至少出现一次。结果取判定覆盖和条件覆盖的<em>并集</em>。</p><blockquote><p>判定/条件覆盖同时满足：</p><ul><li>判定覆盖</li><li>条件覆盖</li></ul></blockquote></li><li><p><u>条件组合覆盖</u>：指设计足够的测试用例，使得每个<em>判定中条件的<strong>各种可能值的组合</strong>都至少出现一次</em>。</p><blockquote><p>满足条件组合覆盖的测试用例一定满足：</p><ul><li>判定覆盖</li><li>条件覆盖</li><li>判定/条件覆盖</li></ul></blockquote></li><li><p><u>路径覆盖</u>：指覆盖被测试程序中<strong>所有可能的路径</strong>。</p></li></ol><hr><blockquote><p>总结（<strong>覆盖程度从低到高</strong>）：</p></blockquote><table><thead><tr><th style="text-align:center;">逻辑覆盖</th><th style="text-align:center;">说明</th><th style="text-align:center;">至少需设计❓个测试用例（<s>个人理解</s>）</th></tr></thead><tbody><tr><td style="text-align:center;">语句覆盖</td><td style="text-align:center;">每条语句执行一次</td><td style="text-align:center;">一般 1 个测试用例就可以覆盖</td></tr><tr><td style="text-align:center;">判定（分支）覆盖</td><td style="text-align:center;">每个分支获得一次 True/False</td><td style="text-align:center;">看覆盖 Y...Y,N...N 需要几个</td></tr><tr><td style="text-align:center;">条件覆盖</td><td style="text-align:center;">每个分支中的每个逻辑条件的所有可能取值满足一次</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">判定/条件覆盖</td><td style="text-align:center;">判定覆盖 + 条件覆盖</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">条件组合覆盖</td><td style="text-align:center;">每个判定中条件的各种可能值的组合都出现一次</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">路径覆盖</td><td style="text-align:center;">覆盖被测试程序中所有可能的路径</td><td style="text-align:center;">数指向结束/return的路径</td></tr></tbody></table><h5 id="伪代码-白盒测试-mccabe" tabindex="-1"><a class="header-anchor" href="#伪代码-白盒测试-mccabe" aria-hidden="true">#</a> 伪代码 + 白盒测试 + McCabe</h5>',10),R=l("div",{class:"language-java line-numbers-mode","data-ext":"java"},[l("pre",{class:"language-java"},[l("code",null,[l("span",{class:"token keyword"},"for"),l("span",{class:"token punctuation"},"("),l("span",{class:"token keyword"},"int"),a(" i "),l("span",{class:"token operator"},"="),a(),l("span",{class:"token number"},"0"),l("span",{class:"token punctuation"},";"),a(" i "),l("span",{class:"token operator"},"<="),a(),l("span",{class:"token number"},"10"),l("span",{class:"token punctuation"},";"),a(" i"),l("span",{class:"token operator"},"++"),l("span",{class:"token punctuation"},")"),l("span",{class:"token punctuation"},"{"),a(`
    `),l("span",{class:"token class-name"},"System"),l("span",{class:"token punctuation"},"."),a("out"),l("span",{class:"token punctuation"},"."),l("span",{class:"token function"},"println"),l("span",{class:"token punctuation"},"("),a("i"),l("span",{class:"token punctuation"},")"),l("span",{class:"token punctuation"},";"),a(`
`),l("span",{class:"token punctuation"},"}"),a(`
`)])]),l("div",{class:"line-numbers","aria-hidden":"true"},[l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"})])],-1),E=l("div",{class:"language-java line-numbers-mode","data-ext":"java"},[l("pre",{class:"language-java"},[l("code",null,[l("span",{class:"token keyword"},"int"),a(" i "),l("span",{class:"token operator"},"="),a(),l("span",{class:"token number"},"0"),l("span",{class:"token punctuation"},";"),a(`
`),l("span",{class:"token keyword"},"while"),l("span",{class:"token punctuation"},"("),a("i "),l("span",{class:"token operator"},"<="),a(),l("span",{class:"token number"},"10"),l("span",{class:"token punctuation"},")"),l("span",{class:"token punctuation"},"{"),a(`
    `),l("span",{class:"token class-name"},"System"),l("span",{class:"token punctuation"},"."),a("out"),l("span",{class:"token punctuation"},"."),l("span",{class:"token function"},"println"),l("span",{class:"token punctuation"},"("),a("i"),l("span",{class:"token punctuation"},")"),l("span",{class:"token punctuation"},";"),a(`
    i`),l("span",{class:"token operator"},"++"),l("span",{class:"token punctuation"},";"),a(`
`),l("span",{class:"token punctuation"},"}"),a(`
`)])]),l("div",{class:"line-numbers","aria-hidden":"true"},[l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"})])],-1),I=l("div",{class:"language-java line-numbers-mode","data-ext":"java"},[l("pre",{class:"language-java"},[l("code",null,[l("span",{class:"token keyword"},"int"),a(" i "),l("span",{class:"token operator"},"="),a(),l("span",{class:"token number"},"0"),l("span",{class:"token punctuation"},";"),a(`
`),l("span",{class:"token keyword"},"do"),l("span",{class:"token punctuation"},"{"),a(`
    `),l("span",{class:"token class-name"},"System"),l("span",{class:"token punctuation"},"."),a("out"),l("span",{class:"token punctuation"},"."),l("span",{class:"token function"},"println"),l("span",{class:"token punctuation"},"("),a("i"),l("span",{class:"token punctuation"},")"),l("span",{class:"token punctuation"},";"),a(`
    i`),l("span",{class:"token operator"},"++"),l("span",{class:"token punctuation"},";"),a(`
`),l("span",{class:"token punctuation"},"}"),l("span",{class:"token keyword"},"while"),l("span",{class:"token punctuation"},"("),a("i "),l("span",{class:"token operator"},"<="),a(),l("span",{class:"token number"},"10"),l("span",{class:"token punctuation"},")"),l("span",{class:"token punctuation"},";"),a(`
`)])]),l("div",{class:"line-numbers","aria-hidden":"true"},[l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"}),l("div",{class:"line-number"})])],-1),D=e('<figure><img src="'+y+'" alt="循环流程图" tabindex="0" loading="lazy"><figcaption>循环流程图</figcaption></figure><h2 id="🍀-运行和维护" tabindex="-1"><a class="header-anchor" href="#🍀-运行和维护" aria-hidden="true">#</a> 🍀 运行和维护</h2><h3 id="系统可维护性概念" tabindex="-1"><a class="header-anchor" href="#系统可维护性概念" aria-hidden="true">#</a> 系统可维护性概念</h3><p>系统是否能被很好地维护，可以用系统的可维护性这一指标来衡量。</p><p><em>系统可维护性的评价指标</em>：</p><ul><li>可理解性</li><li>可测试性</li><li>可修改性</li></ul><blockquote><p>模块的耦合、内聚、作用范围与控制范围的关系等都对可修改性有影响</p></blockquote><h4 id="软件文档与软件维护" tabindex="-1"><a class="header-anchor" href="#软件文档与软件维护" aria-hidden="true">#</a> 软件文档与软件维护</h4><p><strong>软件文档</strong>是软件可维护性的<strong>决定因素</strong>。文档是软件产品的一部分，并且编写高质量的文档可以提高软件开发的质量。</p><p>软件系统的文档分为：</p><ul><li><u>用户文档</u>：主要描述系统功能和使用方法，并不关心这些功能是怎样实现的</li><li><u>系统文档</u>：描述系统设计、实现和测试等各方面的内容。</li></ul><p><em>可维护性</em>是所有软件都应具有的<em>基本特点</em>，必须在<strong>开发阶段</strong>保证软件具有可维护的特点。在软件工程的每一个阶段都应考虑并提高软件的可维护性，在每个阶段结束前的技术审查和管理复查中应该着重对可维护性进行复审（如将来要改进的部分和可能会修改的部分）。</p><div class="hint-container tip"><p class="hint-container-title">做题技巧</p><p><strong>软件文档很重要！！！</strong></p><ul><li>维护应该针对<em>整个软件配置</em>，不应该只修改源程序代码。</li><li>编写高质量文档可以提高软件开发的质量。</li><li>文档也是软件产品的一部分，没有文档的软件就不能称之为软件。</li><li>软件文档的编制在软件开发工作中占有突出的地位和相当大的工作量高质量文档对于软件产品的效益有着重要的意义。</li><li>总的来说，<s>软件文档只好不坏，选项中说软件文档不好的就是不正确的</s>。</li></ul></div><h3 id="系统维护的内容及类型" tabindex="-1"><a class="header-anchor" href="#系统维护的内容及类型" aria-hidden="true">#</a> 系统维护的内容及类型</h3><p>软件维护：</p><ol><li><u>正确性维护</u>。指<strong>改正</strong>在系统开发阶段已发生而系统测试阶段尚未发现的错误。<code>17%~21%</code></li><li><u>适应性维护</u>。使应用软件<em>适应信息技术变化和管理需求变化</em>而进行的修改。<code>18%~25%</code></li><li><u>完善性维护</u>。为<strong>扩充功能</strong>和<strong>改善性能</strong>而进行的修改。<code>50%~60%</code></li><li><u>预防性维护</u>。为了改进应用软件的可靠性和可维护性，为了适应未来的软/硬件环境的变化，应<em>主动增加预防性的新的功能</em>，以使应用系统适应各类变化而不被淘汰。<code>4%</code></li></ol><h3 id="软件可靠性、可用性、可维护性" tabindex="-1"><a class="header-anchor" href="#软件可靠性、可用性、可维护性" aria-hidden="true">#</a> 软件可靠性、可用性、可维护性</h3>',17),V=l("ul",null,[l("li",null,[a("可靠性、可用性和可维护性是软件的"),l("strong",null,"质量属性"),a("，软件工程中，用 0-1 之间的数来度量。")]),l("li",null,[l("u",null,"可靠性"),a(" 是指一个系统对于给定的时间间隔内、在给定条件下无失效运作的概率。可以用 "),l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"M"),l("mi",null,"T"),l("mi",null,"T"),l("mi",null,"F"),l("mi",{mathvariant:"normal"},"/"),l("mo",{stretchy:"false"},"("),l("mn",null,"1"),l("mo",null,"+"),l("mi",null,"M"),l("mi",null,"T"),l("mi",null,"T"),l("mi",null,"F"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"MTTF/(1+MTTF)")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),l("span",{class:"mord mathnormal",style:{"margin-right":"0.13889em"}},"MTTF"),l("span",{class:"mord"},"/"),l("span",{class:"mopen"},"("),l("span",{class:"mord"},"1"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),l("span",{class:"mbin"},"+"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),l("span",{class:"mord mathnormal",style:{"margin-right":"0.13889em"}},"MTTF"),l("span",{class:"mclose"},")")])])]),a(" 来度量，其中 MTTF 为"),l("strong",null,"平均无故障时间"),a("。")]),l("li",null,[l("u",null,"可用性"),a(" 是在给定的时间点上，一个系统能够按照规格说明正确运作的概率。可以用 "),l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"M"),l("mi",null,"T"),l("mi",null,"B"),l("mi",null,"F"),l("mi",{mathvariant:"normal"},"/"),l("mo",{stretchy:"false"},"("),l("mn",null,"1"),l("mo",null,"+"),l("mi",null,"M"),l("mi",null,"T"),l("mi",null,"B"),l("mi",null,"F"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"MTBF/(1+MTBF)")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),l("span",{class:"mord mathnormal",style:{"margin-right":"0.13889em"}},"MTBF"),l("span",{class:"mord"},"/"),l("span",{class:"mopen"},"("),l("span",{class:"mord"},"1"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),l("span",{class:"mbin"},"+"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),l("span",{class:"mord mathnormal",style:{"margin-right":"0.13889em"}},"MTBF"),l("span",{class:"mclose"},")")])])]),a(" 来度量，其中 MTBF 为"),l("strong",null,"平均失效间隔时间"),a("。")]),l("li",null,[l("u",null,"可维护性"),a(" 是在给定的使用条件下，在规定的时间间隔内，使用规定的过程和资源完成维护活动的概率。可以用 "),l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mn",null,"1"),l("mi",{mathvariant:"normal"},"/"),l("mo",{stretchy:"false"},"("),l("mn",null,"1"),l("mo",null,"+"),l("mi",null,"M"),l("mi",null,"T"),l("mi",null,"T"),l("mi",null,"R"),l("mo",{stretchy:"false"},")")]),l("annotation",{encoding:"application/x-tex"},"1/(1+MTTR)")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),l("span",{class:"mord"},"1/"),l("span",{class:"mopen"},"("),l("span",{class:"mord"},"1"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),l("span",{class:"mbin"},"+"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),l("span",{class:"mord mathnormal",style:{"margin-right":"0.00773em"}},"MTTR"),l("span",{class:"mclose"},")")])])]),a(" 来度量，其中 MTTR 为"),l("strong",null,"平均修复时间"),a("。")])],-1),F=l("h2",{id:"🍀-项目管理",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#🍀-项目管理","aria-hidden":"true"},"#"),a(" 🍀 项目管理")],-1),A=l("h3",{id:"沟通路径",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#沟通路径","aria-hidden":"true"},"#"),a(" 沟通路径")],-1),B=l("p",null,"沟通图是指项目中人员或部门之间的沟通用一条无向边连接起来，所构成图即为沟通图。沟通图中的路径称为沟通路径。",-1),G=l("p",null,"软件项目中沟通路径 m 的计算公式（人数 n）：",-1),S=l("ul",null,[l("li",null,[a("沟通图中无主程序员时："),l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"m"),l("mo",null,"="),l("mo",{stretchy:"false"},"("),l("mi",null,"n"),l("mo",null,"−"),l("mn",null,"1"),l("mo",{stretchy:"false"},")"),l("mo",null,"×"),l("mi",null,"n"),l("mo",null,"÷"),l("mn",null,"2")]),l("annotation",{encoding:"application/x-tex"},"m = (n - 1) \\times n ÷ 2")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.4306em"}}),l("span",{class:"mord mathnormal"},"m"),l("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),l("span",{class:"mrel"},"="),l("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),l("span",{class:"mopen"},"("),l("span",{class:"mord mathnormal"},"n"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),l("span",{class:"mbin"},"−"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),l("span",{class:"mord"},"1"),l("span",{class:"mclose"},")"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),l("span",{class:"mbin"},"×"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.6667em","vertical-align":"-0.0833em"}}),l("span",{class:"mord mathnormal"},"n"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),l("span",{class:"mbin"},"÷"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.6444em"}}),l("span",{class:"mord"},"2")])])])]),l("li",null,[a("沟通图中有主程序员时（中介者模式）："),l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"m"),l("mo",null,"="),l("mi",null,"n"),l("mo",null,"−"),l("mn",null,"1")]),l("annotation",{encoding:"application/x-tex"},"m = n - 1")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.4306em"}}),l("span",{class:"mord mathnormal"},"m"),l("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),l("span",{class:"mrel"},"="),l("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.6667em","vertical-align":"-0.0833em"}}),l("span",{class:"mord mathnormal"},"n"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),l("span",{class:"mbin"},"−"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.6444em"}}),l("span",{class:"mord"},"1")])])])])],-1),j=e('<h3 id="cocomo-估算模型" tabindex="-1"><a class="header-anchor" href="#cocomo-估算模型" aria-hidden="true">#</a> COCOMO 估算模型</h3><p>COCOMO 模型是一种精确的、易于使用的成本估算模型。COCOMO 模型按其详细程度分为：</p><ol><li><u><em>基本</em> COCOMO 模型</u>：是一个<em>静态<strong>单</strong>变量模型</em>，用于对整个软件系统进行估算。</li><li><u><em>中级</em> COCOMO 模型</u>：是一个<em>静态<strong>多</strong>变量模型</em>，它将软件系统模型分为系统和部件两个层次，系统由部件构成，它把软件开发所需的人力（成本）看作是程序大小和一系列 “成本驱动属性” 的函数。</li><li><u><em>详细</em> COCOMO 模型</u>：将软件系统模型分为系统、子系统和模块 3 个层次，除包括中级模型所考虑的因素外，还考虑了在需求分析、软件设计等每一步的成本驱动属性的影响。</li></ol><h3 id="cocomoii-模型" tabindex="-1"><a class="header-anchor" href="#cocomoii-模型" aria-hidden="true">#</a> COCOMOII 模型</h3><p>和其前身 COCOMO 一样，COCOMOII 也是一种层次结构的估算模型，被分为 3 个阶段性模型，分别对应三种不同的规模估算选择：</p><ol><li><u>应用组装模型</u>：在软件工程的前期阶段使用，这时用户界面的原型开发、对软件和系统交互的考虑、性能的评估以及技术成熟度的评价是最重要的。 <blockquote><p>规模估算选择：<strong>对象点</strong>。</p></blockquote></li><li><u>早期设计阶段模型</u>：在需求已经稳定并且基本的软件体系结构已经建立时使用。 <blockquote><p>规模估算选择：<strong>功能点</strong>。功能点可转换为代码行。</p></blockquote></li><li><u>体系结构阶段模型</u>：在软件的构造过程中使用。 <blockquote><p>规模估算选择：<strong>代码行</strong>。</p></blockquote></li></ol><h2 id="🍀-进度管理" tabindex="-1"><a class="header-anchor" href="#🍀-进度管理" aria-hidden="true">#</a> 🍀 进度管理</h2><h3 id="gantt-甘特图" tabindex="-1"><a class="header-anchor" href="#gantt-甘特图" aria-hidden="true">#</a> Gantt 甘特图</h3><ul><li>Gantt 图优点： <ul><li>能清晰地描述每个任务的开始时间；</li><li>能清晰地描述每个任务的结束时间；</li><li>能清晰地描述任务的进展情况；</li><li>各个任务之间的并行性。</li></ul></li><li>Gantt 图缺点： <ul><li><s>不能清晰地反映各任务之间的依赖关系；</s></li><li>难以确定整个项目的关键所在，即<s>不能清晰地确定影响进度的关键任务；</s></li><li>不能反映计划中有潜力的部分。</li></ul></li></ul><h3 id="pert-图" tabindex="-1"><a class="header-anchor" href="#pert-图" aria-hidden="true">#</a> PERT 图</h3><p>PERT 图是一个有向图：</p><p>PERT 图的优点：</p><ul><li>给出了每个任务的开始时间、结束时间和完成该任务所需的时间；</li><li>给出了任务之间的关系（依赖关系）。即任务之间的执行顺序。</li></ul><blockquote><p>只有指向该节点的所有任务都结束时，结点所表示的任务才能开始。</p></blockquote><p><s>PERT 图不能清晰地描述任务之间的并行情况。</s></p><blockquote><p>关键路径：持续时间最长的路径</p></blockquote><h3 id="🌸-项目活动图-✅" tabindex="-1"><a class="header-anchor" href="#🌸-项目活动图-✅" aria-hidden="true">#</a> 🌸 项目活动图 ✅</h3><blockquote><p>题型：关键路径、关键路径的长度、问某个顶点/活动是否在关键路径上</p></blockquote><p>项目活动图是一种有向图（与 PERT 图十分类似）：</p><ul><li><p>弧：表示活动。弧的权值表示活动的持续时间。</p></li><li><p>顶点：表示项目里程碑。</p><p>特殊的里程碑：</p><ul><li>开始里程碑：没有任何活动指向该里程碑</li><li>结束里程碑：没有任何活动从该里程碑指出</li></ul></li></ul><p>项目活动图的关键路径：按照 PERT 图的方法求出松弛时间为 0 的、从开始里程碑到结束里程碑的路径。</p><p>关键路径的长度：为结束里程碑的最早时刻（或最晚时刻）。它可以用来表示项目完成的最少时间。</p><div class="hint-container tip"><p class="hint-container-title">做题技巧</p><p>路径上时间总和最大的一条路径就是关键路径，长度为时间总和</p></div><h2 id="🍀-软件配置管理" tabindex="-1"><a class="header-anchor" href="#🍀-软件配置管理" aria-hidden="true">#</a> 🍀 软件配置管理</h2><blockquote><p>背</p></blockquote><p>软件配置管理的主要目标包括：</p><ul><li>标识变更</li><li>控制变更</li><li>版本控制</li><li>确保变更正确地实现</li><li>报告有关变更</li></ul><p>主要内容有两种版本：</p><ol><li>版本管理 <ul><li>配置支持</li><li>变更支持</li><li>过程支持</li><li>团队支持</li><li>变化报告</li><li>审计支持</li></ul></li><li>软件配置标识 <ul><li>变更管理</li><li>版本控制</li><li>系统建立</li><li>配置审核</li><li>配置状态报告</li></ul></li></ol><p>配置数据库分为以下三类：</p><ul><li>开发库</li><li>受控库</li><li>产品库</li></ul><h3 id="🌸-风险管理" tabindex="-1"><a class="header-anchor" href="#🌸-风险管理" aria-hidden="true">#</a> 🌸 风险管理</h3><p>一般认为软件风险包含两个特性：</p><ul><li><u>不确定性</u>：指风险可能发生也可能不发生；</li><li><u>损失</u>：指如果风险发生，就会产生恶性后果。</li></ul><p><strong>项目风险</strong> 威胁到项目计划。项目风险是指预算、进度、人员：聘用职员及组织、资源、利益相关者、需求等方面的潜在问题以及它们对软件项目的影响。</p><blockquote><p>项目复杂度、规模及结构不确定性也属于项目风险因素</p></blockquote><p><strong>技术风险</strong> 威胁到要开发软件的质量及交付时间。技术风险是指<em>设计、实现、接口、验证、维护</em>等方面的潜在问题。</p><blockquote><p>规格说明的歧义性、技术的不确定性、技术陈旧、“前沿” 技术也是技术风险因素</p></blockquote><p><em>商业风险*</em> 威肋到要开发软件的生存能力，且常常会危害到项目或产品。</p><div class="hint-container note"><p class="hint-container-title">注</p><p>5 个主要的商业风险如下：</p><ul><li>市场风险：开发了一个没有人真正需要的优良产品或系统。</li><li>策略风险：开发的产品不再符合公司的整体商业策略。</li><li>销售风险：开发了一个销售部门不知道如何去销售的产品。</li><li>管理风险：由于重点的转移或人员的变动而失去了高级管理层的支持。</li><li>预算风险：没有得到预算或人员的保证。</li></ul></div><h3 id="风险识别" tabindex="-1"><a class="header-anchor" href="#风险识别" aria-hidden="true">#</a> 风险识别*</h3><p>风险识别试图系统化地指出对项目计划（估算、进度、资源分配等）的威胁。识别出已知风险和可预测风险后，项目管理者首先要做的是：</p><ul><li><em>在可能时回避这些风险；</em></li><li><em>在必要时控制这些风险。</em></li></ul><div class="hint-container note"><p class="hint-container-title">注</p><p>识别风险的一种方法是建立<em>风险条目检查表</em>（未考察），主要用来识别下列几种类型中的一些已知风险和可预测风险：</p><ul><li>产品规模：与要开发或要修改的软件的总体规模相关的风险。</li><li>商业影响：与管理者或市场所施加的约束相关的风险。</li><li>客户特性：与客户的素质以及开发者和客户定期沟通的能力相关的风险。</li><li>过程定义：与软件过程定义的程度以及该过程被开发组织遵守的程度相关的风险。</li><li>开发环境：与用来开发产品的工具的可得性及质量相关的风险。</li><li>开发技术：与待开发软件的复杂性及系统所包含技术的 “新奇性” 相关的风险。</li><li>人员才干及经验：与软件工程师的总体技术水平及项目经验相关的风险。</li></ul><p>与上述每个主题相关的问题可以针对每一个软件项目来回答。根据这些问题的答案，项目管理者就可以估计风险产生的影响。另一种风险条目检查表格式：仅仅列出与每一种类型有关的特性，最终给出一组风险因素和驱动因子以及它们发生的概率。</p><p>风险因素（未考察）包括：</p><ul><li>性能：性能风险是指产品能够满足需求且符合其使用目的的不确定程度。</li><li>成本：成本风险是指能够维持项目预算的不确定程度。</li><li>支持：支特风险是指开发出的软件易于纠错、修改及升级的不确定程度。</li><li>进度：进度风险是指能够维持项目进度且按时交付产品的不确定程度。</li></ul></div><h3 id="风险预测" tabindex="-1"><a class="header-anchor" href="#风险预测" aria-hidden="true">#</a> 风险预测</h3><p>风险预测又称风险估计，它试图从两个方面评估一个风险：</p><ul><li>风险发生的可能性或 <strong>概率</strong>；</li><li>发生风险所产生的 <strong>后果</strong>。</li></ul><p>通常，项目计划人员与管理人员、技术人员一起进行以下 4 步<em>风险预测活动</em>：</p><ol><li>建立一个尺度或标准，以反映风险发生的可能性。</li><li>描述风险产生的后果。</li><li>估算风险对项目和产品的影响。</li><li>标注风险预测的整体精确度，以免产生误解。</li></ol><p>一种简单的风险预测技术是<em>建立风险表</em>：</p><ul><li>第 1 列：列出所有的风险（由风险识别活动得到）；</li><li>第 2~4 列：列出每个风险的种类、发生的概率、所产生的影响 <blockquote><p>风险所产生的影响可用一个数字来表示：</p><ul><li>“1”：表示灾难性的；</li><li>“2”：表示严重的；</li><li>“3”：表示轻微的；</li><li>“4”：表示可忽略的。</li></ul></blockquote></li></ul><p>评估风险影响：发生风险时，<strong>风险的本质、范围和时间</strong>可能会影响风险所产生的后果：</p><ul><li><u>风险的本质</u>：指当风险发生时可能带来的问题。</li><li><u>风险的范围</u>： <ul><li>风险的严重性；</li><li>风险的整体分布情况：项目中有多少部分受到影响或有多少客户受到损害。</li></ul></li><li><u>风险的时间</u>： <ul><li>何时能够感受到风险的影响；</li><li>风险的影响会持续多长时间。</li></ul></li></ul><p>整体的 <strong>风险显露度</strong>（RE）：</p>',54),N=l("ul",null,[l("li",null,[l("span",{class:"katex"},[l("span",{class:"katex-mathml"},[l("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[l("semantics",null,[l("mrow",null,[l("mi",null,"R"),l("mi",null,"E"),l("mo",null,"="),l("mi",null,"P"),l("mo",null,"×"),l("mi",null,"C")]),l("annotation",{encoding:"application/x-tex"},"RE = P \\times C")])])]),l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.6833em"}}),l("span",{class:"mord mathnormal",style:{"margin-right":"0.05764em"}},"RE"),l("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),l("span",{class:"mrel"},"="),l("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.7667em","vertical-align":"-0.0833em"}}),l("span",{class:"mord mathnormal",style:{"margin-right":"0.13889em"}},"P"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),l("span",{class:"mbin"},"×"),l("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.6833em"}}),l("span",{class:"mord mathnormal",style:{"margin-right":"0.07153em"}},"C")])])])]),l("li",null,"P 是风险发生的概率，C 是风险发生时带来的项目成本")],-1),U=e('<blockquote><p>风险的优先级通常是根据风险暴露（Risk Exposure）设定</p></blockquote><h3 id="风险评估" tabindex="-1"><a class="header-anchor" href="#风险评估" aria-hidden="true">#</a> 风险评估</h3><p>一种对风险评估很有用的技术就是<em>定义风险参照水准</em>。对于大多数软件项目来说，有 3 种典型的风险参照水准</p><ul><li>成本：成本是否超支</li><li>进度：进程是否延期</li><li>性能：性能是否下降</li></ul><h3 id="风险控制" tabindex="-1"><a class="header-anchor" href="#风险控制" aria-hidden="true">#</a> 风险控制</h3><p>风险控制的目的是<em>辅助项目组建立处理风险的策略</em>。一个有效的策略必须考虑以下 3 个问题：</p><ul><li><p><u>风险避免</u>：应对风险的最好办法是<strong>主动地</strong>避免风险，即在风险发生前分析引起风险的原因，然后采取措施，以避免风险的发生。</p></li><li><p><u>风险监控</u>：项目管理者应监控某些因素，这些因素可以提供风险是否正在变高或变低的指示。</p></li><li><p><u>RMMM 计划</u>：风险管理策略可以包含在软件项目计划中，或者风险管理步骤也可以组织成一个独立的风险缓解、监控和管理计划（RMMM 计划）。RMMM 计划将所有风险分析工作文档化，并由项目管理者作为整个项目计划中的一部分来使用。建立了 RMMM 计划，而且项目已经启动之后，风险缓解及监测步骤也就开始了：</p><ul><li>风险缓解：一种问题规避活动。</li><li>风险监测：一种项目跟踪活动。</li></ul></li></ul><blockquote><p>风险监测的另一个任务就是试图找到 “起源”（在整个项目中是哪些风险引起了哪些问题）。</p></blockquote><h2 id="🍀-软件质量" tabindex="-1"><a class="header-anchor" href="#🍀-软件质量" aria-hidden="true">#</a> 🍀 软件质量</h2><h3 id="软件质量特性" tabindex="-1"><a class="header-anchor" href="#软件质量特性" aria-hidden="true">#</a> 软件质量特性</h3><p>讨论软件质量首先要了解软件的质量特性，目前已经有多种软件质量模型来描述软件质量特性，如：</p><ul><li>ISO/IEC 9126 软件质量模型</li><li>Me Call 软件质量模型。</li></ul><h3 id="🌸-iso-iec-9126" tabindex="-1"><a class="header-anchor" href="#🌸-iso-iec-9126" aria-hidden="true">#</a> 🌸 ISO/IEC 9126</h3><p>ISO/IEC 9126 软件质量模型由 3 个层次组成：</p><ol><li>第一层：<strong>质量特性</strong></li><li>第二层：<strong>质量子特性</strong></li><li>第三层：<strong>度量指标</strong></li></ol><figure><img src="'+_+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>质量子特性</strong>的含义：</p><ul><li>功能性： <ul><li><u>适合性</u>：与对规定任务能否提供一组功能以及这组功能是否<strong>适合</strong>有关的软件属性。</li><li><u>准确性</u>：与能够得到<strong>正确</strong>或相符的结果或效果有关的软件属性。</li><li><u>互用性</u>：与其他指定系统进行<strong>交互</strong>操作的能力相关的软件属性。</li><li><u>依从性</u>：使软件<strong>服从</strong>有关的标准、约定、法规及类似规定的软件属性。</li><li><u><em>安全性</em></u>：与避免对程序及数据的非授权故意或意外访问的能力有关的软件属性。</li></ul></li><li>可靠性： <ul><li><u>成熟性</u>：由软件故障引起失效的频度有关的软件属性。</li><li><u>容错性</u>：在软件错误或违反指定接口的情况下维持指定的性能水平的能力有关的软件属性。</li><li><u><em>易恢复性</em></u>：故障发生后重新建立性能水平并恢复直接受影响数据的能力，以及为达到此目的所需的时间和努力有关的软件属性。</li></ul></li><li>易使用性： <ul><li><u>易理解性</u>：与用户为理解逻辑概念及其应用所付出的劳动有关的软件属性。</li><li><u>易学性</u>：与用户为学习其应用（例如操作控制、输入、输出）所付出的努力相关的软件属性。</li><li><u>易操作性</u>：与用户为进行操作和操作控制所付出的努力有关的软件属性。</li></ul></li><li>效率： <ul><li><u>时间特性</u>：与响应和处理时间以及软件执行其功能时的吞吐量有关的软件属性。</li><li><u>资源特性</u>：与软件执行其功能时，所使用的资源量以及使用资源的持续时间有关的软件属性。</li></ul></li><li><strong>可维护性</strong>： <ul><li><u>易分析性</u>：与为诊断缺陷或失效原因，或为判定待修改的部分所需努力有关的软件属性。</li><li><u>易改变性</u>：与进行修改、排错或适应环境变换所需努力有关的软件属性。</li><li><u>稳定性</u>：与修改造成未预料效果的风险有关的软件属性。</li><li><u><em>易测试性</em></u>：为确认经修改软件所需努力有关的软件属性。<s>很难理解</s></li></ul></li><li><strong>可移植性</strong>： <ul><li><u>适应性</u>：与软件转移到不同环境时的处理或手段有关的软件属性。</li><li><u>易安装性</u>：与在指定环境下安装软件所需努力有关的软件属性。</li><li><u>一致性</u>：使软件服从与可移植性有关的标准或约定的软件属性。</li><li><u>易替换性</u>：与一软件在该软件环境中用来替代指定的其他软件的可能和努力有关的软件属性。</li></ul></li></ul><h3 id="mc-call-软件质量模型" tabindex="-1"><a class="header-anchor" href="#mc-call-软件质量模型" aria-hidden="true">#</a> Mc Call 软件质量模型</h3><figure><img src="'+v+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="🍀-软件评审" tabindex="-1"><a class="header-anchor" href="#🍀-软件评审" aria-hidden="true">#</a> 🍀 软件评审</h2><blockquote><p>2015 年后没考过</p></blockquote><p>通常，把 “质量” 理解为 “用户满意程度”。为了使得用户满意，有以下两个必要条件：</p><ul><li><p><strong>设计质量</strong>：评价软件的规格说明是否符合用户的要求，是否能避免各种异常/错误。</p><blockquote><p>设计质量的评审对象：</p><ul><li>软件需求规格说明</li><li>数据需求规格说明</li><li>软件概要设计说明</li></ul></blockquote></li><li><p><strong>程序质量</strong>：程序按照设计规格说明所规定的情况正确执行。程序质量的评审通常是从开发者的角度进行，与开发技术直接相关。</p><blockquote><p>程序质量的评审对象：</p><ol><li>软件结构：</li></ol><ul><li>功能结构*： <ul><li>数据结构</li><li>功能结构</li><li>数据结构和功能结构之间的对应关系</li></ul></li><li>功能的通用性*</li><li>模块的层次*</li><li><strong>模块结构</strong>： <ul><li><em>控制流结构</em></li><li><em>数据流结构</em></li><li><em>模块结构与功能结构之间的对应关系</em></li></ul></li><li>处理过程的结构</li></ul><ol start="2"><li>与运行环境的接口：</li></ol><ul><li>与硬件的接口</li><li>与用户的接口</li></ul></blockquote></li></ul><p>正式的技术评审是一种由技术人员实施的程式化会议，其唯一的目的是揭露质量问题。在多数情况下，评审能像测试一样有效地揭露软件中的缺陷。</p><p>软件的规格说明分为：</p><ul><li><strong>外部规格说明</strong>：从用户角度来看的规格，包括硬件 / 软件系统设计、功能设计；设计质量是由外部规格说明决定的</li><li><strong>内部规格说明</strong>：为了实现外部规格的更详细的规格，即软件模块结构与模块处理过程的设计。内部规格说明是从开发者角度来看的规格说明。程序是由内部规格说明决定的。</li></ul><h2 id="🍀-软件容错技术" tabindex="-1"><a class="header-anchor" href="#🍀-软件容错技术" aria-hidden="true">#</a> 🍀 软件容错技术</h2><blockquote><p>2014 年后没考过</p></blockquote><p>实现容错的主要手段是<strong>冗余</strong>。</p><p>通常，冗余技术分为 4 类：</p><ol><li>结构冗余：结构冗余是通常采用的冗余技术，按其工作方法可以分为： <ul><li>静态冗余</li><li>动态冗余</li><li>混合冗余</li></ul></li><li>信息冗余：指为<em>检测或纠正信息</em>在运算或传输中的错误需外附加的一部分信息。</li><li>时间冗余：指以<em>重复执行指令或程序</em>来消除瞬时错误带来的影响。</li><li><strong>冗余附加技术</strong>：指为实现上述冗余技术所需的资源和技术，包括：程序、指令、数据、存放和调动它们的空间和通道等。 <ol><li><u><s>在屏蔽硬件错误的容错技术中</s></u>，冗余附加技术包括： <ul><li>关键程序和数据的冗余存储及调用。</li><li>检测、表决、切换、重构、纠错和复算的实现。</li></ul></li><li><u>在屏蔽软件错误的容错系统中</u>，冗余附加技术的构成包括： <ul><li>冗余备份程序的存储及调用。</li><li>实现错误检测和错误恢复的程序。</li><li>实现容错软件所需的固化程序。</li></ul></li></ol></li></ol><h2 id="🍀-软件工具" tabindex="-1"><a class="header-anchor" href="#🍀-软件工具" aria-hidden="true">#</a> 🍀 软件工具</h2><h3 id="软件开发工具" tabindex="-1"><a class="header-anchor" href="#软件开发工具" aria-hidden="true">#</a> 软件开发工具*</h3><p>对应于软件开发过程的各种活动，软件开发工具通常有：</p><ul><li>需求分析工具</li><li>设计工具</li><li>编码与排错工具</li><li>测试工具</li></ul><h3 id="软件维护工具" tabindex="-1"><a class="header-anchor" href="#软件维护工具" aria-hidden="true">#</a> 软件维护工具</h3><p>辅助软件维护过程中活动的软件称为软件维护工具，它辅助维护人员对软件代码及其文档进行各种维护活动。软件维护工具主要有：</p><ul><li>版本控制工具</li><li>文档分析工具</li><li>开发信息库工具</li><li><em>逆向工程工具</em></li><li>再工程工具</li></ul><h3 id="软件管理和软件支持工具" tabindex="-1"><a class="header-anchor" href="#软件管理和软件支持工具" aria-hidden="true">#</a> 软件管理和软件支持工具*</h3><p>常用的铺助软件管理和软件支持的工具有：</p><ul><li>项目管理工具</li><li>配置管理工具</li><li>软件评价工具</li></ul>',42);function W(X,Q){const t=o("router-link"),u=o("CodeTabs");return m(),p("div",null,[l("details",w,[q,l("nav",C,[l("ul",null,[l("li",null,[i(t,{to:"#🍀-软件过程"},{default:s(()=>[a("🍀 软件过程")]),_:1}),l("ul",null,[l("li",null,[i(t,{to:"#能力成熟度模型-cmm"},{default:s(()=>[a("能力成熟度模型（CMM）")]),_:1})]),l("li",null,[i(t,{to:"#能力成熟度模型集成-cmmi"},{default:s(()=>[a("能力成熟度模型集成（CMMI）")]),_:1})])])]),l("li",null,[i(t,{to:"#🍀-软件过程模型"},{default:s(()=>[a("🍀 软件过程模型")]),_:1}),l("ul",null,[l("li",null,[i(t,{to:"#_1-瀑布模型-waterfall-model"},{default:s(()=>[a("1 瀑布模型 Waterfall Model")]),_:1})]),l("li",null,[i(t,{to:"#_2-增量模型-incremental-model"},{default:s(()=>[a("2 增量模型 Incremental Model")]),_:1})]),l("li",null,[i(t,{to:"#_3-演化模型-evolutionary-model"},{default:s(()=>[a("3 演化模型 Evolutionary Model")]),_:1})]),l("li",null,[i(t,{to:"#_4-喷泉模型-water-fountain-model"},{default:s(()=>[a("4 喷泉模型 Water Fountain Model")]),_:1})]),l("li",null,[i(t,{to:"#_5-统一过程-up-模型"},{default:s(()=>[a("5 统一过程（UP）模型*")]),_:1})]),l("li",null,[i(t,{to:"#🌸-6-敏捷方法-agile-development"},{default:s(()=>[a("🌸 6 敏捷方法 Agile Development")]),_:1})])])]),l("li",null,[i(t,{to:"#🍀-需求分析"},{default:s(()=>[a("🍀 需求分析")]),_:1}),l("ul",null,[l("li",null,[i(t,{to:"#软件需求"},{default:s(()=>[a("软件需求")]),_:1})])])]),l("li",null,[i(t,{to:"#🍀-系统设计"},{default:s(()=>[a("🍀 系统设计")]),_:1}),l("ul",null,[l("li",null,[i(t,{to:"#概要设计"},{default:s(()=>[a("概要设计")]),_:1})]),l("li",null,[i(t,{to:"#详细设计"},{default:s(()=>[a("详细设计")]),_:1})])])]),l("li",null,[i(t,{to:"#🍀-系统测试"},{default:s(()=>[a("🍀 系统测试")]),_:1}),l("ul",null,[l("li",null,[i(t,{to:"#系统测试原则"},{default:s(()=>[a("系统测试原则")]),_:1})]),l("li",null,[i(t,{to:"#传统软件的测试策略"},{default:s(()=>[a("传统软件的测试策略")]),_:1})]),l("li",null,[i(t,{to:"#测试方法"},{default:s(()=>[a("测试方法")]),_:1})])])]),l("li",null,[i(t,{to:"#🍀-运行和维护"},{default:s(()=>[a("🍀 运行和维护")]),_:1}),l("ul",null,[l("li",null,[i(t,{to:"#系统可维护性概念"},{default:s(()=>[a("系统可维护性概念")]),_:1})]),l("li",null,[i(t,{to:"#系统维护的内容及类型"},{default:s(()=>[a("系统维护的内容及类型")]),_:1})]),l("li",null,[i(t,{to:"#软件可靠性、可用性、可维护性"},{default:s(()=>[a("软件可靠性、可用性、可维护性")]),_:1})])])]),l("li",null,[i(t,{to:"#🍀-项目管理"},{default:s(()=>[a("🍀 项目管理")]),_:1}),l("ul",null,[l("li",null,[i(t,{to:"#沟通路径"},{default:s(()=>[a("沟通路径")]),_:1})]),l("li",null,[i(t,{to:"#cocomo-估算模型"},{default:s(()=>[a("COCOMO 估算模型")]),_:1})]),l("li",null,[i(t,{to:"#cocomoii-模型"},{default:s(()=>[a("COCOMOII 模型")]),_:1})])])]),l("li",null,[i(t,{to:"#🍀-进度管理"},{default:s(()=>[a("🍀 进度管理")]),_:1}),l("ul",null,[l("li",null,[i(t,{to:"#gantt-甘特图"},{default:s(()=>[a("Gantt 甘特图")]),_:1})]),l("li",null,[i(t,{to:"#pert-图"},{default:s(()=>[a("PERT 图")]),_:1})]),l("li",null,[i(t,{to:"#🌸-项目活动图-✅"},{default:s(()=>[a("🌸 项目活动图 ✅")]),_:1})])])]),l("li",null,[i(t,{to:"#🍀-软件配置管理"},{default:s(()=>[a("🍀 软件配置管理")]),_:1}),l("ul",null,[l("li",null,[i(t,{to:"#🌸-风险管理"},{default:s(()=>[a("🌸 风险管理")]),_:1})]),l("li",null,[i(t,{to:"#风险识别"},{default:s(()=>[a("风险识别*")]),_:1})]),l("li",null,[i(t,{to:"#风险预测"},{default:s(()=>[a("风险预测")]),_:1})]),l("li",null,[i(t,{to:"#风险评估"},{default:s(()=>[a("风险评估")]),_:1})]),l("li",null,[i(t,{to:"#风险控制"},{default:s(()=>[a("风险控制")]),_:1})])])]),l("li",null,[i(t,{to:"#🍀-软件质量"},{default:s(()=>[a("🍀 软件质量")]),_:1}),l("ul",null,[l("li",null,[i(t,{to:"#软件质量特性"},{default:s(()=>[a("软件质量特性")]),_:1})]),l("li",null,[i(t,{to:"#🌸-iso-iec-9126"},{default:s(()=>[a("🌸 ISO/IEC 9126")]),_:1})]),l("li",null,[i(t,{to:"#mc-call-软件质量模型"},{default:s(()=>[a("Mc Call 软件质量模型")]),_:1})])])]),l("li",null,[i(t,{to:"#🍀-软件评审"},{default:s(()=>[a("🍀 软件评审")]),_:1})]),l("li",null,[i(t,{to:"#🍀-软件容错技术"},{default:s(()=>[a("🍀 软件容错技术")]),_:1})]),l("li",null,[i(t,{to:"#🍀-软件工具"},{default:s(()=>[a("🍀 软件工具")]),_:1}),l("ul",null,[l("li",null,[i(t,{to:"#软件开发工具"},{default:s(()=>[a("软件开发工具*")]),_:1})]),l("li",null,[i(t,{to:"#软件维护工具"},{default:s(()=>[a("软件维护工具")]),_:1})]),l("li",null,[i(t,{to:"#软件管理和软件支持工具"},{default:s(()=>[a("软件管理和软件支持工具*")]),_:1})])])])])])]),T,O,L,z,P,i(u,{id:"1838",data:[{id:"for"},{id:"while"},{id:"do while"}]},{title0:s(({value:n,isActive:r})=>[a("for")]),title1:s(({value:n,isActive:r})=>[a("while")]),title2:s(({value:n,isActive:r})=>[a("do while")]),tab0:s(({value:n,isActive:r})=>[R]),tab1:s(({value:n,isActive:r})=>[E]),tab2:s(({value:n,isActive:r})=>[I]),_:1}),D,V,F,A,B,G,S,j,N,U])}const K=c(M,[["render",W],["__file","5.html.vue"]]);export{K as default};
