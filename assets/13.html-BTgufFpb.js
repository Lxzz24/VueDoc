import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as s,o as i,c as r,a as e,b as c,w as d,e as a,d as l}from"./app-CvlAI_tu.js";const p="/VueDoc/assets/202206142349353-DJ1xT1Ys.png",h="/VueDoc/assets/20220615221814-BMEBUjg0.png",u={},m={class:"hint-container details"},v=e("summary",null,"目录",-1),g={class:"table-of-contents"},x=l(`<h2 id="🍀-classpath" tabindex="-1"><a class="header-anchor" href="#🍀-classpath" aria-hidden="true">#</a> 🍀 classpath</h2><p>在 Java 中，我们经常听到 <code>classpath</code> 这个东西。网上有很多关于 “如何设置 classpath ” 的文章，但大部分设置都不靠谱。</p><h3 id="到底什么是-classpath" tabindex="-1"><a class="header-anchor" href="#到底什么是-classpath" aria-hidden="true">#</a> 到底什么是 classpath？</h3><p><code>classpath</code> 是 JVM 用到的一个环境变量，它用来指示 JVM 如何搜索 <code>class</code> 。</p><p>因为 Java 是编译型语言，源码文件是 <code>.java</code>，而编译后的 <code>.class</code> 文件才是真正可以被 JVM 执行的字节码。因此，JVM 需要知道，如果要加载一个 abc.xyz.Hello 的类，应该去哪搜索对应的 Hello.class 文件。</p><p>所以，<code>classpath</code> 就是一组目录的集合，它设置的搜索路径与操作系统相关。例如，在 Windows 系统上，用 <code>;</code> 分隔，带空格的目录用 <code>&quot;&quot;</code> 括起来，可能长这样：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>C:\\work\\project1\\bin;C:\\shared;&quot;D:\\My Documents\\project1\\bin&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在 Linux 系统上，用 <code>:</code> 分隔，可能长这样：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>/usr/shared:/usr/local/bin:/home/liaoxuefeng/bin
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>现在我们假设 <code>classpath</code> 是 <code>.;C:\\work\\project1\\bin;C:\\shared</code>，当 JVM 在加载 <code>abc.xyz.Hello</code> 这个类时，会依次查找：</p><ul><li>&lt;当前目录&gt;\\abc\\xyz\\Hello.class</li><li>C:\\work\\project1\\bin\\abc\\xyz\\Hello.class</li><li>C:\\shared\\abc\\xyz\\Hello.class</li></ul><p>注意到 <code>.</code> 代表当前目录。如果 JVM 在某个路径下找到了对应的 <code>class</code> 文件，就不再往后继续搜索。如果所有路径下都没有找到，就报错。</p><h3 id="classpath-的设定方法有两种" tabindex="-1"><a class="header-anchor" href="#classpath-的设定方法有两种" aria-hidden="true">#</a> classpath 的设定方法有两种：</h3><ol><li>在系统环境变量中设置 classpath 环境变量，不推荐；</li><li>在<em>启动 JVM 时</em>设置 classpath 变量，<strong><em>推荐</em></strong> 。</li></ol><p>我们强烈<strong>不推荐</strong>在系统环境变量中设置 <code>classpath</code>，那样 <strong><em>会污染整个系统环境</em></strong> 。</p><p>在启动 JVM 时设置 <code>classpath</code> 才是推荐的做法。实际上就是给 <code>java</code> 命令传入 <code>-classpath</code> 或 <code>-cp</code> 参数：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>java -classpath .;C:\\work\\project1\\bin;C:\\shared abc.xyz.Hello
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>或者使用 <code>-cp</code> 的简写：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>java -cp .;C:\\work\\project1\\bin;C:\\shared abc.xyz.Hello
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>没有设置系统环境变量，也没有传入 <code>-cp</code> 参数，那么 JVM 默认的 <code>classpath</code> 为 <code>.</code>，即当前目录：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>java abc.xyz.Hello
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上述命令告诉 JVM 只在当前目录搜索 <code>Hello.class</code> 。</p><p>在 IDE 中运行 Java 程序，IDE 自动传入的 <code>-cp</code> 参数是当前工程的 <code>bin</code> 目录和引入的 jar 包。</p><p>通常，我们在自己编写的 <code>class</code> 中，会引用 Java 核心库的 <code>class</code>，例如，<code>String</code>、<code>ArrayList</code> 等。这些 <code>class</code> 应该上哪去找？</p><p>有很多 “如何设置 classpath” 的文章会告诉你把 JVM 自带的 <code>rt.jar</code> 放入 <code>classpath</code>，但事实上，根本不需要告诉 JVM 如何去 Java 核心库查找 <code>class</code>，JVM 怎么可能笨到连自己的核心库在哪都不知道？</p><div class="hint-container caution"><p class="hint-container-title">警告</p><p>不要把任何 Java 核心库添加到 classpath 中！JVM 根本不依赖 classpath 加载核心库！</p></div><p>更好的做法是，不要设置 <code>classpath</code> ！默认的当前目录 <code>.</code> 对于绝大多数情况都够用了。</p><p>假设我们有一个编译后的 <code>Hello.class</code>，它的包名是 <code>com.example</code>，当前目录是 <code>C:\\work</code>，那么，目录结构必须如下：</p><pre><code>C:\\work
└─ com
    └─ example
        └─ Hello.class
</code></pre><p>运行这个 <code>Hello.class</code> 必须在当前目录下使用如下命令：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>C:\\work&gt; java -cp . com.example.Hello
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>JVM 根据 classpath 设置的 <code>.</code> 在当前目录下查找 <code>com.example.Hello</code>，即实际搜索文件必须位于 <code>com/example/Hello.class</code> 。如果指定的 <code>.class</code> 文件不存在，或者目录结构和包名对不上，均会报错。</p><h2 id="🍀-jar-包" tabindex="-1"><a class="header-anchor" href="#🍀-jar-包" aria-hidden="true">#</a> 🍀 jar 包</h2><p>如果有很多 <code>.class</code> 文件，散落在各层目录中，肯定不便于管理。如果能把目录打一个包，变成一个文件，就方便多了。</p><p>jar 包就是用来干这个事的，它可以把 <code>package</code> 组织的目录层级，以及各个目录下的所有文件（包括 <code>.class</code> 文件和其他文件）都打成一个 jar 文件，这样一来，无论是备份，还是发给客户，就简单多了。</p><p>jar 包实际上就是一个 zip 格式的压缩文件，而 jar 包相当于目录。如果我们要执行一个 jar 包的 <code>class</code>，就可以把 jar 包放到 classpath 中：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>java -cp ./hello.jar abc.xyz.Hello
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样 JVM 会自动在 <code>hello.jar</code> 文件里去搜索某个类。</p><p>那么问题来了：</p><h3 id="如何创建-jar-包" tabindex="-1"><a class="header-anchor" href="#如何创建-jar-包" aria-hidden="true">#</a> 如何创建 jar 包？</h3><p>因为 jar 包就是 zip 包，所以，直接在资源管理器中，找到正确的目录，点击右键，在弹出的快捷菜单中选择 “发送到”，“压缩(zipped) 文件夹”，就制作了一个 zip 文件。然后，把后缀从 <code>.zip</code> 改为 <code>.jar</code>，一个 jar 包就创建成功。</p><p>假设编译输出的目录结构是这样：</p><pre><code>package_sample
└─ bin
    ├─ hong
    │  └─ Person.class
    │  ming
    │  └─ Person.class
    └─ mr
        └─ jun
            └─ Arrays.class
</code></pre><p>这里需要特别注意的是，jar 包里的第一层目录，不能是 <code>bin</code>，而应该是 <code>hong</code>、<code>ming</code>、<code>mr</code> 。如果在 Windows 的资源管理器中看，应该长这样：</p><figure><img src="`+p+'" alt="hello.zip" tabindex="0" loading="lazy"><figcaption>hello.zip</figcaption></figure><p>如果长这样：</p><figure><img src="'+h+`" alt="20220615221814" tabindex="0" loading="lazy"><figcaption>20220615221814</figcaption></figure><p>说明打包打得有问题，JVM 仍然无法从 jar 包中查找正确的 <code>class</code>，原因是 <code>hong.Person</code> 必须按 <code>hong/Person.class</code> 存放，而不是 <code>bin/hong/Person.class</code> 。</p><p>jar 包还可以包含一个特殊的 <code>/META-INF/MANIFEST.MF</code> 文件，<code>MANIFEST.MF</code> 是纯文本，可以指定 <code>Main-Class</code> 和其它信息。JVM 会自动读取这个 <code>MANIFEST.MF</code> 文件，如果存在 <code>Main-Class</code>，我们就不必在命令行指定启动的类名，而是用更方便的命令：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>java -jar hello.jar
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>jar 包还可以包含其它 jar 包，这个时候，就需要在 <code>MANIFEST.MF</code> 文件里配置 <code>classpath</code> 了。</p>`,51),b=e("code",null,"MANIFEST.MF",-1),j={href:"/Maven%E5%9F%BA%E7%A1%80",target:"_blank",rel:"noopener noreferrer"},_=l('<h2 id="🍀-小结" tabindex="-1"><a class="header-anchor" href="#🍀-小结" aria-hidden="true">#</a> 🍀 小结</h2><p>JVM 通过环境变量 <code>classpath</code> 决定搜索 <code>class</code> 的路径和顺序；</p><p>不推荐设置系统环境变量 <code>classpath</code>，始终建议通过 <code>-cp</code> 命令传入；</p><p>jar 包相当于目录，可以包含很多 <code>.class</code> 文件，方便下载和使用；</p><p><code>MANIFEST.MF</code> 文件可以提供 jar 包的信息，如 <code>Main-Class</code>，这样可以直接运行 jar 包。</p>',5);function M(f,J){const o=s("router-link"),t=s("ExternalLinkIcon");return i(),r("div",null,[e("details",m,[v,e("nav",g,[e("ul",null,[e("li",null,[c(o,{to:"#🍀-classpath"},{default:d(()=>[a("🍀 classpath")]),_:1}),e("ul",null,[e("li",null,[c(o,{to:"#到底什么是-classpath"},{default:d(()=>[a("到底什么是 classpath？")]),_:1})]),e("li",null,[c(o,{to:"#classpath-的设定方法有两种"},{default:d(()=>[a("classpath 的设定方法有两种：")]),_:1})])])]),e("li",null,[c(o,{to:"#🍀-jar-包"},{default:d(()=>[a("🍀 jar 包")]),_:1}),e("ul",null,[e("li",null,[c(o,{to:"#如何创建-jar-包"},{default:d(()=>[a("如何创建 jar 包？")]),_:1})])])]),e("li",null,[c(o,{to:"#🍀-小结"},{default:d(()=>[a("🍀 小结")]),_:1})])])])]),x,e("p",null,[a("在大型项目中，不可能手动编写 "),b,a(" 文件，再手动创建 zip 包。Java 社区提供了大量的开源构建工具，例如 "),e("a",j,[a("Maven"),c(t)]),a(" ，可以非常方便地创建 jar 包。")]),_])}const C=n(u,[["render",M],["__file","13.html.vue"]]);export{C as default};
