import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as p,o as c,c as l,a as n,b as a,w as e,d as i,e as t}from"./app-CvlAI_tu.js";const r="/VueDoc/assets/image-20231220171452717-CF_MsUVd.png",d="/VueDoc/assets/l-20231220171306566-DwpTuEzc.jpeg",u="/VueDoc/assets/image-20231220171529128-BfVrUogW.png",k="/VueDoc/assets/l-20231220171306527-DUiJ-s44.jpeg",v={},m={class:"hint-container details"},g=n("summary",null,"目录",-1),h={class:"table-of-contents"},b=i(`<h2 id="🍀-redirect" tabindex="-1"><a class="header-anchor" href="#🍀-redirect" aria-hidden="true">#</a> 🍀 Redirect</h2><p>重定向是指当浏览器请求一个 URL 时，服务器返回一个重定向指令，告诉浏览器地址已经变了，麻烦使用新的 URL 再重新发送新请求。</p><p>例如，我们已经编写了一个能处理 <code>/hello</code> 的 <code>HelloServlet</code>，如果收到的路径为 <code>/hi</code>，希望能重定向到 <code>/hello</code>，可以再编写一个 <code>RedirectServlet</code>：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@WebServlet</span><span class="token punctuation">(</span>urlPatterns <span class="token operator">=</span> <span class="token string">&quot;/hi&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedirectServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">{</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doGet</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> req<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> resp<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
        <span class="token comment">// 构造重定向的路径:</span>
        <span class="token class-name">String</span> name <span class="token operator">=</span> req<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> redirectToUrl <span class="token operator">=</span> <span class="token string">&quot;/hello&quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>name <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token string">&quot;&quot;</span><span class="token operator">:</span><span class="token string">&quot;?name=&quot;</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 发送重定向响应:</span>
        resp<span class="token punctuation">.</span><span class="token function">sendRedirect</span><span class="token punctuation">(</span>redirectToUrl<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果浏览器发送 <code>GET /hi</code> 请求，<code>RedirectServlet</code> 将处理此请求。由于 <code>RedirectServlet</code> 在内部又发送了重定向响应，因此，浏览器会收到如下响应：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>HTTP/1.1 <span class="token number">302</span> Found
Location: /hello
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>当浏览器收到 302 响应后，它会立刻根据 <code>Location</code> 的指示发送一个新的 <code>GET /hello</code> 请求，这个过程就是重定向：</p><figure><img src="`+r+'" alt="image-20231220171452717" tabindex="0" loading="lazy"><figcaption>image-20231220171452717</figcaption></figure><p>观察 Chrome 浏览器的网络请求，可以看到两次 HTTP 请求：</p><figure><img src="'+d+`" alt="redirect" tabindex="0" loading="lazy"><figcaption>redirect</figcaption></figure><p>并且浏览器的地址栏路径自动更新为 <code>/hello</code>。</p><p>重定向有两种：一种是 302 响应，称为临时重定向，一种是 301 响应，称为永久重定向。两者的区别是，如果服务器发送 301 永久重定向响应，浏览器会缓存 <code>/hi</code> 到 <code>/hello</code> 这个重定向的关联，下次请求 <code>/hi</code> 的时候，浏览器就直接发送 <code>/hello</code> 请求了。</p><p>重定向有什么作用？重定向的目的是当 Web 应用升级后，如果请求路径发生了变化，可以将原来的路径重定向到新路径，从而避免浏览器请求原路径找不到资源。</p><p><code>HttpServletResponse</code> 提供了快捷的 <code>redirect()</code> 方法实现 302 重定向。如果要实现 301 永久重定向，可以这么写：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>resp<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span><span class="token class-name">HttpServletResponse</span><span class="token punctuation">.</span><span class="token constant">SC_MOVED_PERMANENTLY</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 301</span>
resp<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">&quot;Location&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;/hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="🍀-forward" tabindex="-1"><a class="header-anchor" href="#🍀-forward" aria-hidden="true">#</a> 🍀 Forward</h2><p>Forward 是指内部转发。当一个 Servlet 处理请求的时候，它可以决定自己不继续处理，而是转发给另一个 Servlet 处理。</p><p>例如，我们已经编写了一个能处理 <code>/hello</code> 的 <code>HelloServlet</code>，继续编写一个能处理 <code>/morning</code> 的 <code>ForwardServlet</code>：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@WebServlet</span><span class="token punctuation">(</span>urlPatterns <span class="token operator">=</span> <span class="token string">&quot;/morning&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ForwardServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">{</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doGet</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> req<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> resp<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span><span class="token punctuation">,</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
        req<span class="token punctuation">.</span><span class="token function">getRequestDispatcher</span><span class="token punctuation">(</span><span class="token string">&quot;/hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forward</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> resp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>ForwardServlet</code> 在收到请求后，它并不自己发送响应，而是把请求和响应都转发给路径为 <code>/hello</code> 的 Servlet，即下面的代码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>req<span class="token punctuation">.</span><span class="token function">getRequestDispatcher</span><span class="token punctuation">(</span><span class="token string">&quot;/hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forward</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> resp<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>后续请求的处理实际上是由 <code>HelloServlet</code> 完成的。这种处理方式称为转发（Forward），我们用流程图画出来如下：</p><figure><img src="`+u+'" alt="image-20231220171529128" tabindex="0" loading="lazy"><figcaption>image-20231220171529128</figcaption></figure><p>转发和重定向的区别在于，转发是在 Web 服务器内部完成的，对浏览器来说，它只发出了一个 HTTP 请求：</p><figure><img src="'+k+'" alt="forward" tabindex="0" loading="lazy"><figcaption>forward</figcaption></figure><p>注意到使用转发的时候，浏览器的地址栏路径仍然是 <code>/morning</code>，浏览器并不知道该请求在 Web 服务器内部实际上做了一次转发。</p><h2 id="🍀-练习" tabindex="-1"><a class="header-anchor" href="#🍀-练习" aria-hidden="true">#</a> 🍀 练习</h2><p>使用重定向和转发</p><h2 id="🍀-小结" tabindex="-1"><a class="header-anchor" href="#🍀-小结" aria-hidden="true">#</a> 🍀 小结</h2><p>使用重定向时，浏览器知道重定向规则，并且会自动发起新的 HTTP 请求；</p><p>使用转发时，浏览器并不知道服务器内部的转发逻辑。</p>',31);function f(_,w){const s=p("router-link");return c(),l("div",null,[n("details",m,[g,n("nav",h,[n("ul",null,[n("li",null,[a(s,{to:"#🍀-redirect"},{default:e(()=>[t("🍀 Redirect")]),_:1})]),n("li",null,[a(s,{to:"#🍀-forward"},{default:e(()=>[t("🍀 Forward")]),_:1})]),n("li",null,[a(s,{to:"#🍀-练习"},{default:e(()=>[t("🍀 练习")]),_:1})]),n("li",null,[a(s,{to:"#🍀-小结"},{default:e(()=>[t("🍀 小结")]),_:1})])])])]),b])}const x=o(v,[["render",f],["__file","1.html.vue"]]);export{x as default};
