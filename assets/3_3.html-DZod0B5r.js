import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as s,d as t}from"./app-CvlAI_tu.js";const e={},p=t(`<blockquote><p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p></blockquote><p>解释器模式（Interpreter）是一种针对特定问题设计的一种解决方案。例如，匹配字符串的时候，由于匹配条件非常灵活，使得通过代码来实现非常不灵活。举个例子，针对以下的匹配条件：</p><ul><li>以 <code>+</code> 开头的数字表示的区号和电话号码，如 <code>+861012345678</code>；</li><li>以英文开头，后接英文和数字，并以. 分隔的域名，如 <code>www.liaoxuefeng.com</code>；</li><li>以 <code>/</code> 开头的文件路径，如 <code>/path/to/file.txt</code>；</li><li>...</li></ul><p>因此，需要一种通用的表示方法——正则表达式来进行匹配。正则表达式就是一个字符串，但要把正则表达式解析为语法树，然后再匹配指定的字符串，就需要一个解释器。</p><p>实现一个完整的正则表达式的解释器非常复杂，但是使用解释器模式却很简单：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">&quot;+861012345678&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span><span class="token string">&quot;^\\\\+\\\\d+$&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>类似的，当我们使用 JDBC 时，执行的 SQL 语句虽然是字符串，但最终需要数据库服务器的 SQL 解释器来把 SQL“翻译” 成数据库服务器能执行的代码，这个执行引擎也非常复杂，但对于使用者来说，仅仅需要写出 SQL 字符串即可。</p><h2 id="🍀-练习" tabindex="-1"><a class="header-anchor" href="#🍀-练习" aria-hidden="true">#</a> 🍀 练习</h2><p>请实现一个简单的解释器，它可以以 SLF4J 的日志格式输出字符串：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;[{}] start {} at {}...&quot;</span><span class="token punctuation">,</span> <span class="token class-name">LocalTime</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withNano</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;engine&quot;</span><span class="token punctuation">,</span> <span class="token class-name">LocalDate</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// [11:02:18] start engine at 2020-02-21...</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="🍀-小结" tabindex="-1"><a class="header-anchor" href="#🍀-小结" aria-hidden="true">#</a> 🍀 小结</h2><p>解释器模式通过抽象语法树实现对用户输入的解释执行。</p><p>解释器模式的实现通常非常复杂，且一般只能解决一类特定问题。</p>`,13),o=[p];function c(l,i){return a(),s("div",null,o)}const r=n(e,[["render",c],["__file","3_3.html.vue"]]);export{r as default};
