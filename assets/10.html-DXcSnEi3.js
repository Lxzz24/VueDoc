import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as p,o as l,c as t,a,b as s,w as e,d as i,e as c}from"./app-CvlAI_tu.js";const d={},r={class:"hint-container details"},u=a("summary",null,"目录",-1),k={class:"table-of-contents"},m=i(`<p>在前面的代码中，我们把类和接口命名为 <code>Person</code>、<code>Student</code>、<code>Hello</code> 等简单名字。</p><p>在现实中，如果小明写了一个 <code>Person</code> 类，小红也写了一个 <code>Person</code> 类，现在，小白既想用小明的 <code>Person</code>，也想用小红的 <code>Person</code>，怎么办？</p><p>如果小军写了一个 <code>Arrays</code> 类，恰好 JDK 也自带了一个 <code>Arrays</code> 类，如何解决类名冲突？</p><p>在 Java 中，我们使用 <code>package</code> 来解决名字冲突。</p><p>Java 定义了一种名字空间，称之为包： <code>package</code> 。一个类总是属于某个包，类名（比如 <code>Person</code> ）只是一个简写，真正的完整类名是 <code>包名.类名</code> 。</p><p>例如：</p><ul><li>小明的 <code>Person</code> 类存放在包 <code>ming</code> 下面，因此，完整类名是 <code>ming.Person</code> ；</li><li>小红的 <code>Person</code> 类存放在包 <code>hong</code> 下面，因此，完整类名是 <code>hong.Person</code> ；</li><li>小军的 <code>Arrays</code> 类存放在包 <code>mr.jun</code> 下面，因此，完整类名是 <code>mr.jun.Arrays</code> ；</li><li>JDK 的 <code>Arrays</code> 类存放在包 <code>java.util</code> 下面，因此，完整类名是 <code>java.util.Arrays</code>。</li></ul><p>在定义 <code>class</code> 的时候，我们需要在第一行声明这个 <code>class</code> 属于哪个包。</p><p>小明的 <code>Person.java</code> 文件：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">ming</span><span class="token punctuation">;</span> <span class="token comment">// 申明包名 ming</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>小军的 <code>Arrays.java</code> 文件：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">mr<span class="token punctuation">.</span>jun</span><span class="token punctuation">;</span> <span class="token comment">// 申明包名 mr.jun</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Arrays</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 Java 虚拟机执行的时候，JVM 只看完整类名，因此，只要包名不同，类就不同。</p><p>包可以是多层结构，用 <code>.</code> 隔开。例如： <code>java.util</code> 。</p><div class="hint-container caution"><p class="hint-container-title">警告</p><p>要特别注意：包没有父子关系。<code>java.util</code> 和 <code>java.util.zip</code> 是不同的包，两者没有任何继承关系。</p></div><p>没有定义包名的 <code>class</code>，它使用的是默认包，<em>非常容易引起名字冲突</em>，因此，不推荐不写包名的做法。</p><p>我们还需要按照包结构把上面的 Java 文件组织起来。假设以 <code>package_sample</code> 作为根目录，<code>src</code> 作为源码目录，那么所有文件结构就是：</p><pre><code>    package_sample
    └─ src
        ├─ hong
        │  └─ Person.java
        │  ming
        │  └─ Person.java
        └─ mr
            └─ jun
                └─ Arrays.java
</code></pre><p>即所有 Java 文件对应的目录层次要和包的层次一致。</p><p>编译后的 <code>.class</code> 文件也需要按照包结构存放。如果使用 IDE，把编译后的 <code>.class</code> 文件放到 <code>bin</code> 目录下，那么，编译的文件结构就是：</p><pre><code>    package_sample
    └─ bin
        ├─ hong
        │  └─ Person.class
        │  ming
        │  └─ Person.class
        └─ mr
            └─ jun
                └─ Arrays.class
</code></pre><p>编译的命令相对比较复杂，我们需要在 <code>src</code> 目录下执行 <code>javac</code> 命令：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>javac -d ../bin ming/Person.java hong/Person.java mr/jun/Arrays.java
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在 IDE 中，会自动根据包结构编译所有 Java 源码，所以不必担心使用命令行编译的复杂命令。</p><h2 id="🍀-包作用域" tabindex="-1"><a class="header-anchor" href="#🍀-包作用域" aria-hidden="true">#</a> 🍀 包作用域</h2><p>位于同一个包的类，可以访问包作用域的字段和方法。不用 <code>public</code>、<code>protected</code>、<code>private</code> 修饰的字段和方法就是包作用域。例如，<code>Person</code> 类定义在 <code>hello</code> 包下面：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">hello</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token comment">// 包作用域:</span>
    <span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>Main</code> 类也定义在 <code>hello</code> 包下面：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">hello</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Person</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        p<span class="token punctuation">.</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 可以调用，因为 Main 和 Person 在同一个包</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="🍀-import" tabindex="-1"><a class="header-anchor" href="#🍀-import" aria-hidden="true">#</a> 🍀 import</h2><p>在一个 <code>class</code> 中，我们总会引用其他的 <code>class</code> 。例如，小明的 <code>ming.Person</code> 类，如果要引用小军的 <code>mr.jun.Arrays</code> 类，他有三种写法：</p><p>第一种，<strong><em>直接写出完整类名</em></strong> ，例如：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">ming</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name"><span class="token namespace">mr<span class="token punctuation">.</span>jun<span class="token punctuation">.</span></span>Arrays</span> arrays <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token namespace">mr<span class="token punctuation">.</span>jun<span class="token punctuation">.</span></span>Arrays</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>很显然，每次写完整类名比较痛苦。</p><p>因此，第二种写法是 <strong><em>用 <code>import</code> 语句，导入小军的 <code>Arrays</code>，然后写简单类名</em></strong> ：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">ming</span><span class="token punctuation">;</span>

<span class="token comment">// 导入完整类名:</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">mr<span class="token punctuation">.</span>jun<span class="token punctuation">.</span></span><span class="token class-name">Arrays</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Arrays</span> arrays <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Arrays</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在写 <code>import</code> 的时候，可以使用 <code>*</code>，表示把这个包下面的所有 <code>class</code> 都导入进来（但不包括子包的 <code>class</code> ）：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">ming</span><span class="token punctuation">;</span>

<span class="token comment">// 导入 mr.jun 包的所有 class:</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">mr<span class="token punctuation">.</span>jun<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Arrays</span> arrays <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Arrays</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container important"><p class="hint-container-title">重要</p><p>我们一般不推荐这种写法，因为在导入了多个包后，很难看出 Arrays 类属于哪个包。</p></div><p>还有一种 <code>import static</code> 的语法，它可以 <strong><em>导入一个类的静态字段和静态方法</em></strong> ：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">main</span><span class="token punctuation">;</span>

<span class="token comment">// 导入 System 类的所有静态字段和静态方法:</span>
<span class="token keyword">import</span> <span class="token keyword">static</span> <span class="token import static"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token operator">*</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 相当于调用 System.out.println(…)</span>
        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, world!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>import static</code> <em>很少使用</em>。</p><p>Java 编译器最终编译出的 <code>.class</code> 文件只使用 <strong><em>完整类名</em></strong> ，因此，在代码中，当编译器遇到一个 <code>class</code> 名称时：</p><ul><li>如果是完整类名，就直接根据完整类名查找这个 <code>class</code> ；</li><li>如果是简单类名，按下面的顺序依次查找： <ul><li>查找当前 <code>package</code> 是否存在这个 <code>class</code> ；</li><li>查找 <code>import</code> 的包是否包含这个 <code>class</code> ；</li><li>查找 <code>java.lang</code> 包是否包含这个 <code>class</code> 。</li></ul></li></ul><p>如果按照上面的规则还无法确定类名，则编译报错。</p><p>我们来看一个例子：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">test</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>text<span class="token punctuation">.</span></span><span class="token class-name">Format</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>List</span> list<span class="token punctuation">;</span> <span class="token comment">// ok，使用完整类名 -&gt; java.util.List</span>
        <span class="token class-name">Format</span> format <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// ok，使用 import 的类 -&gt; java.text.Format</span>
        <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">&quot;hi&quot;</span><span class="token punctuation">;</span> <span class="token comment">// ok，使用 java.lang 包的 String -&gt; java.lang.String</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok，使用 java.lang 包的 System -&gt; java.lang.System</span>
        <span class="token class-name">MessageFormat</span> mf <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 编译错误：无法找到 MessageFormat: MessageFormat cannot be resolved to a type</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因此，编写 class 的时候，编译器会自动帮我们做两个 <code>import</code> 动作：</p><p>默认自动 <code>import</code> 当前 <code>package</code> 的其他 <code>class</code> ；</p><p>默认自动 <code>import java.lang.*</code> 。</p><div class="hint-container caution"><p class="hint-container-title">警告</p><p>自动导入的是 <code>java.lang</code> 包，但类似 <code>java.lang.reflect</code> 这些包仍需要手动导入。</p></div><p>如果有两个 <code>class</code> 名称相同，例如，<code>mr.jun.Arrays</code> 和 <code>java.util.Arrays</code>，那么只能 <code>import</code> 其中一个，另一个必须写完整类名。</p><h3 id="import-关键字的使用" tabindex="-1"><a class="header-anchor" href="#import-关键字的使用" aria-hidden="true">#</a> <code>import</code> 关键字的使用</h3><ol><li>在源文件中显式的使用 <code>import</code> 结构导入指定包下的类、接口</li><li>声明在包的声明和类的声明之间</li><li>如果需要导入多个结构，则并列写出即可</li><li>可以使用 <code>xxx.*</code> 的方式，表示可以导入 xxx 包下的所有结构</li><li>如果使用的类或接口是 <code>java.lang</code> 包下定义的，则可以省略 <code>import</code> 结构</li><li>如果使用的类或接口是本包下定义的，则可以省略 <code>import</code> 结构</li><li>如果在源文件中，使用了不同包下的同名的类，则必须至少有一个类以全类名的方式显示</li><li>使用 <code>xxx.*</code> 方式表明可以调用 xxx 包下的所有结构。但是如果使用的是 xxx 子包下的结构，则仍需要显式导入。</li><li><code>import static</code> ：导入指定类或接口中的静态结构：属性或方法。</li></ol><h2 id="🍀-最佳实践" tabindex="-1"><a class="header-anchor" href="#🍀-最佳实践" aria-hidden="true">#</a> 🍀 最佳实践</h2><p>为了避免名字冲突，我们需要确定唯一的包名。推荐的做法是使用倒置的域名来确保唯一性。例如：</p><ul><li>org.apache</li><li>org.apache.commons.log</li><li>com.liaoxuefeng.sample</li></ul><p>子包就可以根据功能自行命名。</p><p>要注意不要和 <code>java.lang</code> 包的类重名，即自己的类不要使用这些名字：</p><ul><li>String</li><li>System</li><li>Runtime</li><li>...</li></ul><p>要注意也不要和 JDK 常用类重名：</p><ul><li>java.util.List</li><li>java.text.Format</li><li>java.math.BigInteger</li><li>...</li></ul><h2 id="🍀-package-关键字的使用" tabindex="-1"><a class="header-anchor" href="#🍀-package-关键字的使用" aria-hidden="true">#</a> 🍀 <code>package</code> 关键字的使用</h2><ol><li>为了更好的实现项目中类的管理，提供包的概念</li><li>使用 <code>package</code> 声明类或接口所需的包，声明在源文件的首行</li><li>包，属于标识符，遵循标识符的命名规则、规范（<em>xxxyyyzzz</em>）、“见名知意”</li><li>每 <code>&quot;.&quot;</code> 一次，就代表一层文件目录</li></ol><div class="hint-container caution"><p class="hint-container-title">警告</p><p>同一个包下，不能命名同名的接口、类； 不同的包下，可以命名同名的接口、类。</p></div><h3 id="jdk-中主要的包" tabindex="-1"><a class="header-anchor" href="#jdk-中主要的包" aria-hidden="true">#</a> JDK 中主要的包</h3><ol><li><code>java.lang</code>（language）---- 包含一些 Java 语言的核心类，如 String 、 Math 、 Integer 、 System 和 Thread ，提供常用功能</li><li><code>java.net</code> ---- 包含执行与网络相关的操作的类和接口。</li><li><code>java.io</code> ---- 包含能提供多种输入 / 输出功能的类。</li><li><code>java.util</code> ---- 包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。</li><li><code>java.text</code> ---- 包含了一些 java 格式化相关的类</li><li><code>java.sql</code> ---- 包含了 java 进行 JDBC 数据库编程的相关类 / 接口</li><li><code>java.awt</code> ---- 包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面 (GUI)。<em><s>（Java 也可以写客户端，但是基本不用了）</s></em></li></ol><h3 id="mvc-设计模式" tabindex="-1"><a class="header-anchor" href="#mvc-设计模式" aria-hidden="true">#</a> MVC 设计模式</h3><p>MVC 是常用的设计模式之一，将整个程序分为三个层次： <strong><em>视图模型层</em></strong> ，<strong><em>控制器层</em></strong> ，与 <strong><em>数据模型层</em></strong> 。</p><ol><li><p>模型层 model 主要处理数据</p><ul><li>数据对象封装 <code>model.bean/domain</code></li><li>数据库操作类 <code>model.dao</code></li><li>数据库 <code>model.db</code></li></ul></li><li><p>视图层 view 显示数据</p><ul><li>相关工具类 <code>view.utils</code></li><li>自定义 <code>view view.ui</code></li></ul></li><li><p>控制层 controller 处理业务逻辑</p><ul><li>应用界面相关 <code>controller.activity</code></li><li>存放 <code>fragment</code> <code>controller.fragment</code></li><li>显示列表的适配器 <code>controller.adapter</code></li><li>服务相关的 <code>controller.service</code></li><li>抽取的基类 <code>controller.base</code></li></ul></li></ol><p><strong>好处：</strong></p><p>这种将程序输入输出、数据处理，以及数据的展示分离开来的设计模式使程序结构变的灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程序的耦合性。</p><h2 id="🍀-练习" tabindex="-1"><a class="header-anchor" href="#🍀-练习" aria-hidden="true">#</a> 🍀 练习</h2><p>请按如下包结构创建工程项目：</p><pre><code>oop-package
└── src
    └── com
        └── itranswarp
            ├── sample
            │   └── Main.java
            └── world
                └── Person.java
</code></pre><h2 id="🍀-小结" tabindex="-1"><a class="header-anchor" href="#🍀-小结" aria-hidden="true">#</a> 🍀 小结</h2><ul><li>Java 内建的 <code>package</code> 机制是为了避免 <code>class</code> 命名冲突；</li><li>JDK 的核心类使用 <code>java.lang</code> 包，编译器会自动导入；</li><li>JDK 的其它常用类定义在 <code>java.util.*</code>，<code>java.math.*</code>，<code>java.text.*</code>，... ；</li><li>包名推荐使用倒置的域名，例如 <code>org.apache</code> 。</li></ul>`,77);function v(g,b){const n=p("router-link");return l(),t("div",null,[a("details",r,[u,a("nav",k,[a("ul",null,[a("li",null,[s(n,{to:"#🍀-包作用域"},{default:e(()=>[c("🍀 包作用域")]),_:1})]),a("li",null,[s(n,{to:"#🍀-import"},{default:e(()=>[c("🍀 import")]),_:1}),a("ul",null,[a("li",null,[s(n,{to:"#import-关键字的使用"},{default:e(()=>[c("import 关键字的使用")]),_:1})])])]),a("li",null,[s(n,{to:"#🍀-最佳实践"},{default:e(()=>[c("🍀 最佳实践")]),_:1})]),a("li",null,[s(n,{to:"#🍀-package-关键字的使用"},{default:e(()=>[c("🍀 package 关键字的使用")]),_:1}),a("ul",null,[a("li",null,[s(n,{to:"#jdk-中主要的包"},{default:e(()=>[c("JDK 中主要的包")]),_:1})]),a("li",null,[s(n,{to:"#mvc-设计模式"},{default:e(()=>[c("MVC 设计模式")]),_:1})])])]),a("li",null,[s(n,{to:"#🍀-练习"},{default:e(()=>[c("🍀 练习")]),_:1})]),a("li",null,[s(n,{to:"#🍀-小结"},{default:e(()=>[c("🍀 小结")]),_:1})])])])]),m])}const j=o(d,[["render",v],["__file","10.html.vue"]]);export{j as default};
