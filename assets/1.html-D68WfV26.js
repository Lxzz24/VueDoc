import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as c,o as i,c as o,a as s,b as n,w as t,d as p,e}from"./app-CvlAI_tu.js";const u="/VueDoc/assets/20221124100150-BoBER6vH.png",r="/VueDoc/assets/20221124100203-BPA8T2Zm.png",d="/VueDoc/assets/20221124100344-0hsD3CYE.png",k="/VueDoc/assets/20221124100359-DyDC-QM5.png",m="/VueDoc/assets/20221124100439-Byv-nC2m.png",v="/VueDoc/assets/20221124100448-CjXP0aJe.png",g={},b={class:"hint-container details"},h=s("summary",null,"目录",-1),f={class:"table-of-contents"},y=p('<p>什么是单元测试呢？单元测试就是针对最小的功能单元编写测试代码。Java 程序最小的功能单元是方法，因此，对 Java 程序进行单元测试就是针对单个 Java 方法的测试。</p><p>单元测试有什么好处呢？在学习单元测试前，我们可以先了解一下测试驱动开发。</p><p>所谓测试驱动开发，是指先编写接口，紧接着编写测试。编写完测试后，我们才开始真正编写实现代码。在编写实现代码的过程中，一边写，一边测，什么时候测试全部通过了，那就表示编写的实现完成了：</p><figure><img src="'+u+'" alt="20221124100150" tabindex="0" loading="lazy"><figcaption>20221124100150</figcaption></figure><p>这就是传说中的……</p><figure><img src="'+r+'" alt="20221124100203" tabindex="0" loading="lazy"><figcaption>20221124100203</figcaption></figure><p>当然，这是一种理想情况。大部分情况是我们已经编写了实现代码，需要对已有的代码进行测试。</p><p>我们先通过一个示例来看如何编写测试。假定我们编写了一个计算阶乘的类，它只有一个静态方法来计算阶乘：</p>',8),j=s("p",null,[s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"n"),s("mo",{stretchy:"false"},"!"),s("mo",null,"="),s("mn",null,"1"),s("mo",null,"×"),s("mn",null,"2"),s("mo",null,"×"),s("mn",null,"3"),s("mo",null,"×"),s("mi",{mathvariant:"normal"},"."),s("mi",{mathvariant:"normal"},"."),s("mi",{mathvariant:"normal"},"."),s("mo",null,"×"),s("mi",null,"n")]),s("annotation",{encoding:"application/x-tex"},"n!=1×2×3×...×n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6944em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},"!"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"×"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},"2"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"×"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},"3"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"×"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6667em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},"..."),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"×"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"n")])])])],-1),_=p(`<p>代码如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Factorial</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">fact</span><span class="token punctuation">(</span><span class="token keyword">long</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">long</span> r <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">long</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            r <span class="token operator">=</span> r <span class="token operator">*</span> i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> r<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要测试这个方法，一个很自然的想法是编写一个 main() 方法，然后运行一些测试代码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fact</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">3628800</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;pass&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;fail&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样我们就可以通过运行 main() 方法来运行测试代码。</p><p>不过，使用 main() 方法测试有很多缺点：</p><p>一是只能有一个 main() 方法，不能把测试代码分离，二是没有打印出测试结果和期望结果，例如，expected: 3628800, but actual: 123456，三是很难编写一组通用的测试代码。</p><p>因此，我们需要一种测试框架，帮助我们编写测试。</p><h2 id="🍀-junit" tabindex="-1"><a class="header-anchor" href="#🍀-junit" aria-hidden="true">#</a> 🍀 JUnit</h2><p>JUnit 是一个开源的 Java 语言的单元测试框架，专门针对 Java 设计，使用最广泛。JUnit 是事实上的单元测试的标准框架，任何 Java 开发者都应当学习并使用 JUnit 编写单元测试。</p><p>使用 JUnit 编写单元测试的好处在于，我们可以非常简单地组织测试代码，并随时运行它们，JUnit 就会给出成功的测试和失败的测试，还可以生成测试报告，不仅包含测试的成功率，还可以统计测试的代码覆盖率，即被测试的代码本身有多少经过了测试。对于高质量的代码来说，测试覆盖率应该在 80% 以上。</p><p>此外，几乎所有的 IDE 工具都集成了 JUnit，这样我们就可以直接在 IDE 中编写并运行 JUnit 测试。JUnit 目前最新版本是 5。</p><p>以 Eclipse 为例，当我们已经编写了一个 Factorial.java 文件后，我们想对其进行测试，需要编写一个对应的 FactorialTest.java 文件，以 Test 为后缀是一个惯例，并分别将其放入 src 和 test 目录中。最后，在 Project - Properties - Java Build Path - Libraries 中添加 JUnit 5 的库：</p><figure><img src="`+d+'" alt="20221124100344" tabindex="0" loading="lazy"><figcaption>20221124100344</figcaption></figure><p>整个项目结构如下：</p><figure><img src="'+k+`" alt="20221124100359" tabindex="0" loading="lazy"><figcaption>20221124100359</figcaption></figure><p>我们来看一下 FactorialTest.java 的内容：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itranswarp<span class="token punctuation">.</span>learnjava</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token keyword">static</span> <span class="token import static"><span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>jupiter<span class="token punctuation">.</span>api<span class="token punctuation">.</span></span><span class="token class-name">Assertions</span><span class="token punctuation">.</span><span class="token operator">*</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>jupiter<span class="token punctuation">.</span>api<span class="token punctuation">.</span></span><span class="token class-name">Test</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FactorialTest</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">void</span> <span class="token function">testFact</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">Factorial</span><span class="token punctuation">.</span><span class="token function">fact</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token class-name">Factorial</span><span class="token punctuation">.</span><span class="token function">fact</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token class-name">Factorial</span><span class="token punctuation">.</span><span class="token function">fact</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token number">3628800</span><span class="token punctuation">,</span> <span class="token class-name">Factorial</span><span class="token punctuation">.</span><span class="token function">fact</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token number">2432902008176640000L</span><span class="token punctuation">,</span> <span class="token class-name">Factorial</span><span class="token punctuation">.</span><span class="token function">fact</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>核心测试方法 testFact() 加上了 @Test 注解，这是 JUnit 要求的，它会把带有 @Test 的方法识别为测试方法。在测试方法内部，我们用 assertEquals(1, Factorial.fact(1)) 表示，期望 Factorial.fact(1) 返回 1。assertEquals(expected, actual) 是最常用的测试方法，它在 Assertion 类中定义。Assertion 还定义了其他断言方法，例如：</p><ul><li>assertTrue(): 期待结果为 true</li><li>assertFalse(): 期待结果为 false</li><li>assertNotNull(): 期待结果为非 null</li><li>assertArrayEquals(): 期待结果为数组并与期望数组每个元素的值均相等</li><li>...</li></ul><p>运行单元测试非常简单。选中 FactorialTest.java 文件，点击 Run - Run As - JUnit Test，Eclipse 会自动运行这个 JUnit 测试，并显示结果：</p><figure><img src="`+m+'" alt="20221124100439" tabindex="0" loading="lazy"><figcaption>20221124100439</figcaption></figure><p>如果测试结果与预期不符，assertEquals() 会抛出异常，我们就会得到一个测试失败的结果：</p><figure><img src="'+v+`" alt="20221124100448" tabindex="0" loading="lazy"><figcaption>20221124100448</figcaption></figure><p>在 Failure Trace 中，JUnit 会告诉我们详细的错误结果：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>org.opentest4j.AssertionFailedError: expected: &lt;3628800&gt; but was: &lt;362880&gt;
	at org.junit.jupiter.api.AssertionUtils.fail(AssertionUtils.java:55)
	at org.junit.jupiter.api.AssertEquals.failNotEqual(AssertEquals.java:195)
	at org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:168)
	at org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:163)
	at org.junit.jupiter.api.Assertions.assertEquals(Assertions.java:611)
	at com.itranswarp.learnjava.FactorialTest.testFact(FactorialTest.java:14)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at ...
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第一行的失败信息的意思是期待结果 3628800 但是实际返回是 362880，此时，我们要么修正实现代码，要么修正测试代码，直到测试通过为止。</p><p>使用浮点数时，由于浮点数无法精确地进行比较，因此，我们需要调用 assertEquals(double expected, double actual, double delta) 这个重载方法，指定一个误差值：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> <span class="token number">9</span> <span class="token operator">/</span> <span class="token number">10.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0000001</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="🍀-单元测试的好处" tabindex="-1"><a class="header-anchor" href="#🍀-单元测试的好处" aria-hidden="true">#</a> 🍀 单元测试的好处</h2><p>单元测试可以确保单个方法按照正确预期运行，如果修改了某个方法的代码，只需确保其对应的单元测试通过，即可认为改动正确。此外，测试代码本身就可以作为示例代码，用来演示如何调用该方法。</p><p>使用 JUnit 进行单元测试，我们可以使用断言（Assertion）来测试期望结果，可以方便地组织和运行测试，并方便地查看测试结果。此外，JUnit 既可以直接在 IDE 中运行，也可以方便地集成到 Maven 这些自动化工具中运行。</p><p>在编写单元测试的时候，我们要遵循一定的规范：</p><p>一是单元测试代码本身必须非常简单，能一下看明白，决不能再为测试代码编写测试；</p><p>二是每个单元测试应当互相独立，不依赖运行的顺序；</p><p>三是测试时不但要覆盖常用测试用例，还要特别注意测试边界条件，例如输入为 0，null，空字符串 &quot;&quot; 等情况。</p><h2 id="🍀-练习" tabindex="-1"><a class="header-anchor" href="#🍀-练习" aria-hidden="true">#</a> 🍀 练习</h2><h2 id="🍀-小结" tabindex="-1"><a class="header-anchor" href="#🍀-小结" aria-hidden="true">#</a> 🍀 小结</h2><p>JUnit 是一个单元测试框架，专门用于运行我们编写的单元测试：</p><p>一个 JUnit 测试包含若干 @Test 方法，并使用 Assertions 进行断言，注意浮点数 assertEquals() 要指定 delta 。</p>`,40);function w(x,E){const a=c("router-link");return i(),o("div",null,[s("details",b,[h,s("nav",f,[s("ul",null,[s("li",null,[n(a,{to:"#🍀-junit"},{default:t(()=>[e("🍀 JUnit")]),_:1})]),s("li",null,[n(a,{to:"#🍀-单元测试的好处"},{default:t(()=>[e("🍀 单元测试的好处")]),_:1})]),s("li",null,[n(a,{to:"#🍀-练习"},{default:t(()=>[e("🍀 练习")]),_:1})]),s("li",null,[n(a,{to:"#🍀-小结"},{default:t(()=>[e("🍀 小结")]),_:1})])])])]),y,j,_])}const F=l(g,[["render",w],["__file","1.html.vue"]]);export{F as default};
