import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as c,o,c as l,a,b as s,w as t,d as i,e}from"./app-CvlAI_tu.js";const u={},r={class:"hint-container details"},k=a("summary",null,"目录",-1),d={class:"table-of-contents"},v=i(`<h2 id="🍀-简介" tabindex="-1"><a class="header-anchor" href="#🍀-简介" aria-hidden="true">#</a> 🍀 简介</h2><p>序列化是指把一个 Java 对象变成二进制内容，本质上就是一个 byte[] 数组。</p><p>为什么要把 Java 对象序列化呢？因为序列化后可以把 byte[] 保存到文件中，或者把 byte[] 通过网络传输到远程，这样，就相当于把 Java 对象存储到文件或者通过网络传输出去了。</p><p>有序列化，就有反序列化，即把一个二进制内容（也就是 byte[]数组）变回 Java 对象。有了反序列化，保存到文件中的 byte[]数组又可以 “变回”Java 对象，或者从网络上读取 byte[] 并把它“变回”Java 对象。</p><p>我们来看看如何把一个 Java 对象序列化。</p><p>一个 Java 对象要能序列化，必须实现一个特殊的 java.io.Serializable 接口，它的定义如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>Serializable 接口没有定义任何方法，它是一个空接口。我们把这样的空接口称为 “标记接口”（Marker Interface），实现了标记接口的类仅仅是给自身贴了个 “标记”，并没有增加任何方法。</p><h2 id="🍀-序列化" tabindex="-1"><a class="header-anchor" href="#🍀-序列化" aria-hidden="true">#</a> 🍀 序列化</h2><p>把一个 Java 对象变为 byte[] 数组，需要使用 ObjectOutputStream。它负责把一个 Java 对象写入一个字节流：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Arrays</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
        <span class="token class-name">ByteArrayOutputStream</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">ObjectOutputStream</span> output <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 写入int:</span>
            output<span class="token punctuation">.</span><span class="token function">writeInt</span><span class="token punctuation">(</span><span class="token number">12345</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 写入String:</span>
            output<span class="token punctuation">.</span><span class="token function">writeUTF</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 写入Object:</span>
            output<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span><span class="token class-name">Double</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">123.456</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ObjectOutputStream 既可以写入基本类型，如 int，boolean，也可以写入 String（以 UTF-8 编码），还可以写入实现了 Serializable 接口的 Object。</p><p>因为写入 Object 时需要大量的类型信息，所以写入的内容很大。</p><h2 id="🍀-反序列化" tabindex="-1"><a class="header-anchor" href="#🍀-反序列化" aria-hidden="true">#</a> 🍀 反序列化</h2><p>和 ObjectOutputStream 相反，ObjectInputStream 负责从一个字节流读取 Java 对象：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">ObjectInputStream</span> input <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">readInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> s <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">readUTF</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Double</span> d <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Double</span><span class="token punctuation">)</span> input<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除了能读取基本类型和 String 类型外，调用 readObject() 可以直接返回一个 Object 对象。要把它变成一个特定类型，必须强制转型。</p><p>readObject() 可能抛出的异常有：</p><ul><li>ClassNotFoundException：没有找到对应的 Class；</li><li>InvalidClassException：Class 不匹配。</li></ul><p>对于 ClassNotFoundException ，这种情况常见于一台电脑上的 Java 程序把一个 Java 对象，例如，Person 对象序列化以后，通过网络传给另一台电脑上的另一个 Java 程序，但是这台电脑的 Java 程序并没有定义 Person 类，所以无法反序列化。</p><p>对于 InvalidClassException，这种情况常见于序列化的 Person 对象定义了一个 int 类型的 age 字段，但是反序列化时，Person 类定义的 age 字段被改成了 long 类型，所以导致 class 不兼容。</p><p>为了避免这种 class 定义变动导致的不兼容，Java 的序列化允许 class 定义一个特殊的 serialVersionUID 静态变量，用于标识 Java 类的序列化 “版本”，通常可以由 IDE 自动生成。如果增加或修改了字段，可以改变 serialVersionUID 的值，这样就能自动阻止不匹配的 class 版本：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">2709425275741743919L</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要特别注意反序列化的几个重要特点：</p><p>反序列化时，由 JVM 直接构造出 Java 对象，不调用构造方法，构造方法内部的代码，在反序列化时根本不可能执行。</p><h2 id="🍀-安全性" tabindex="-1"><a class="header-anchor" href="#🍀-安全性" aria-hidden="true">#</a> 🍀 安全性</h2><p>因为 Java 的序列化机制可以导致一个实例能直接从 byte[] 数组创建，而不经过构造方法，因此，它存在一定的安全隐患。一个精心构造的 byte[] 数组被反序列化后可以执行特定的 Java 代码，从而导致严重的安全漏洞。</p><p>实际上，Java 本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过 JSON 这样的通用数据结构来实现，只输出基本类型（包括 String）的内容，而不存储任何与代码相关的信息。</p><h2 id="🍀-小结" tabindex="-1"><a class="header-anchor" href="#🍀-小结" aria-hidden="true">#</a> 🍀 小结</h2><p>可序列化的 Java 对象必须实现 java.io.Serializable 接口，类似 Serializable 这样的空接口被称为 “标记接口”（Marker Interface）；</p><p>反序列化时不调用构造方法，可设置 serialVersionUID 作为版本号（非必需）；</p><p>Java 的序列化机制仅适用于 Java，如果需要与其它语言交换数据，必须使用通用的序列化方法，例如 JSON。</p>`,32);function m(b,h){const n=c("router-link");return o(),l("div",null,[a("details",r,[k,a("nav",d,[a("ul",null,[a("li",null,[s(n,{to:"#🍀-简介"},{default:t(()=>[e("🍀 简介")]),_:1})]),a("li",null,[s(n,{to:"#🍀-序列化"},{default:t(()=>[e("🍀 序列化")]),_:1})]),a("li",null,[s(n,{to:"#🍀-反序列化"},{default:t(()=>[e("🍀 反序列化")]),_:1})]),a("li",null,[s(n,{to:"#🍀-安全性"},{default:t(()=>[e("🍀 安全性")]),_:1})]),a("li",null,[s(n,{to:"#🍀-小结"},{default:t(()=>[e("🍀 小结")]),_:1})])])])]),v])}const j=p(u,[["render",m],["__file","7.html.vue"]]);export{j as default};
