import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as p,o as c,c as i,a as n,b as a,w as e,e as s,d as u}from"./app-CvlAI_tu.js";const d="/VueDoc/assets/l-DFbtL-uB.jpeg",r={},k={class:"hint-container details"},g=n("summary",null,"目录",-1),m={class:"table-of-contents"},v=u(`<p>哈希算法（Hash）又称摘要算法（Digest），它的作用是：对任意一组输入数据进行计算，得到一个固定长度的输出摘要。</p><p>哈希算法最重要的特点就是：</p><ul><li>相同的输入一定得到相同的输出；</li><li>不同的输入大概率得到不同的输出。</li></ul><p>哈希算法的目的就是为了验证原始数据是否被篡改。</p><p>Java 字符串的 <code>hashCode()</code> 就是一个哈希算法，它的输入是任意字符串，输出是固定的 4 字节 <code>int</code> 整数：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token string">&quot;hello&quot;</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0x5e918d2</span>
<span class="token string">&quot;hello, java&quot;</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0x7a9d88e8</span>
<span class="token string">&quot;hello, bob&quot;</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0xa0dbae2f</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>两个相同的字符串永远会计算出相同的 <code>hashCode</code>，否则基于 <code>hashCode</code> 定位的 <code>HashMap</code> 就无法正常工作。这也是为什么当我们自定义一个 class 时，覆写 <code>equals()</code> 方法时我们必须正确覆写 <code>hashCode()</code> 方法。</p><h3 id="哈希碰撞" tabindex="-1"><a class="header-anchor" href="#哈希碰撞" aria-hidden="true">#</a> 哈希碰撞</h3><p>哈希碰撞是指，两个不同的输入得到了相同的输出：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token string">&quot;AaAaAa&quot;</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0x7460e8c0</span>
<span class="token string">&quot;BBAaBB&quot;</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0x7460e8c0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>有童鞋会问：碰撞能不能避免？答案是不能。碰撞是一定会出现的，因为输出的字节长度是固定的，<code>String</code> 的 <code>hashCode()</code> 输出是 4 字节整数，最多只有 4294967296 种输出，但输入的数据长度是不固定的，有无数种输入。所以，哈希算法是把一个无限的输入集合映射到一个有限的输出集合，必然会产生碰撞。</p><p>碰撞不可怕，我们担心的不是碰撞，而是碰撞的概率，因为碰撞概率的高低关系到哈希算法的安全性。一个安全的哈希算法必须满足：</p><ul><li>碰撞概率低；</li><li>不能猜测输出。</li></ul><p>不能猜测输出是指，输入的任意一个 bit 的变化会造成输出完全不同，这样就很难从输出反推输入（只能依靠暴力穷举）。假设一种哈希算法有如下规律：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token function">hashA</span><span class="token punctuation">(</span><span class="token string">&quot;java001&quot;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">&quot;123456&quot;</span>
<span class="token function">hashA</span><span class="token punctuation">(</span><span class="token string">&quot;java002&quot;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">&quot;123457&quot;</span>
<span class="token function">hashA</span><span class="token punctuation">(</span><span class="token string">&quot;java003&quot;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">&quot;123458&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么很容易从输出 <code>123459</code> 反推输入，这种哈希算法就不安全。安全的哈希算法从输出是看不出任何规律的：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token function">hashB</span><span class="token punctuation">(</span><span class="token string">&quot;java001&quot;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">&quot;123456&quot;</span>
<span class="token function">hashB</span><span class="token punctuation">(</span><span class="token string">&quot;java002&quot;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">&quot;580271&quot;</span>
<span class="token function">hashB</span><span class="token punctuation">(</span><span class="token string">&quot;java003&quot;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">?</span><span class="token operator">?</span><span class="token operator">?</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>常用的哈希算法有：</p><table><thead><tr><th style="text-align:left;">算法</th><th style="text-align:left;">输出长度（位）</th><th style="text-align:left;">输出长度（字节）</th></tr></thead><tbody><tr><td style="text-align:left;">MD5</td><td style="text-align:left;">128 bits</td><td style="text-align:left;">16 bytes</td></tr><tr><td style="text-align:left;">SHA-1</td><td style="text-align:left;">160 bits</td><td style="text-align:left;">20 bytes</td></tr><tr><td style="text-align:left;">RipeMD-160</td><td style="text-align:left;">160 bits</td><td style="text-align:left;">20 bytes</td></tr><tr><td style="text-align:left;">SHA-256</td><td style="text-align:left;">256 bits</td><td style="text-align:left;">32 bytes</td></tr><tr><td style="text-align:left;">SHA-512</td><td style="text-align:left;">512 bits</td><td style="text-align:left;">64 bytes</td></tr></tbody></table><p>根据碰撞概率，哈希算法的输出长度越长，就越难产生碰撞，也就越安全。</p><p>Java 标准库提供了常用的哈希算法，并且有一套统一的接口。我们以 MD5 算法为例，看看如何对输入计算哈希：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>math<span class="token punctuation">.</span></span><span class="token class-name">BigInteger</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>security<span class="token punctuation">.</span></span><span class="token class-name">MessageDigest</span></span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建一个 MessageDigest 实例:</span>
        <span class="token class-name">MessageDigest</span> md <span class="token operator">=</span> <span class="token class-name">MessageDigest</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">&quot;MD5&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 反复调用 update 输入数据:</span>
        md<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">&quot;UTF-8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        md<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token string">&quot;World&quot;</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">&quot;UTF-8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> md<span class="token punctuation">.</span><span class="token function">digest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 16 bytes: 68e109f0f40ca72a15e05cc22786f8e6</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BigInteger</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 <code>MessageDigest</code> 时，我们首先根据哈希算法获取一个 <code>MessageDigest</code> 实例，然后，反复调用 <code>update(byte[])</code> 输入数据。当输入结束后，调用 <code>digest()</code> 方法获得 byte[] 数组表示的摘要，最后，把它转换为十六进制的字符串。</p><p>运行上述代码，可以得到输入 <code>HelloWorld</code> 的 MD5 是 <code>68e109f0f40ca72a15e05cc22786f8e6</code>。</p><h3 id="哈希算法的用途" tabindex="-1"><a class="header-anchor" href="#哈希算法的用途" aria-hidden="true">#</a> 哈希算法的用途</h3><p>因为相同的输入永远会得到相同的输出，因此，如果输入被修改了，得到的输出就会不同。</p><p>我们在网站上下载软件的时候，经常看到下载页显示的哈希：</p><figure><img src="`+d+`" alt="file-md5" tabindex="0" loading="lazy"><figcaption>file-md5</figcaption></figure><p>如何判断下载到本地的软件是原始的、未经篡改的文件？我们只需要自己计算一下本地文件的哈希值，再与官网公开的哈希值对比，如果相同，说明文件下载正确，否则，说明文件已被篡改。</p><p>哈希算法的另一个重要用途是存储用户口令。如果直接将用户的原始口令存放到数据库中，会产生极大的安全风险：</p><ul><li>数据库管理员能够看到用户明文口令；</li><li>数据库数据一旦泄漏，黑客即可获取用户明文口令。</li></ul><p>不存储用户的原始口令，那么如何对用户进行认证？</p><p>方法是存储用户口令的哈希，例如，MD5。</p><p>在用户输入原始口令后，系统计算用户输入的原始口令的 MD5 并与数据库存储的 MD5 对比，如果一致，说明口令正确，否则，口令错误。</p><p>因此，数据库存储用户名和口令的表内容应该像下面这样：</p><table><thead><tr><th style="text-align:left;">username</th><th style="text-align:left;">password</th></tr></thead><tbody><tr><td style="text-align:left;">bob</td><td style="text-align:left;">f30aa7a662c728b7407c54ae6bfd27d1</td></tr><tr><td style="text-align:left;">alice</td><td style="text-align:left;">25d55ad283aa400af464c76d713c07ad</td></tr><tr><td style="text-align:left;">tim</td><td style="text-align:left;">bed128365216c019988915ed3add75fb</td></tr></tbody></table><p>这样一来，数据库管理员看不到用户的原始口令。即使数据库泄漏，黑客也无法拿到用户的原始口令。想要拿到用户的原始口令，必须用暴力穷举的方法，一个口令一个口令地试，直到某个口令计算的 MD5 恰好等于指定值。</p><p>使用哈希口令时，还要注意防止彩虹表攻击。</p><p>什么是彩虹表呢？上面讲到了，如果只拿到 MD5，从 MD5 反推明文口令，只能使用暴力穷举的方法。</p><p>然而黑客并不笨，暴力穷举会消耗大量的算力和时间。但是，如果有一个预先计算好的常用口令和它们的 MD5 的对照表：</p><table><thead><tr><th style="text-align:left;">常用口令</th><th style="text-align:left;">MD5</th></tr></thead><tbody><tr><td style="text-align:left;">hello123</td><td style="text-align:left;">f30aa7a662c728b7407c54ae6bfd27d1</td></tr><tr><td style="text-align:left;">12345678</td><td style="text-align:left;">25d55ad283aa400af464c76d713c07ad</td></tr><tr><td style="text-align:left;">passw0rd</td><td style="text-align:left;">bed128365216c019988915ed3add75fb</td></tr><tr><td style="text-align:left;">19700101</td><td style="text-align:left;">570da6d5277a646f6552b8832012f5dc</td></tr><tr><td style="text-align:left;">…</td><td style="text-align:left;">…</td></tr><tr><td style="text-align:left;">20201231</td><td style="text-align:left;">6879c0ae9117b50074ce0a0d4c843060</td></tr></tbody></table><p>这个表就是彩虹表。如果用户使用了常用口令，黑客从 MD5 一下就能反查到原始口令：</p><p>bob 的 MD5：<code>f30aa7a662c728b7407c54ae6bfd27d1</code>，原始口令：<code>hello123</code>；</p><p>alice 的 MD5：<code>25d55ad283aa400af464c76d713c07ad</code>，原始口令：<code>12345678</code>；</p><p>tim 的 MD5：<code>bed128365216c019988915ed3add75fb</code>，原始口令：<code>passw0rd</code>。</p><p>这就是为什么不要使用常用密码，以及不要使用生日作为密码的原因。</p><p>即使用户使用了常用口令，我们也可以采取措施来抵御彩虹表攻击，方法是对每个口令额外添加随机数，这个方法称之为加盐（salt）：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>digest <span class="token operator">=</span> <span class="token function">md5</span><span class="token punctuation">(</span>salt<span class="token operator">+</span>inputPassword<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>经过加盐处理的数据库表，内容如下：</p><table><thead><tr><th style="text-align:left;">username</th><th style="text-align:left;">salt</th><th style="text-align:left;">password</th></tr></thead><tbody><tr><td style="text-align:left;">bob</td><td style="text-align:left;">H1r0a</td><td style="text-align:left;">a5022319ff4c56955e22a74abcc2c210</td></tr><tr><td style="text-align:left;">alice</td><td style="text-align:left;">7$p2w</td><td style="text-align:left;">e5de688c99e961ed6e560b972dab8b6a</td></tr><tr><td style="text-align:left;">tim</td><td style="text-align:left;">z5Sk9</td><td style="text-align:left;">1eee304b92dc0d105904e7ab58fd2f64</td></tr></tbody></table><p>加盐的目的在于使黑客的彩虹表失效，即使用户使用常用口令，也无法从 MD5 反推原始口令。</p><h3 id="sha-1" tabindex="-1"><a class="header-anchor" href="#sha-1" aria-hidden="true">#</a> SHA-1</h3><p>SHA-1 也是一种哈希算法，它的输出是 160 bits，即 20 字节。SHA-1 是由美国国家安全局开发的，SHA 算法实际上是一个系列，包括 SHA-0（已废弃）、SHA-1、SHA-256、SHA-512 等。</p><p>在 Java 中使用 SHA-1，和 MD5 完全一样，只需要把算法名称改为 <code>&quot;SHA-1&quot;</code>：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>math<span class="token punctuation">.</span></span><span class="token class-name">BigInteger</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>security<span class="token punctuation">.</span></span><span class="token class-name">MessageDigest</span></span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建一个 MessageDigest 实例:</span>
        <span class="token class-name">MessageDigest</span> md <span class="token operator">=</span> <span class="token class-name">MessageDigest</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">&quot;SHA-1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 反复调用 update 输入数据:</span>
        md<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">&quot;UTF-8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        md<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token string">&quot;World&quot;</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">&quot;UTF-8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> md<span class="token punctuation">.</span><span class="token function">digest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 20 bytes: db8ac1c259eb89d4a131b253bacfca5f319d54f2</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BigInteger</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,55),b=n("code",null,'"SHA-256"',-1),f=n("code",null,'"SHA-512"',-1),h={href:"https://docs.oracle.com/en/java/javase/14/docs/specs/security/standard-names.html#messagedigest-algorithms",target:"_blank",rel:"noopener noreferrer"},y=n("p",null,"注意：MD5 因为输出长度较短，短时间内破解是可能的，目前已经不推荐使用。",-1),x=n("h3",{id:"小结",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#小结","aria-hidden":"true"},"#"),s(" 小结")],-1),q=n("p",null,"哈希算法可用于验证数据完整性，具有防篡改检测的功能；",-1),_=n("p",null,"常用的哈希算法有 MD5、SHA-1 等；",-1),j=n("p",null,"用哈希存储口令时要考虑彩虹表攻击。",-1);function D(M,w){const t=p("router-link"),o=p("ExternalLinkIcon");return c(),i("div",null,[n("details",k,[g,n("nav",m,[n("ul",null,[n("li",null,[a(t,{to:"#哈希碰撞"},{default:e(()=>[s("哈希碰撞")]),_:1})]),n("li",null,[a(t,{to:"#哈希算法的用途"},{default:e(()=>[s("哈希算法的用途")]),_:1})]),n("li",null,[a(t,{to:"#sha-1"},{default:e(()=>[s("SHA-1")]),_:1})]),n("li",null,[a(t,{to:"#小结"},{default:e(()=>[s("小结")]),_:1})])])])]),v,n("p",null,[s("类似的，计算 SHA-256，我们需要传入名称 "),b,s("，计算 SHA-512，我们需要传入名称 "),f,s("。Java 标准库支持的所有哈希算法可以在 "),n("a",h,[s("这里"),a(o)]),s(" 查到。")]),y,x,q,_,j])}const H=l(r,[["render",D],["__file","2.html.vue"]]);export{H as default};
