import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as e,o as t,c as p,a as n,b as o,w as c,d as l,e as i}from"./app-CvlAI_tu.js";const u={},d={class:"hint-container details"},k=n("summary",null,"目录",-1),r={class:"table-of-contents"},m=l(`<p>前面介绍的 <code>ReadWriteLock</code> 可以解决多线程同时读，但只有一个线程能写的问题。</p><p>如果我们深入分析 <code>ReadWriteLock</code>，会发现它有个潜在的问题：如果有线程正在读，写线程需要等待读线程释放锁后才能获取写锁，即读的过程中不允许写，这是一种悲观的读锁。</p><p>要进一步提升并发执行效率，Java 8 引入了新的读写锁：<code>StampedLock</code>。</p><p><code>StampedLock</code> 和 <code>ReadWriteLock</code> 相比，改进之处在于：读的过程中也允许获取写锁后写入！这样一来，我们读的数据就可能不一致，所以，需要一点额外的代码来判断读的过程中是否有写入，这种读锁是一种乐观锁。</p><p>乐观锁的意思就是乐观地估计读的过程中大概率不会有写入，因此被称为乐观锁。反过来，悲观锁则是读的过程中拒绝有写入，也就是写入必须等待。显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。</p><p>我们来看例子：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">StampedLock</span> stampedLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StampedLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">double</span> x<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">double</span> y<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">move</span><span class="token punctuation">(</span><span class="token keyword">double</span> deltaX<span class="token punctuation">,</span> <span class="token keyword">double</span> deltaY<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">long</span> stamp <span class="token operator">=</span> stampedLock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取写锁</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            x <span class="token operator">+=</span> deltaX<span class="token punctuation">;</span>
            y <span class="token operator">+=</span> deltaY<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            stampedLock<span class="token punctuation">.</span><span class="token function">unlockWrite</span><span class="token punctuation">(</span>stamp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 释放写锁</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">distanceFromOrigin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">long</span> stamp <span class="token operator">=</span> stampedLock<span class="token punctuation">.</span><span class="token function">tryOptimisticRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获得一个乐观读锁</span>
        <span class="token comment">// 注意下面两行代码不是原子操作</span>
        <span class="token comment">// 假设 x,y = (100,200)</span>
        <span class="token keyword">double</span> currentX <span class="token operator">=</span> x<span class="token punctuation">;</span>
        <span class="token comment">// 此处已读取到 x=100，但 x,y 可能被写线程修改为 (300,400)</span>
        <span class="token keyword">double</span> currentY <span class="token operator">=</span> y<span class="token punctuation">;</span>
        <span class="token comment">// 此处已读取到 y，如果没有写入，读取是正确的 (100,200)</span>
        <span class="token comment">// 如果有写入，读取是错误的 (100,400)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>stampedLock<span class="token punctuation">.</span><span class="token function">validate</span><span class="token punctuation">(</span>stamp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 检查乐观读锁后是否有其他写锁发生</span>
            stamp <span class="token operator">=</span> stampedLock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取一个悲观读锁</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                currentX <span class="token operator">=</span> x<span class="token punctuation">;</span>
                currentY <span class="token operator">=</span> y<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                stampedLock<span class="token punctuation">.</span><span class="token function">unlockRead</span><span class="token punctuation">(</span>stamp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 释放悲观读锁</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>currentX <span class="token operator">*</span> currentX <span class="token operator">+</span> currentY <span class="token operator">*</span> currentY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>和 <code>ReadWriteLock</code> 相比，写入的加锁是完全一样的，不同的是读取。注意到首先我们通过 <code>tryOptimisticRead()</code> 获取一个乐观读锁，并返回版本号。接着进行读取，读取完成后，我们通过 <code>validate()</code> 去验证版本号，如果在读取过程中没有写入，版本号不变，验证成功，我们就可以放心地继续后续操作。如果在读取过程中有写入，版本号会发生变化，验证将失败。在失败的时候，我们再通过获取悲观读锁再次读取。由于写入的概率不高，程序在绝大部分情况下可以通过乐观读锁获取数据，极少数情况下使用悲观读锁获取数据。</p><p>可见，<code>StampedLock</code> 把读锁细分为乐观读和悲观读，能进一步提升并发效率。但这也是有代价的：一是代码更加复杂，二是 <code>StampedLock</code> 是不可重入锁，不能在一个线程中反复获取同一个锁。</p><p><code>StampedLock</code> 还提供了更复杂的将悲观读锁升级为写锁的功能，它主要使用在 if-then-update 的场景：即先读，如果读的数据满足条件，就返回，如果读的数据不满足条件，再尝试写。</p><h2 id="🍀-小结" tabindex="-1"><a class="header-anchor" href="#🍀-小结" aria-hidden="true">#</a> 🍀 小结</h2><p><code>StampedLock</code> 提供了乐观读锁，可取代 <code>ReadWriteLock</code> 以进一步提升并发性能；</p><p><code>StampedLock</code> 是不可重入锁。</p>`,13);function v(b,y){const s=e("router-link");return t(),p("div",null,[n("details",d,[k,n("nav",r,[n("ul",null,[n("li",null,[o(s,{to:"#🍀-小结"},{default:c(()=>[i("🍀 小结")]),_:1})])])])]),m])}const _=a(u,[["render",v],["__file","13.html.vue"]]);export{_ as default};
