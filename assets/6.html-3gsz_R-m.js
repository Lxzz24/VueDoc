import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as c,o as p,c as i,a as n,b as s,w as o,d as l,e as t}from"./app-CvlAI_tu.js";const u={},d={class:"hint-container details"},r=n("summary",null,"目录",-1),k={class:"table-of-contents"},m=l(`<p>我们在讲多线程的时候说过，创建线程是一个昂贵的操作，如果有大量的小任务需要执行，并且频繁地创建和销毁线程，实际上会消耗大量的系统资源，往往创建和消耗线程所耗费的时间比执行任务的时间还长，所以，为了提高效率，可以用线程池。</p><p>类似的，在执行 JDBC 的增删改查的操作时，如果每一次操作都来一次打开连接，操作，关闭连接，那么创建和销毁 JDBC 连接的开销就太大了。为了避免频繁地创建和销毁 JDBC 连接，我们可以通过连接池（Connection Pool）复用已经创建好的连接。</p><p>JDBC 连接池有一个标准的接口 <code>javax.sql.DataSource</code>，注意这个类位于 Java 标准库中，但仅仅是接口。要使用 JDBC 连接池，我们必须选择一个 JDBC 连接池的实现。常用的 JDBC 连接池有：</p><ul><li>HikariCP</li><li>C3P0</li><li>BoneCP</li><li>Druid</li></ul><p>目前使用最广泛的是 HikariCP。我们以 HikariCP 为例，要使用 JDBC 连接池，先添加 HikariCP 的依赖如下：</p><ul><li>com.zaxxer:HikariCP:2.7.1</li></ul><p>紧接着，我们需要创建一个 <code>DataSource</code> 实例，这个实例就是连接池：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">HikariConfig</span> config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HikariConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
config<span class="token punctuation">.</span><span class="token function">setJdbcUrl</span><span class="token punctuation">(</span><span class="token string">&quot;jdbc:mysql://localhost:3306/test&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
config<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">&quot;root&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
config<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">&quot;password&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
config<span class="token punctuation">.</span><span class="token function">addDataSourceProperty</span><span class="token punctuation">(</span><span class="token string">&quot;connectionTimeout&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;1000&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 连接超时：1 秒</span>
config<span class="token punctuation">.</span><span class="token function">addDataSourceProperty</span><span class="token punctuation">(</span><span class="token string">&quot;idleTimeout&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;60000&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 空闲超时：60 秒</span>
config<span class="token punctuation">.</span><span class="token function">addDataSourceProperty</span><span class="token punctuation">(</span><span class="token string">&quot;maximumPoolSize&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;10&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 最大连接数：10</span>
<span class="token class-name">DataSource</span> ds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HikariDataSource</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意创建 <code>DataSource</code> 也是一个非常昂贵的操作，所以通常 <code>DataSource</code> 实例总是作为一个全局变量存储，并贯穿整个应用程序的生命周期。</p><p>有了连接池以后，我们如何使用它呢？和前面的代码类似，只是获取 <code>Connection</code> 时，把 <code>DriverManage.getConnection()</code> 改为 <code>ds.getConnection()</code>：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">Connection</span> conn <span class="token operator">=</span> ds<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 在此获取连接</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span> <span class="token comment">// 在此 “关闭” 连接</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过连接池获取连接时，并不需要指定 JDBC 的相关 URL、用户名、口令等信息，因为这些信息已经存储在连接池内部了（创建 <code>HikariDataSource</code> 时传入的 <code>HikariConfig</code> 持有这些信息）。一开始，连接池内部并没有连接，所以，第一次调用 <code>ds.getConnection()</code>，会迫使连接池内部先创建一个 <code>Connection</code>，再返回给客户端使用。当我们调用 <code>conn.close()</code> 方法时（<code> 在 try(resource){...}</code> 结束处），不是真正 “关闭” 连接，而是释放到连接池中，以便下次获取连接时能直接返回。</p><p>因此，连接池内部维护了若干个 <code>Connection</code> 实例，如果调用 <code>ds.getConnection()</code>，就选择一个空闲连接，并标记它为 “正在使用” 然后返回，如果对 <code>Connection</code> 调用 <code>close()</code>，那么就把连接再次标记为 “空闲” 从而等待下次调用。这样一来，我们就通过连接池维护了少量连接，但可以频繁地执行大量的 SQL 语句。</p><p>通常连接池提供了大量的参数可以配置，例如，维护的最小、最大活动连接数，指定一个连接在空闲一段时间后自动关闭等，需要根据应用程序的负载合理地配置这些参数。此外，大多数连接池都提供了详细的实时状态以便进行监控。</p><h2 id="🍀-练习" tabindex="-1"><a class="header-anchor" href="#🍀-练习" aria-hidden="true">#</a> 🍀 练习</h2><p>使用 HikariCP 连接池</p><h2 id="🍀-小结" tabindex="-1"><a class="header-anchor" href="#🍀-小结" aria-hidden="true">#</a> 🍀 小结</h2><p>数据库连接池是一种复用 <code>Connection</code> 的组件，它可以避免反复创建新连接，提高 JDBC 代码的运行效率；</p><p>可以配置连接池的详细参数并监控连接池。</p>`,19);function v(C,g){const a=c("router-link");return p(),i("div",null,[n("details",d,[r,n("nav",k,[n("ul",null,[n("li",null,[s(a,{to:"#🍀-练习"},{default:o(()=>[t("🍀 练习")]),_:1})]),n("li",null,[s(a,{to:"#🍀-小结"},{default:o(()=>[t("🍀 小结")]),_:1})])])])]),m])}const h=e(u,[["render",v],["__file","6.html.vue"]]);export{h as default};
