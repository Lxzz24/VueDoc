import{_ as c}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as t,o as d,c as l,a,b as s,w as n,d as r,e as o}from"./app-CvlAI_tu.js";const i={},p={class:"hint-container details"},v=a("summary",null,"目录",-1),u={class:"table-of-contents"},J=r(`<p>在 Java 开发中，许多童鞋经常被各种版本的 JDK 搞得晕头转向，本节我们就来详细讲解 Java 程序编译后的 class 文件版本问题。</p><p>我们通常说的 Java 8，Java 11，Java 17，是指 JDK 的版本，也就是 JVM 的版本，更确切地说，就是 <code>java.exe</code> 这个程序的版本：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ java -version
java version &quot;17&quot; 2021-09-14 LTS
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>而每个版本的 JVM ，它能执行的 class 文件版本也不同。例如，Java 11 对应的 class 文件版本是 55，而 Java 17 对应的 class 文件版本是 61。</p><p>如果用 Java 11 编译一个 Java 程序，输出的 class 文件版本默认就是 55，这个 class 既可以在 Java 11 上运行，也可以在 Java 17 上运行，因为 Java 17 支持的 class 文件版本是 61，表示 “最多支持到版本 61”。</p><p>如果用 Java 17 编译一个 Java 程序，输出的 class 文件版本默认就是 61，它可以在 Java 17、Java 18 上运行，但不可能在 Java 11 上运行，因为 Java 11 支持的 class 版本最多到 55。如果使用低于 Java 17 的 JVM 运行，会得到一个 <code>UnsupportedClassVersionError</code>，错误信息类似：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>java.lang.UnsupportedClassVersionError: Xxx has been compiled by a more recent version of the Java Runtime...
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>只要看到 <code>UnsupportedClassVersionError</code> 就表示当前要加载的 class 文件版本超过了 JVM 的能力，必须使用更高版本的 JVM 才能运行。</p><p>打个比方，用 Word 2013 保存一个 Word 文件，这个文件也可以在 Word 2016 上打开。但反过来，用 Word 2016 保存一个 Word 文件，就无法使用 Word 2013 打开。</p><p>但是，且慢，用 Word 2016 也可以保存一个格式为 Word 2013 的文件，这样保存的 Word 文件就可以用低版本的 Word 2013 打开，但前提是保存时必须明确指定文件格式兼容 Word 2013。</p><p>类似的，对应到 JVM 的 class 文件，我们也可以用 Java 17 编译一个 Java 程序，指定输出的 class 版本要兼容 Java 11（即 class 版本 55），这样编译生成的 class 文件就可以在 Java &gt;= 11 的环境中运行。</p><p><strong><em>指定编译输出</em></strong> 有两种方式，一种是 <strong><em>在 <code>javac</code> 命令行中用参数 <code>--release</code> 设置</em></strong> ：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ javac --release 11 Main.java
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>参数 <code>--release 11</code> 表示源码兼容 Java 11，编译的 class 输出版本为 Java 11 兼容，即 class 版本 55。</p><p>第二种方式是 <strong><em>用参数 <code>--source</code> 指定源码版本</em></strong> ，<strong><em>用参数 <code>--target</code> 指定输出 class 版本</em></strong>：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ javac --source 9 --target 11 Main.java
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上述命令如果使用 Java 17 的 JDK 编译，它会把源码视为 Java 9 兼容版本，并输出 class 为 Java 11 兼容版本。</p><p>注意 <code>--release</code> 参数和 <code>--source --target</code> 参数只能二选一，不能同时设置。</p><p>然而，指定版本如果低于当前的 JDK 版本，会有一些潜在的问题。例如，我们用 Java 17 编译 Hello.java，参数设置 <code>--source 9</code> 和 <code>--target 11</code>：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Hello</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">.</span><span class="token function">indent</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>用低于 Java 11 的 JVM 运行 <code>Hello</code> 会得到一个 <code>LinkageError</code>，因为无法加载 <code>Hello.class</code> 文件，而用 Java 11 运行 <code>Hello</code> 会得到一个 <code>NoSuchMethodError</code>，因为 <code>String.indent()</code> 方法是从 Java 12 才添加进来的，Java 11 的 <code>String</code> 版本根本没有 <code>indent()</code> 方法。</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>注：如果使用 <code>--release 11</code> 则会在编译时检查该方法是否在 Java 11 中存在。</p></div><p>因此，如果运行时的 JVM 版本是 Java 11，则编译时也最好使用 Java 11，而不是用高版本的 JDK 编译输出低版本的 class 。</p><p>如果使用 <code>javac</code> 编译时不指定任何版本参数，那么相当于使用 <code>--release</code> 当前版本编译，即源码版本和输出版本均为当前版本。</p><p>在开发阶段，多个版本的 JDK 可以同时安装，当前使用的 JDK 版本可由 <code>JAVA_HOME</code> 环境变量切换。</p><h2 id="🍀-源码版本" tabindex="-1"><a class="header-anchor" href="#🍀-源码版本" aria-hidden="true">#</a> 🍀 源码版本</h2><p>在编写源代码的时候，我们通常会预设一个源码的版本。在编译的时候，如果用 <code>--source</code> 或 <code>--release</code> 指定源码版本，则使用指定的源码版本检查语法。</p><p>例如，使用了 lambda 表达式的源码版本至少要为 8 才能编译，使用了 <code>var</code> 关键字的源码版本至少要为 10 才能编译，使用 <code>switch</code> 表达式的源码版本至少要为 12 才能编译，且 12 和 13 版本需要启用 <code>--enable-preview</code> 参数。</p><h2 id="🍀-小结" tabindex="-1"><a class="header-anchor" href="#🍀-小结" aria-hidden="true">#</a> 🍀 小结</h2><p>高版本的 JDK 可编译输出低版本兼容的 class 文件，但需注意，低版本的 JDK 可能不存在高版本 JDK 添加的类和方法，导致运行时报错。</p><p>运行时使用哪个 JDK 版本，编译时就尽量使用同一版本编译源码。</p>`,31);function m(g,k){const e=t("router-link");return d(),l("div",null,[a("details",p,[v,a("nav",u,[a("ul",null,[a("li",null,[s(e,{to:"#🍀-源码版本"},{default:n(()=>[o("🍀 源码版本")]),_:1})]),a("li",null,[s(e,{to:"#🍀-小结"},{default:n(()=>[o("🍀 小结")]),_:1})])])])]),J])}const x=c(i,[["render",m],["__file","14.html.vue"]]);export{x as default};
