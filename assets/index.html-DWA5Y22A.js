import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as p,o as u,c as l,a as e,b as a,w as r,d,e as i}from"./app-CvlAI_tu.js";const s="/VueDoc/assets/20221123100417-7O-Y_arB.png",o="/VueDoc/assets/20221123100441-TZCYiiZA.png",c="/VueDoc/assets/20221123100507-BhSohm6X.png",m={},h={class:"hint-container details"},_=e("summary",null,"目录",-1),I={class:"table-of-contents"},f=d('<p>IO 是指 Input/Output，即输入和输出。以内存为中心：</p><ul><li>Input 指从外部读入数据到内存，例如，把文件从磁盘读取到内存，从网络读取数据到内存等等。</li><li>Output 指把数据从内存输出到外部，例如，把数据从内存写入到文件，把数据从内存输出到网络等等。</li></ul><p>为什么要把数据读到内存才能处理这些数据？因为代码是在内存中运行的，数据也必须读到内存，最终的表示方式无非是 byte 数组，字符串等，都必须存放在内存里。</p><p>从 Java 代码来看，输入实际上就是从外部，例如，硬盘上的某个文件，把内容读到内存，并且以 Java 提供的某种数据类型表示，例如，byte[]，String，这样，后续代码才能处理这些数据。</p><p>因为内存有 “易失性” 的特点，所以必须把处理后的数据以某种方式输出，例如，写入到文件。Output 实际上就是把 Java 表示的数据格式，例如，byte[]，String 等输出到某个地方。</p><p>IO 流是一种顺序读写数据的模式，它的特点是单向流动。数据类似自来水一样在水管中流动，所以我们把它称为 IO 流。</p><figure><img src="'+s+'" alt="20221123100417" tabindex="0" loading="lazy"><figcaption>20221123100417</figcaption></figure><h2 id="🍀-inputstream-outputstream" tabindex="-1"><a class="header-anchor" href="#🍀-inputstream-outputstream" aria-hidden="true">#</a> 🍀 InputStream / OutputStream</h2><p>IO 流以 byte（字节）为最小单位，因此也称为字节流。例如，我们要从磁盘读入一个文件，包含 6 个字节，就相当于读入了 6 个字节的数据：</p><figure><img src="'+o+'" alt="20221123100441" tabindex="0" loading="lazy"><figcaption>20221123100441</figcaption></figure><p>这 6 个字节是按顺序读入的，所以是输入字节流。</p><p>反过来，我们把 6 个字节从内存写入磁盘文件，就是输出字节流：</p><figure><img src="'+c+`" alt="20221123100507" tabindex="0" loading="lazy"><figcaption>20221123100507</figcaption></figure><p>在 Java 中，InputStream 代表输入字节流，OuputStream 代表输出字节流，这是最基本的两种 IO 流。</p><h2 id="🍀-reader-writer" tabindex="-1"><a class="header-anchor" href="#🍀-reader-writer" aria-hidden="true">#</a> 🍀 Reader / Writer</h2><p>如果我们需要读写的是字符，并且字符不全是单字节表示的 ASCII 字符，那么，按照 char 来读写显然更方便，这种流称为 <em><strong>字符流</strong></em> 。</p><p>Java 提供了 Reader 和 Writer 表示字符流，字符流传输的最小数据单位是 char。</p><p>例如，我们把 char[] 数组 Hi 你好这 4 个字符用 Writer 字符流写入文件，并且使用 UTF-8 编码，得到的最终文件内容是 8 个字节，英文字符 H 和 i 各占一个字节，中文字符你好各占 3 个字节：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>0x48
0x69
0xe4bda0
0xe5a5bd
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>反过来，我们用 Reader 读取以 UTF-8 编码的这 8 个字节，会从 Reader 中得到 Hi 你好这 4 个字符。</p><p>因此，Reader 和 Writer 本质上是一个能自动编解码的 InputStream 和 OutputStream。</p><p>使用 Reader，数据源虽然是字节，但我们读入的数据都是 char 类型的字符，原因是 Reader 内部把读入的 byte 做了解码，转换成了 char。使用 InputStream，我们读入的数据和原始二进制数据一模一样，是 byte[] 数组，但是我们可以自己把二进制 byte[] 数组按照某种编码转换为字符串。究竟使用 Reader 还是 InputStream，要取决于具体的使用场景。如果数据源不是文本，就只能使用 InputStream，如果数据源是文本，使用 Reader 更方便一些。Writer 和 OutputStream 是类似的。</p><h2 id="🍀-同步和异步" tabindex="-1"><a class="header-anchor" href="#🍀-同步和异步" aria-hidden="true">#</a> 🍀 同步和异步</h2><p>同步 IO 是指，读写 IO 时代码必须等待数据返回后才继续执行后续代码，它的优点是代码编写简单，缺点是 CPU 执行效率低。</p><p>而异步 IO 是指，读写 IO 时仅发出请求，然后立刻执行后续代码，它的优点是 CPU 执行效率高，缺点是代码编写复杂。</p><p>Java 标准库的包 java.io 提供了同步 IO，而 java.nio 则是异步 IO。上面我们讨论的 InputStream、OutputStream、Reader 和 Writer 都是同步 IO 的抽象类，对应的具体实现类，以文件为例，有 FileInputStream、FileOutputStream、FileReader 和 FileWriter。</p><p>本节我们只讨论 Java 的同步 IO，即输入 / 输出流的 IO 模型。</p><h2 id="🍀-小结" tabindex="-1"><a class="header-anchor" href="#🍀-小结" aria-hidden="true">#</a> 🍀 小结</h2><p>IO 流是一种流式的数据输入 / 输出模型：</p><ul><li>二进制数据以 byte 为最小单位在 InputStream/OutputStream 中单向流动；</li><li>字符数据以 char 为最小单位在 Reader/Writer 中单向流动。</li></ul><p>Java 标准库的 java.io 包提供了同步 IO 功能：</p><ul><li>字节流接口：InputStream / OutputStream；</li><li>字符流接口：Reader / Writer。</li></ul>`,32);function g(O,v){const t=p("router-link");return u(),l("div",null,[e("details",h,[_,e("nav",I,[e("ul",null,[e("li",null,[a(t,{to:"#🍀-inputstream-outputstream"},{default:r(()=>[i("🍀 InputStream / OutputStream")]),_:1})]),e("li",null,[a(t,{to:"#🍀-reader-writer"},{default:r(()=>[i("🍀 Reader / Writer")]),_:1})]),e("li",null,[a(t,{to:"#🍀-同步和异步"},{default:r(()=>[i("🍀 同步和异步")]),_:1})]),e("li",null,[a(t,{to:"#🍀-小结"},{default:r(()=>[i("🍀 小结")]),_:1})])])])]),f])}const x=n(m,[["render",g],["__file","index.html.vue"]]);export{x as default};
