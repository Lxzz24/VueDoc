import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as t,o as d,c as i,a as s,b as n,w as e,e as a,d as o}from"./app-CvlAI_tu.js";const u="/VueDoc/assets/20221122104817-C6eWaVe9.png",k="/VueDoc/assets/20221122104843-iPDRkM_g.png",r={},m={class:"hint-container details"},v=s("summary",null,"目录",-1),h={class:"table-of-contents"},g=o(`<p>我们知道 <code>Map</code> 是一种 <strong>键-值</strong>（key-value）映射表，可以通过 <code>key</code> 快速查找对应的 <code>value</code> 。</p><p>以 <code>HashMap</code> 为例，观察下面的代码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Xiao Ming&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Xiao Hong&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;c&quot;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Xiao Jun&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Person(&quot;Xiao Ming&quot;)</span>
map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;x&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// null</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>HashMap</code> 之所以能根据 <code>key</code> 直接拿到 <code>value</code>，原因是它内部通过 <em>空间换时间</em> 的方法，用一个大数组存储所有 <code>value</code>，并根据 <code>key</code> 直接计算出 <code>value</code> 应该存储在哪个索引：</p><figure><img src="`+u+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如果 <code>key</code> 的值为 <code>&quot;a&quot;</code>，计算得到的索引总是 <code>1</code>，因此返回 <code>value</code> 为 <code>Person(&quot;Xiao Ming&quot;)</code>，如果 <code>key</code> 的值为 <code>&quot;b&quot;</code>，计算得到的索引总是 <code>5</code>，因此返回 <code>value</code> 为 <code>Person(&quot;Xiao Hong&quot;)</code>，这样，就不必遍历整个数组，即可直接读取 <code>key</code> 对应的 <code>value</code> 。</p><hr><p>当我们使用 <code>key</code> 存取 <code>value</code> 的时候，就会引出一个问题：</p><p>我们放入 <code>Map</code> 的 <code>key</code> 是字符串 <code>&quot;a&quot;</code>，但是，当我们获取 <code>Map</code> 的 <code>value</code> 时，传入的变量不一定就是放入的那个 <code>key</code> 对象。</p><p>换句话讲，两个 <code>key</code> 应该是内容相同，但不一定是同一个对象。测试代码如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">HashMap</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Map</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> key1 <span class="token operator">=</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">;</span>
        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key1<span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">String</span> key2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 123</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>key1 <span class="token operator">==</span> key2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>key1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为在 <code>Map</code> 的内部，对 <code>key</code> 做比较是通过 <code>equals()</code> 实现的，这一点和 <code>List</code> 查找元素需要正确覆写 <code>equals()</code> 是一样的，即正确使用 <code>Map</code> 必须保证：作为 <code>key</code> 的对象必须正确覆写 <code>equals()</code> 方法。</p><p>我们经常使用 <code>String</code> 作为 <code>key</code>，因为 <code>String</code> 已经正确覆写了 <code>equals()</code> 方法。但如果我们放入的 <code>key</code> 是一个自己写的类，就必须保证正确覆写了 <code>equals()</code> 方法。</p><hr><p>我们再思考一下 <code>HashMap</code> 为什么能通过 <code>key</code> 直接计算出 <code>value</code> 存储的索引。相同的 <code>key</code> 对象（使用 <code>equals()</code> 判断时返回 <code>true</code> ）必须要计算出相同的索引，否则，相同的 <code>key</code> 每次取出的 <code>value</code> 就不一定对。</p><p>通过 <code>key</code> 计算索引的方式就是调用 <code>key</code> 对象的 <code>hashCode()</code> 方法，它返回一个 <code>int</code> 整数。<code>HashMap</code> 正是通过这个方法直接定位 <code>key</code> 对应的 <code>value</code> 的索引，继而直接返回 <code>value</code> 。</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>因此，正确使用 <code>Map</code> 必须保证：</p><ol><li>作为 <code>key</code> 的对象必须正确覆写 <code>equals()</code> 方法，相等的两个 <code>key</code> 实例调用 <code>equals()</code> 必须返回 <code>true</code> ；</li><li>作为 <code>key</code> 的对象还必须正确覆写 <code>hashCode()</code> 方法，且 <code>hashCode()</code> 方法要严格遵循以下规范： <ul><li>如果两个对象相等，则两个对象的 <code>hashCode()</code> 必须相等；</li><li>如果两个对象不相等，则两个对象的 <code>hashCode()</code> 尽量不要相等。</li></ul></li></ol><p>即对应两个实例 <code>a</code> 和 <code>b</code> ：</p><ul><li>如果 <code>a</code> 和 <code>b</code> 相等，那么 <code>a.equals(b)</code> 一定为 <code>true</code>，则 <code>a.hashCode()</code> 必须等于 <code>b.hashCode()</code> ；</li><li>如果 <code>a</code> 和 <code>b</code> 不相等，那么 <code>a.equals(b)</code> 一定为 <code>false</code>，则 <code>a.hashCode()</code> 和 <code>b.hashCode()</code> 尽量不要相等。</li></ul></div><p>上述第一条规范是正确性，必须保证实现，否则 <code>HashMap</code> 不能正常工作。</p><p>而第二条如果尽量满足，则可以保证查询效率，因为不同的对象，如果返回相同的 <code>hashCode()</code>，会造成 <code>Map</code> 内部存储冲突，使存取的效率下降。</p>`,19),b=s("code",null,"equals()",-1),y=s("code",null,"Person",-1),q=o(`<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> firstName<span class="token punctuation">;</span>
    <span class="token class-name">String</span> lastName<span class="token punctuation">;</span>
    <span class="token keyword">int</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>把需要比较的字段找出来：</p><ul><li>firstName</li><li>lastName</li><li>age</li></ul><p>然后，引用类型使用 <code>Objects.equals()</code> 比较，基本类型使用 <code>==</code> 比较。</p><hr><p>在正确实现 <code>equals()</code> 的基础上，我们还需要正确实现 <code>hashCode()</code>，即上述 3 个字段分别相同的实例，<code>hashCode()</code> 返回的 <code>int</code> 必须相同：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> firstName<span class="token punctuation">;</span>
    <span class="token class-name">String</span> lastName<span class="token punctuation">;</span>
    <span class="token keyword">int</span> age<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        h <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">*</span> h <span class="token operator">+</span> firstName<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        h <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">*</span> h <span class="token operator">+</span> lastName<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        h <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">*</span> h <span class="token operator">+</span> age<span class="token punctuation">;</span>
        <span class="token keyword">return</span> h<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意到 <code>String</code> 类已经正确实现了 <code>hashCode()</code> 方法，我们在计算 <code>Person</code> 的 <code>hashCode()</code> 时，反复使用 <code>31*h</code>，这样做的目的是为了尽量把不同的 <code>Person</code> 实例的 <code>hashCode()</code> 均匀分布到整个 <code>int</code> 范围。</p><p>和实现 <code>equals()</code> 方法遇到的问题类似，如果 <code>firstName</code> 或 <code>lastName</code> 为 <code>null</code>，上述代码工作起来就会抛 <code>NullPointerException</code> 。为了解决这个问题，我们在计算 <code>hashCode()</code> 的时候，经常借助 <code>Objects.hash()</code> 来计算：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hash</span><span class="token punctuation">(</span>firstName<span class="token punctuation">,</span> lastName<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以，编写 <code>equals()</code> 和 <code>hashCode()</code> 遵循的原则是：</p><p><code>equals()</code> 用到的用于比较的每一个字段，都必须在 <code>hashCode()</code> 中用于计算； <code>equals()</code> 中没有使用到的字段，绝不可放在 <code>hashCode()</code> 中计算。</p><p>另外注意，对于放入 <code>HashMap</code> 的 <code>value</code> 对象，没有任何要求。</p><h2 id="🍀-延伸阅读" tabindex="-1"><a class="header-anchor" href="#🍀-延伸阅读" aria-hidden="true">#</a> 🍀 延伸阅读</h2><p>既然 <code>HashMap</code> 内部使用了数组，通过计算 <code>key</code> 的 <code>hashCode()</code> 直接定位 <code>value</code> 所在的索引，那么第一个问题来了： <code>hashCode()</code> 返回的 <code>int</code> 范围高达 ±21 亿，先不考虑负数，<code>HashMap</code> 内部使用的数组得有多大？</p><p>实际上 <code>HashMap</code> 初始化时默认的数组大小只有 16 ，任何 <code>key</code>，无论它的 <code>hashCode()</code> 有多大，都可以简单地通过：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">int</span> index <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xf</span><span class="token punctuation">;</span> <span class="token comment">// 0xf = 15</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>把索引确定在 0 ～ 15，即永远不会超出数组范围，上述算法只是一种最简单的实现。</p><p>第二个问题：如果添加超过 16 个 <code>key-value</code> 到 <code>HashMap</code>，数组不够用了怎么办？</p><p>添加超过一定数量的 <code>key-value</code> 时，<code>HashMap</code> 会在内部自动扩容，每次扩容一倍，即长度为 16 的数组扩展为长度 32，相应地，需要重新确定 <code>hashCode()</code> 计算的索引位置。例如，对长度为 32 的数组计算 <code>hashCode()</code> 对应的索引，计算方式要改为：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">int</span> index <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x1f</span><span class="token punctuation">;</span> <span class="token comment">// 0x1f = 31</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>由于扩容会导致重新分布已有的 <code>key-value</code>，所以，频繁扩容对 <code>HashMap</code> 的性能影响很大。如果我们确定要使用一个容量为 10000 个 <code>key-value</code> 的 <code>HashMap</code>，更好的方式是创建 <code>HashMap</code> 时就指定容量：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,23),f=s("p",null,[a("虽然指定容量是 "),s("code",null,"10000"),a("，但 "),s("code",null,"HashMap"),a(" 内部的数组长度总是 "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mn",null,"2"),s("mi",null,"n")])]),s("annotation",{encoding:"application/x-tex"},"2^n")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6644em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},"2"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.6644em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight"},"n")])])])])])])])])])]),a(" ，因此，实际数组长度被初始化为比 "),s("code",null,"10000"),a(" 大的 "),s("code",null,"16384"),a(" （ "),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mn",null,"2"),s("mn",null,"14")])]),s("annotation",{encoding:"application/x-tex"},"2^{14}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8141em"}}),s("span",{class:"mord"},[s("span",{class:"mord"},"2"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8141em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mtight"},"14")])])])])])])])])])])]),a("）。")],-1),w=o(`<p>最后一个问题：如果不同的两个 <code>key</code>，例如 <code>&quot;a&quot;</code> 和 <code>&quot;b&quot;</code>，它们的 <code>hashCode()</code> 恰好是相同的（这种情况是完全可能的，因为不相等的两个实例，只要求 <code>hashCode()</code> 尽量不相等），那么，当我们放入：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Xiao Ming&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Xiao Hong&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>时，由于计算出的数组索引相同，后面放入的 <code>&quot;Xiao Hong&quot;</code> 会不会把 <code>&quot;Xiao Ming&quot;</code> 覆盖了？</p><p>当然不会！使用 <code>Map</code> 的时候，只要 <code>key</code> 不相同，它们映射的 <code>value</code> 就互不干扰。但是，在 <code>HashMap</code> 内部，确实可能存在不同的 <code>key</code>，映射到相同的 <code>hashCode()</code>，即相同的数组索引上，肿么办？</p><p>我们就假设 <code>&quot;a&quot;</code> 和 <code>&quot;b&quot;</code> 这两个 <code>key</code> 最终计算出的索引都是 <code>5</code>，那么，在 <code>HashMap</code> 的数组中，实际存储的不是一个 <code>Person</code> 实例，而是一个 <code>List</code>，它包含两个 <code>Entry</code>，一个是 <code>&quot;a&quot;</code> 的映射，一个是 <code>&quot;b&quot;</code> 的映射：</p><figure><img src="`+k+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在查找的时候，例如：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Person</span> p <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>HashMap</code> 内部通过 <code>&quot;a&quot;</code> 找到的实际上是 <code>List&lt;Entry&lt;String, Person&gt;&gt;</code>，它还需要遍历这个 <code>List</code>，并找到一个 <code>Entry</code>，它的 <code>key</code> 字段是 <code>&quot;a&quot;</code>，才能返回对应的 <code>Person</code> 实例。</p><p>我们把不同的 <code>key</code> 具有相同的 <code>hashCode()</code> 的情况称之为哈希冲突。在冲突的时候，一种最简单的解决办法是用 <code>List</code> 存储 <code>hashCode()</code> 相同的 <code>key-value</code> 。显然，如果冲突的概率越大，这个 <code>List</code> 就越长，<code>Map</code> 的 <code>get()</code> 方法效率就越低，这就是为什么要尽量满足条件二：</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>如果两个对象不相等，则两个对象的 <code>hashCode()</code> 尽量不要相等。</p></div><p><code>hashCode()</code> 方法编写得越好，<code>HashMap</code> 工作的效率就越高。</p><h2 id="🍀-小结" tabindex="-1"><a class="header-anchor" href="#🍀-小结" aria-hidden="true">#</a> 🍀 小结</h2><ol><li><p>要正确使用 <code>HashMap</code>，作为 <code>key</code> 的类必须正确覆写 <code>equals()</code> 和 <code>hashCode()</code> 方法；</p></li><li><p>一个类如果覆写了 <code>equals()</code>，就必须覆写 <code>hashCode()</code>，并且覆写规则是：</p><ul><li>（正确性）如果 <code>equals()</code> 返回 <code>true</code>，则 <code>hashCode()</code> 返回值必须相等；</li><li>（效率性）如果 <code>equals()</code> 返回 <code>false</code>，则 <code>hashCode()</code> 返回值尽量不要相等。</li></ul></li><li><p>实现 <code>hashCode()</code> 方法可以通过 <code>Objects.hashCode()</code> 辅助方法实现。</p></li></ol><div class="hint-container tip"><p class="hint-container-title">提示</p><p>hashmap 中依据 <code>key</code> 的 hash 值来确定 <code>value</code> 存储位置，所以一定要重写 <code>hashCode()</code> 方法，而重写 <code>equals()</code> 方法，是为了解决 hash 冲突，如果两个 <code>key</code> 的 hash 值相同，就会调用 <code>equals()</code> 方法，比较 <code>key</code> 值是否相同。</p><ul><li>在存储时：如果 <code>equals()</code> 结果相同就覆盖更新 <code>value</code> 值，如果不同就用 List 他们都存储起来。</li><li>在取出来是：如果 <code>equals()</code> 结果相同就返回当前 <code>value</code> 值，如果不同就遍历 List 中下一个元素。即要 <code>key</code> 与 <code>hash</code> 同时匹配才会认为是同一个 <code>key</code>。</li></ul><p>JDK 中源码:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>ops<span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></div>`,15);function M(C,_){const c=t("router-link"),p=t("RouterLink");return d(),i("div",null,[s("details",m,[v,s("nav",h,[s("ul",null,[s("li",null,[n(c,{to:"#🍀-延伸阅读"},{default:e(()=>[a("🍀 延伸阅读")]),_:1})]),s("li",null,[n(c,{to:"#🍀-小结"},{default:e(()=>[a("🍀 小结")]),_:1})])])])]),g,s("p",null,[a("正确编写 "),b,a(" 的方法我们已经在 "),n(p,{to:"/1-Java/7_%E9%9B%86%E5%90%88/3.html"},{default:e(()=>[a("编写 equals 方法")]),_:1}),a(" 一节中讲过了，以 "),y,a(" 类为例：")]),q,f,w])}const H=l(r,[["render",M],["__file","5.html.vue"]]);export{H as default};
